<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Block Blast</title>
    <script type="text/javascript" src="cordova.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            user-select: none;
            touch-action: none; /* é˜²æ­¢è§¦æ‘¸æ»šåŠ¨ */
            overflow-x: hidden;
        }

        .container {
            display: flex;
            max-width: 1200px;
            margin: 0 auto;
            gap: 30px;
            /* è®©å†…å®¹åœ¨è§†å£å†…å‚ç›´å±…ä¸­ï¼Œä¸Šä¸‹å¤šä½™ç©ºé—´å¯¹ç§°åˆ†é…ï¼ˆæ‰£é™¤ body çš„ä¸Šä¸‹ padding å„20ï¼‰ */
            min-height: calc(100vh - 40px);
            align-items: center;
        }

        .developer-panel {
            width: 250px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            height: fit-content;
        }

        .game-panel {
            flex: 1;
            text-align: center;
        }

        h1 {
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            font-size: 24px;
        }

        .score {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            color: white;
        }

        .combo {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 15px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            color: white;
        }

        .settings {
            margin-bottom: 20px;
        }

        .settings label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .settings select {
            width: 100%;
            padding: 8px;
            border-radius: 8px;
            border: none;
            background: rgba(255,255,255,0.2);
            color: white;
            margin-bottom: 15px;
        }

        .settings select option {
            background: #333;
            color: white;
        }

        .game-board {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            margin: 0 auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 10px;
            margin: 0 auto 30px;
            max-width: 400px;
        }

        .cell {
            aspect-ratio: 1;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            transition: all 0.2s ease;
            border: 1px solid rgba(255,255,255,0.2);
            position: relative;
            overflow: hidden;
        }

        .cell.filled {
            /* ç›˜é¢ï¼šå»é™¤äº®è¾¹ï¼Œåªä¿ç•™æŸ”å’Œçš„å†…æš—è¾¹ä¸å†…è¾‰ */
            box-shadow:
                inset 0 -1px 2px rgba(0,0,0,0.18),
                inset 0 0 2px rgba(0,0,0,0.12);
            border-color: rgba(255,255,255,0.18);
        }
        .cell.filled::before, .cell.filled::after { content: none !important; }

        .cell.color-1 { background: linear-gradient(45deg, #ff6b6b, #ee5a24); }
        .cell.color-2 { background: linear-gradient(45deg, #4ecdc4, #44a08d); }
        .cell.color-3 { background: linear-gradient(45deg, #a8e6cf, #56ab2f); }
        .cell.color-4 { background: linear-gradient(45deg, #ffd93d, #ff9f40); }
        .cell.color-5 { background: linear-gradient(45deg, #b19cd9, #8e44ad); }
        .cell.color-6 { background: linear-gradient(45deg, #fd79a8, #e84393); }
        .cell.color-7 { background: linear-gradient(45deg, #74b9ff, #0984e3); }
        .cell.color-8 { background: linear-gradient(45deg, #fd79a8, #fdcb6e); }

        .cell.highlight {
            /* ä¸å†ä½¿ç”¨åŸé«˜äº® */
        }
        .cell.projection {
            /* åªåšç¼©æ”¾ï¼Œé€æ˜åº¦ç”¨jsæ§åˆ¶ */
            transform: scale(1.0);
        }

        .cell.invalid {
            background: rgba(255,0,0,0.3);
        }

        .cell.pre-clear {
            z-index: 10;
        }
        .cell.pre-clear.pre-clear-color-1 { box-shadow: 0 0 0 3px #ff6b6b, 0 0 16px 6px #ff6b6b88; border-color: #ff6b6b !important; }
        .cell.pre-clear.pre-clear-color-2 { box-shadow: 0 0 0 3px #4ecdc4, 0 0 16px 6px #4ecdc488; border-color: #4ecdc4 !important; }
        .cell.pre-clear.pre-clear-color-3 { box-shadow: 0 0 0 3px #56ab2f, 0 0 16px 6px #56ab2f88; border-color: #56ab2f !important; }
        .cell.pre-clear.pre-clear-color-4 { box-shadow: 0 0 0 3px #ffd93d, 0 0 16px 6px #ffd93d88; border-color: #ffd93d !important; }
        .cell.pre-clear.pre-clear-color-5 { box-shadow: 0 0 0 3px #8e44ad, 0 0 16px 6px #8e44ad88; border-color: #8e44ad !important; }
        .cell.pre-clear.pre-clear-color-6 { box-shadow: 0 0 0 3px #e84393, 0 0 16px 6px #e8439388; border-color: #e84393 !important; }
        .cell.pre-clear.pre-clear-color-7 { box-shadow: 0 0 0 3px #0984e3, 0 0 16px 6px #0984e388; border-color: #0984e3 !important; }
        .cell.pre-clear.pre-clear-color-8 { box-shadow: 0 0 0 3px #fdcb6e, 0 0 16px 6px #fdcb6e88; border-color: #fdcb6e !important; }

        .shapes-container {
            display: flex;
            justify-content: center; /* ä¸æ£‹ç›˜å±…ä¸­å¯¹é½ */
            flex-wrap: nowrap;
            margin-left: 0; /* ç§»é™¤å›ºå®šåç§»ï¼Œé¿å…å·¦å³ä¸å¯¹é½ */
            width: 100%; /* è®©å®¹å™¨å æ»¡æ£‹ç›˜å®½åº¦ä»¥ä¾¿å±…ä¸­ */
        }
        .shape-slot {
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        /* å¢å¤§ä¸­é—´sloté—´éš” */
        .shape-slot:not(:last-child) {
            margin-right: 30px;
        }
        .shape-slot:nth-child(2) {
            margin-right: 60px;
        }

        .shape {
            /* å®Œå…¨å»é™¤èƒŒæ¿å’Œè¾¹ç•Œæ•ˆæœ */
            background: none;
            border-radius: 10px;
            padding: 15px;
            cursor: grab;
            transition: all 0.3s ease;
            border: none;
            /* ä¸´æ—¶å…³é—­ä»»ä½•æŠ•å½±æ•ˆæœ */
            box-shadow: none;
        }

        /* å…³é—­æ‚¬åœåé¦ˆï¼šåç»­å¦åšè®¾è®¡ï¼Œè¿™é‡Œä¿æŒé™ç½®å¤–è§‚ä¸€è‡´ */
        .shape:hover { box-shadow: none; transform: none; }

        .shape.dragging {
            cursor: grabbing;
            /* é¿å…ç¼©æ”¾å¯¼è‡´ä¸­å¿ƒç‚¹è®¡ç®—åç§» */
            transform: none;
            /* é¿å…å†…è¾¹è·å¯¼è‡´ä¸­å¿ƒç‚¹è®¡ç®—åç§» */
            padding: 0;
            z-index: 1000;
            position: fixed;
            pointer-events: none;
            transition: none;
            /* å…³é—­æ‹–æ‹½æŠ•å½± */
            box-shadow: none;
        }
        /* æ‹–æ‹½ä¸­ï¼šä»…ä¿ç•™å†…å‡¹/å‡¸èµ·çš„å†…é˜´å½±ï¼Œä¸åŠ ä»»ä½•å¤–æŠ•å½± */
        .shape.dragging .shape-cell.filled {
            /* æ‹–æ‹½ä¸­ï¼šä¸ç›˜é¢ä¸€è‡´çš„"æ— äº®è¾¹"å†…é˜´å½±ï¼›æ— ä»»ä½•å¤–å½± */
            box-shadow:
                inset 0 -1px 2px rgba(0,0,0,0.18),
                inset 0 0 2px rgba(0,0,0,0.12) !important;
            border-color: rgba(255,255,255,0.12) !important;
        }

        /* é˜´å½±æ¨¡å¼å¼€å…³ï¼ˆä»…ä½œç”¨äºå‡ºå—åŒºå°æ ¼ .shape-cellï¼‰ */
        /* hardï¼šé»˜è®¤åœ¨ .shape-cell.filled ä¸Šå®šä¹‰ï¼Œæ— éœ€é¢å¤–ç±» */
        body.shadow-soft .shape-cell.filled {
            /* æŸ”å…‰æ¨¡å¼ï¼šä¸ç›˜é¢ä¸€è‡´çš„"æ— äº®è¾¹"å‡¸èµ· + æŸ”å…‰å¤–å½± */
            box-shadow:
                inset 0 -1px 2px rgba(0,0,0,0.18),
                inset 0 0 2px rgba(0,0,0,0.12),
                0 16px 36px rgba(0,0,0,0.24),
                0 32px 72px rgba(0,0,0,0.15);
            border-color: rgba(255,255,255,0.18);
        }
        body.shadow-none .shape-cell.filled { box-shadow: none !important; }

        .shape-grid {
            display: grid;
            gap: 1px; /* å‡å°å•å…ƒé—´è·ï¼Œä½¿é˜´å½±è½®å»“æ›´èšåˆ */
        }

        .shape-cell {
            width: 25px;
            height: 25px;
            border-radius: 3px;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .shape-cell.filled {
            /* å‡ºå—åŒºï¼šä¸ç›˜é¢ä¸€è‡´çš„"æ— äº®è¾¹"å‡¸èµ· + ç¡¬è¾¹å¤–å½± */
            box-shadow:
                inset 0 -1px 2px rgba(0,0,0,0.18),
                inset 0 0 2px rgba(0,0,0,0.12),
                6px 6px 0 rgba(0,0,0,0.18);
            border: 1px solid rgba(255,255,255,0.18);
        }
        .shape-cell.filled::before, .shape-cell.filled::after { content: none !important; }

        .shape-cell.color-1 { background: linear-gradient(45deg, #ff6b6b, #ee5a24); }
        .shape-cell.color-2 { background: linear-gradient(45deg, #4ecdc4, #44a08d); }
        .shape-cell.color-3 { background: linear-gradient(45deg, #a8e6cf, #56ab2f); }
        .shape-cell.color-4 { background: linear-gradient(45deg, #ffd93d, #ff9f40); }
        .shape-cell.color-5 { background: linear-gradient(45deg, #b19cd9, #8e44ad); }
        .shape-cell.color-6 { background: linear-gradient(45deg, #fd79a8, #e84393); }
        .shape-cell.color-7 { background: linear-gradient(45deg, #74b9ff, #0984e3); }
        .shape-cell.color-8 { background: linear-gradient(45deg, #fd79a8, #fdcb6e); }

        .shape-cell.empty {
            background: transparent;
        }

        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .game-over-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            position: relative;
        }
        /* æ–°çºªå½•æ ·å¼ */
        .game-over-content.best-record #game-over-title {
            color: #FFD700;
            font-weight: 900;
            font-size: 40px; /* ä¿æŒä¸æ™®é€šç»“æŸç›¸è¿‘çš„æ¯”ä¾‹ */
            letter-spacing: 1px;
            text-shadow: 0 0 12px rgba(255,215,0,0.7), 2px 2px 6px rgba(0,0,0,0.5);
        }
        .game-over-content.best-record #final-score {
            color: #FFD700;
            font-size: 54px; /* ä¸é»˜è®¤æœ€ç»ˆåˆ†æ•°ä¸€è‡´ï¼Œé¿å…æ’‘å¤§å¼¹çª— */
        }
        /* å¼ºåŒ–è¯»æ•°çš„å¯è¯»æ€§ */
        .game-over-content #final-score {
            display: block;
            font-size: 54px;
            line-height: 1.1;
            margin-top: 6px;
            font-weight: 800;
        }
        .game-over-content #high-score {
            display: block;
            font-size: 40px;
            line-height: 1.1;
            margin-top: 6px;
            font-weight: 800;
        }
        .game-over-content #final-score-label,
        .game-over-content #high-score-label {
            font-size: 16px;
            opacity: 0.9;
        }
        
        .game-over-content #high-score {
            color: #FFD700;
            font-weight: bold;
            font-size: 14px;
        }
        
        .settings-icon {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            width: 40px;
            height: 40px;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }
        
        .settings-icon:hover {
            transform: rotate(90deg);
        }

        .restart-btn {
            background: linear-gradient(45deg, #56ab2f, #a8e6cf);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }



        .restart-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
        }
        
        .settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2100;
        }
        
        .settings-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            min-width: 280px;
        }
        
        .settings-content h3 {
            margin: 0 0 25px 0;
            color: white;
            font-size: 24px;
        }
        
        .setting-item {
            margin: 20px 0;
            text-align: left;
        }
        
        .setting-item label {
            display: flex;
            align-items: center;
            gap: 15px;
            cursor: pointer;
            font-size: 18px;
            color: white;
            font-weight: 500;
        }
        
        .setting-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #4CAF50;
        }
        
        .settings-content button {
            background: linear-gradient(45deg, #56ab2f, #a8e6cf);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 20px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 25px;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .settings-content button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
        }

        .hidden {
            display: none;
        }

        @keyframes clearAnimation {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); background: #ffd700; }
            100% { transform: scale(1); }
        }
        @keyframes clearAnimation-1 { 0%{transform:scale(1);} 50%{transform:scale(1.2);background:#ff6b6b;} 100%{transform:scale(1);} }
        @keyframes clearAnimation-2 { 0%{transform:scale(1);} 50%{transform:scale(1.2);background:#4ecdc4;} 100%{transform:scale(1);} }
        @keyframes clearAnimation-3 { 0%{transform:scale(1);} 50%{transform:scale(1.2);background:#56ab2f;} 100%{transform:scale(1);} }
        @keyframes clearAnimation-4 { 0%{transform:scale(1);} 50%{transform:scale(1.2);background:#ffd93d;} 100%{transform:scale(1);} }
        @keyframes clearAnimation-5 { 0%{transform:scale(1);} 50%{transform:scale(1.2);background:#8e44ad;} 100%{transform:scale(1);} }
        @keyframes clearAnimation-6 { 0%{transform:scale(1);} 50%{transform:scale(1.2);background:#e84393;} 100%{transform:scale(1);} }
        @keyframes clearAnimation-7 { 0%{transform:scale(1);} 50%{transform:scale(1.2);background:#0984e3;} 100%{transform:scale(1);} }
        @keyframes clearAnimation-8 { 0%{transform:scale(1);} 50%{transform:scale(1.2);background:#fdcb6e;} 100%{transform:scale(1);} }

        .clearing.clearing-color-1 { animation: clearAnimation-1 0.5s ease; }
        .clearing.clearing-color-2 { animation: clearAnimation-2 0.5s ease; }
        .clearing.clearing-color-3 { animation: clearAnimation-3 0.5s ease; }
        .clearing.clearing-color-4 { animation: clearAnimation-4 0.5s ease; }
        .clearing.clearing-color-5 { animation: clearAnimation-5 0.5s ease; }
        .clearing.clearing-color-6 { animation: clearAnimation-6 0.5s ease; }
        .clearing.clearing-color-7 { animation: clearAnimation-7 0.5s ease; }
        .clearing.clearing-color-8 { animation: clearAnimation-8 0.5s ease; }

        .combo-bonus {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 1500;
            animation: comboFade 2s ease-out forwards;
        }

        @keyframes comboFade {
            0% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1.2);
            }
            50% { 
                opacity: 1; 
                transform: translate(-50%, -80%) scale(1);
            }
            100% { 
                opacity: 0; 
                transform: translate(-50%, -100%) scale(0.8);
            }
        }
        
        .placement-score {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            font-weight: bold;
            color: #00ff00;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 1400;
            animation: placementFade 1.5s ease-out forwards;
        }
        
        @keyframes placementFade {
            0% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1);
            }
            50% { 
                opacity: 1; 
                transform: translate(-50%, -60%) scale(1.1);
            }
            100% { 
                opacity: 0; 
                transform: translate(-50%, -70%) scale(0.9);
            }
        }
        
        .elimination-score {
            position: fixed;
            font-size: 32px;
            font-weight: bold;
            color: var(--elim-color, #ff6b6b);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 1600;
            animation: eliminationFade 0.6s ease-out forwards;
        }
        /* ä»…æ”¾ç½®å¾—åˆ†ï¼ˆæ— æ¶ˆé™¤æ—¶ï¼‰ */
        .placement-score {
            position: fixed;
            font-size: 18px;
            font-weight: bold;
            color: rgba(255,255,255,0.9);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.6);
            pointer-events: none;
            z-index: 1500;
            animation: placementScoreFade 0.5s ease-out forwards;
        }
        @keyframes placementScoreFade {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -60%) scale(0.9); }
        }
        
        @keyframes eliminationFade {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(2);
            }
            20% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2);
            }
            90% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
        }
        
        .combo-effect {
            position: absolute;
            top: 50%;
            left: 50%;
            font-size: 48px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8), 0 0 20px rgba(255,215,0,0.5);
            pointer-events: none;
            z-index: 2000;
            animation: comboEffect 1.2s ease-out forwards;
        }
        
        @keyframes comboEffect {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.3);
                color: #ff6b6b;
            }
            15% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.8);
                color: #ffd700;
            }
            25% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.3);
                color: #ffd700;
            }
            70% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.3);
                color: #ffd700;
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
                color: #ffd700;
            }
        }
        
        @keyframes screenShake {
            0%, 100% { transform: translateX(0); }
            10% { transform: translateX(-5px); }
            20% { transform: translateX(5px); }
            30% { transform: translateX(-5px); }
            40% { transform: translateX(5px); }
            50% { transform: translateX(-3px); }
            60% { transform: translateX(3px); }
            70% { transform: translateX(-2px); }
            80% { transform: translateX(2px); }
            90% { transform: translateX(-1px); }
        }
        
        @keyframes particleExplosion {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--x, 100px), var(--y, -100px)) scale(0);
                opacity: 0;
            }
        }
        
        /* è¿å‡»æ–‡å­—åŠ¨ç”» */
        @keyframes comboText {
            0% {
                transform: translate(-50%, -50%) scale(0.3);
                opacity: 0;
            }
            15% {
                transform: translate(-50%, -50%) scale(1.4);
                opacity: 1;
            }
            70% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(1.6);
                opacity: 0;
            }
        }
        @media (max-width: 600px) {
            html, body {
                height: 100vh;
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }
            .game-panel {
                min-height: 100vh;
                width: 100vw;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: flex-start;
                padding: 0;
                padding-top: 12vh;
                padding-bottom: 4vh;
            }
            .score {
                width: 95vw;
                max-width: 95vw;
                text-align: center;
                font-size: 11vw;
                margin: 0 auto 4vw auto;
                padding: 0;
            }
            .game-board {
                width: 95vw;
                max-width: 95vw;
                margin: 0 auto 10vw auto;
                padding: 0;
                background: none !important;
                box-shadow: none !important;
                border-radius: 0 !important;
                box-sizing: border-box;
            }
            .grid {
                width: 100%;
                max-width: 100%;
                aspect-ratio: 1/1;
                margin: 0 auto;
                box-sizing: border-box;
            }
            .shapes-container {
                width: 95vw;
                max-width: 95vw;
                margin: 6vw auto 6vw auto;
                display: flex;
                justify-content: center;
                flex-wrap: wrap;
            }
            .shape-slot {
                width: 18vw;
                height: 18vw;
                max-width: 80px;
                max-height: 80px;
                margin-right: 3vw;
            }
            .shape-slot:last-child {
                margin-right: 0;
            }
        }
    </style>
</head>
<body>
    <audio id="eliminate-audio" src="https://cdn.pixabay.com/audio/2022/07/26/audio_124bfae5c7.mp3" preload="auto"></audio>
    <audio id="voice-nice" src="audio/nice.mp3" preload="auto"></audio>
    <audio id="voice-amazing" src="audio/amazing.mp3" preload="auto"></audio>
    <div class="container">
        <div class="developer-panel" id="developer-panel">
            <h1>ğŸ§© Block Blast</h1>
            
            <div class="settings">
                <label>é¢œè‰²ç§ç±»ï¼š</label>
                <select id="color-count-select">
                    <option value="3" selected>3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                    <option value="8">8</option>
                </select>
                
                <label>æ¯å—æœ€å¤šé¢œè‰²æ•°ï¼š</label>
                <select id="max-shape-color-select">
                    <option value="1">1</option>
                    <option value="2" selected>2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                </select>
            </div>
            
            <div class="combo">
                <span id="combo-text">Combo</span>: <span id="combo">x1.0</span>
            </div>
        </div>
        
        <div class="game-panel">
            <div class="score">
                <span id="score">0</span>
            </div>
            
            <div class="game-board">
                <div class="grid" id="grid"></div>
                <div class="shapes-container" id="shapes-container">
                    <div class="shape-slot" id="shape-slot-0"></div>
                    <div class="shape-slot" id="shape-slot-1"></div>
                    <div class="shape-slot" id="shape-slot-2"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="game-over hidden" id="game-over">
        <div class="game-over-content">
            <button class="settings-icon" onclick="showSettings()">âš™ï¸</button>
            <h2 id="game-over-title">Game Over</h2>
            <p><span id="final-score-label">Score</span><br/><span id="final-score">0</span></p>
            <p style="margin-top: 14px;"><span id="high-score-label">Best Score</span><br/><span id="high-score">0</span></p>
            <button id="restart-btn" class="restart-btn" onclick="restartGame()">Restart</button>
        </div>
    </div>
    
            <div id="settings-modal" class="settings-modal hidden">
            <div class="settings-content">
                <h3 id="settings-title">Settings</h3>
                <div class="setting-item">
                    <label>
                        <input type="checkbox" id="sound-toggle" checked>
                        <span id="sound-label">Sound</span>
                    </label>
                </div>
                <div class="setting-item">
                    <label>
                        <input type="checkbox" id="vibration-toggle">
                        <span id="vibration-label">Vibration</span>
                    </label>
                </div>
                <div class="setting-item">
                    <label>
                        <input type="checkbox" id="voice-toggle" checked>
                        <span id="voice-label">Voice</span>
                    </label>
                </div>
                <div class="setting-item">
                    <label>
                        <span id="language-label">Language</span>
                        <select id="language-select">
                            <option value="zh">ä¸­æ–‡</option>
                            <option value="en">English</option>
                        </select>
                    </label>
                </div>
                <div class="setting-item">
                    <a id="privacy-link" href="privacy-policy.html">Privacy Policy</a>
                </div>
                <button onclick="closeSettings()">OK</button>
        </div>
    </div>

    <script>
        // ATT æƒé™è¯·æ±‚ï¼ˆä»… iOS ç”Ÿæ•ˆï¼‰
        function requestATTrackingPermission() {
            // æ£€æŸ¥æ˜¯å¦åœ¨ iOS å¹³å°
            if (window.device && window.device.platform === 'iOS') {
                // æ£€æŸ¥ iOS ç‰ˆæœ¬æ˜¯å¦æ”¯æŒ ATT
                if (window.device.version && parseFloat(window.device.version) >= 14.5) {
                    // è¯·æ±‚ ATT æƒé™
                    if (typeof window.requestTrackingPermission === 'function') {
                        window.requestTrackingPermission().then(function(status) {
                            console.log('ATT Permission Status:', status);
                            // æƒé™è¯·æ±‚å®Œæˆååˆå§‹åŒ– AdMob
                            initAd();
                        }).catch(function(error) {
                            console.log('ATT Permission Error:', error);
                            // å³ä½¿å¤±è´¥ä¹Ÿåˆå§‹åŒ– AdMob
                            initAd();
                        });
                    } else {
                        // å¦‚æœä¸æ”¯æŒ ATTï¼Œç›´æ¥åˆå§‹åŒ– AdMob
                        initAd();
                    }
                } else {
                    // iOS ç‰ˆæœ¬å¤ªä½ï¼Œç›´æ¥åˆå§‹åŒ– AdMob
                    initAd();
                }
            } else {
                // é iOS å¹³å°ï¼Œç›´æ¥åˆå§‹åŒ– AdMob
                initAd();
            }
        }

        // è½»é‡çº§å¹¿å‘Šè°ƒè¯•å å±‚ï¼ˆæ— éœ€ logcatï¼‰ã€‚å‘å¸ƒå‰å¯å°† AD_DEBUG_ENABLED è®¾ä¸º falseã€‚
        const AD_DEBUG_ENABLED = false;
        function adDbg(message, isError) {
            if (!AD_DEBUG_ENABLED) return;
            try {
                let el = document.getElementById('ad-debug-overlay');
                if (!el) {
                    el = document.createElement('div');
                    el.id = 'ad-debug-overlay';
                    el.style.cssText = [
                        'position:fixed','left:8px','right:8px','bottom:60px','max-height:40vh','overflow:auto',
                        'background:rgba(0,0,0,0.6)','color:#c8f7c5','font:12px/1.4 monospace','padding:6px 8px',
                        'border-radius:6px','z-index:3000','box-shadow:0 2px 8px rgba(0,0,0,0.4)'
                    ].join(';');
                    document.body.appendChild(el);
                }
                const line = document.createElement('div');
                line.textContent = `${new Date().toLocaleTimeString()}  ${message}`;
                if (isError) line.style.color = '#ff6b6b';
                el.appendChild(line);
                // é™åˆ¶è¡Œæ•°
                while (el.children.length > 80) el.removeChild(el.firstChild);
            } catch(_) {}
        }
        window.__adDbg = adDbg;
        // ç®€å•æ›å…‰æ§åˆ¶ï¼šå†·å¯åŠ¨å»¶è¿Ÿï¼ˆæ¯«ç§’ï¼‰ã€‚å¯é€šè¿‡ window.CP8_BANNER_DELAY_MS è¦†ç›–ã€‚
        const BANNER_DELAY_MS = (typeof window.CP8_BANNER_DELAY_MS === 'number' && window.CP8_BANNER_DELAY_MS >= 0)
            ? window.CP8_BANNER_DELAY_MS
            : 90000;
        function scheduleBannerShow() {
            try { adDbg('å·²è®¡åˆ’åœ¨ ' + Math.round(BANNER_DELAY_MS/1000) + ' ç§’åå±•ç¤ºæ¨ªå¹…'); } catch(_) {}
            setTimeout(() => {
                try { adDbg('å†·å¯åŠ¨å»¶è¿Ÿåˆ°æœŸï¼Œå°è¯•åˆ›å»ºå¹¶æ˜¾ç¤ºæ¨ªå¹…...'); } catch(_) {}
                window.bannerShow();
            }, BANNER_DELAY_MS);
        }
        // å¾®ä¿¡å°ç¨‹åºé€‚é…å¼€å…³ï¼štrue å¼€å¯å°ç¨‹åºé€‚é…ï¼ˆå¼ºåˆ¶ä¸­æ–‡ã€å…³é—­è‹±æ–‡æ¿€åŠ±è¯ä¸é…éŸ³ï¼‰
        const WX_MINIPROGRAM_MODE = false;
        // æ‹–æ‹½æ—¶å°æ ¼çš„åƒç´ å®½é«˜ï¼ˆå¯è‡ªè¡Œè°ƒæ•´ï¼‰
        // const DRAG_CELL_SIZE = 42; // å·²åˆ é™¤ï¼Œæ”¹ç”¨åŠ¨æ€å°ºå¯¸
        let displayScore = 0;
        // å¯æ’æ‹”ï¼šå‡ºå—è¦†ç›–é’©å­ï¼ˆå¤–éƒ¨å¯ä¿®æ”¹ï¼‰ã€‚enabled: æ˜¯å¦å¯ç”¨ï¼›position: 'before' | 'after'
        window.CP8_HOOK = window.CP8_HOOK || { enabled: false, position: 'before' };
        // è‡ªå®šä¹‰ç”Ÿæˆå‡½æ•°ï¼šå…¥å‚ä¸º game å®ä¾‹ï¼›è¿”å› null/undefined è·³è¿‡ï¼›
        // è¦†ç›–æ—¶è¿”å›å½¢å¦‚ [{ pattern: number[][], colors: number[][] }, ...] çš„æ•°ç»„ï¼ˆå–å‰3ä¸ªï¼‰ã€‚
        window.CP8_generateShapes = window.CP8_generateShapes || function(game){ return null; };
        let scoreAnimationFrame = null;
        // å…¨å±€å”¯ä¸€éŸ³é¢‘ä¸Šä¸‹æ–‡
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        // è¯­éŸ³æ¿€åŠ±æ˜ å°„ï¼ˆå¼±â†’å¼ºï¼‰ï¼Œé˜ˆå€¼ä¸º"æœ¬æ¬¡æ¶ˆé™¤å—æ•°"
        const VOICE_CUES = [
            { id: 'cool', threshold: 12 },
            { id: 'wow', threshold: 13 },
            { id: 'whoa', threshold: 14 },
            { id: 'nice', threshold: 15 },
            { id: 'great', threshold: 16 },
            { id: 'goodjob', threshold: 17 },
            { id: 'welldone', threshold: 18 },
            { id: 'sweet', threshold: 19 },
            { id: 'excellent', threshold: 20 },
            { id: 'brilliant', threshold: 21 },
            { id: 'awesome', threshold: 22 },
            { id: 'fantastic', threshold: 23 },
            { id: 'wonderful', threshold: 24 },
            { id: 'perfect', threshold: 25 },
            { id: 'outstanding', threshold: 26 },
            { id: 'incredible', threshold: 27 },
            { id: 'amazing', threshold: 28 },
            { id: 'unbelievable', threshold: 30 },
            { id: 'legendary', threshold: 32 },
            { id: 'boom', threshold: 34 }
        ];
        let voiceAudioMap = {};
        let voiceInitialized = false;
        let lastVoicePlayTs = 0;
        const VOICE_COOLDOWN_MS = 900;
        
        // =====================
        // æµ‹è¯•èŠ‚ç‚¹ï¼ˆæœ€é«˜ä¼˜å…ˆçº§å¯é€‰ï¼‰
        // - TEST_NODE_PRE_ENABLED: åœ¨åŸé€»è¾‘ä¹‹å‰è°ƒç”¨ testNodePreï¼Œè‹¥è¿”å›å½¢çŠ¶åˆ™ç›´æ¥ä½¿ç”¨å¹¶è·³è¿‡åŸé€»è¾‘
        // - TEST_NODE_POST_ENABLED: åœ¨åŸé€»è¾‘ç”Ÿæˆåè°ƒç”¨ testNodePostï¼Œè‹¥è¿”å›å½¢çŠ¶åˆ™è¦†ç›–åŸé€»è¾‘ç»“æœ
        // - å›è°ƒéœ€è¿”å›å½¢å¦‚ [{pattern:number[][], colors:number[][]}, ...] çš„æ•°ç»„ï¼ˆæœ€å¤š3ä¸ªï¼‰
        // - é»˜è®¤å‡ä¸ºå…³é—­ï¼Œç”±ä½ æŒ‰éœ€åˆ‡æ¢
        // =====================
        const TEST_NODE_PRE_ENABLED = false;
        const TEST_NODE_POST_ENABLED = false;

        function testNodePre(gameInstance) {
            // è¿”å› null è¡¨ç¤ºä¸æ¥ç®¡ï¼ˆèµ°åŸé€»è¾‘ï¼‰
            return null;
        }

        function testNodePost(gameInstance, generatedShapes) {
            // è¿”å› null è¡¨ç¤ºä¸è¦†ç›–ï¼›è¿”å›æ–°æ•°ç»„åˆ™è¦†ç›–åŸé€»è¾‘çš„ currentShapes
            return null;
        }

        // å¯é€‰ï¼šå‰ç½®é’©å­å®ç°ï¼ˆé»˜è®¤ä¸å¯ç”¨ï¼‰ã€‚å½“å‰ç‰ˆæœ¬ä¸åŒ…å«ä»»ä½•ç­–ç•¥ï¼Œå§‹ç»ˆè¿”å› nullï¼ˆä¸æ¥ç®¡ï¼‰ã€‚
        window.CP8_generateShapes = function(game) {
            return null;
        };
        // å•ä¸€çœŸæºï¼šé¢œè‰²æ˜ å°„ï¼ˆç¼–å· -> æ¸å˜ä¸¤ç«¯é¢œè‰²ï¼‰
        const COLOR_STYLES = {
            1: ['#ff6b6b', '#ee5a24'],
            2: ['#4ecdc4', '#44a08d'],
            3: ['#a8e6cf', '#56ab2f'],
            4: ['#ffd93d', '#ff9f40'],
            5: ['#b19cd9', '#8e44ad'],
            6: ['#fd79a8', '#e84393'],
            7: ['#74b9ff', '#0984e3'],
            8: ['#fd79a8', '#fdcb6e']
        };
        // è®¡ç®—æ–‡æœ¬ç”¨çš„ä¸»è‰²ï¼šæŒ‘é€‰æ¸å˜ä¸­æ›´äº®çš„ä¸€ç«¯
        function getLuminance(hex) {
            try {
                const m = /^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i.exec(hex);
                if (!m) return 0;
                const r = parseInt(m[1], 16) / 255;
                const g = parseInt(m[2], 16) / 255;
                const b = parseInt(m[3], 16) / 255;
                const srgb = [r, g, b].map(v => (v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4)));
                return 0.2126 * srgb[0] + 0.7152 * srgb[1] + 0.0722 * srgb[2];
            } catch (_) { return 0; }
        }
        function pickTextPrimaryColor(pair) {
            if (!pair || !pair.length) return '#ffffff';
            if (pair.length === 1) return pair[0];
            const [c1, c2] = pair;
            return getLuminance(c1) >= getLuminance(c2) ? c1 : c2;
        }
        // ç”± JS æ³¨å…¥è¦†ç›–è‰²å—æ ·å¼ï¼Œä¿è¯ CSS ä¸åŠ¨æ•ˆä¸€è‡´
        function initDynamicColorStyles() {
            try {
                const styleElId = 'dynamic-color-styles';
                let styleEl = document.getElementById(styleElId);
                if (!styleEl) {
                    styleEl = document.createElement('style');
                    styleEl.id = styleElId;
                    document.head.appendChild(styleEl);
                }
                let css = '';
                Object.keys(COLOR_STYLES).forEach(k => {
                    const [c1, c2] = COLOR_STYLES[k];
                    const gradient = `linear-gradient(45deg, ${c1}, ${c2})`;
                    css += `.cell.color-${k} { background: ${gradient}; }\n`;
                    css += `.shape-cell.color-${k} { background: ${gradient}; }\n`;
                });
                styleEl.textContent = css;
            } catch (_) {}
        }
        function initVoiceAudios() {
            if (voiceInitialized) return;
            VOICE_CUES.forEach(({ id }) => {
                const elId = `voice-${id}`;
                let el = document.getElementById(elId);
                if (!el) {
                    el = document.createElement('audio');
                    el.id = elId;
                    el.preload = 'auto';
                    el.src = `audio/${id}.mp3`;
                    document.body.appendChild(el);
                }
                voiceAudioMap[id] = el;
            });
            // å·²æœ‰çš„ nice/amazing æ ‡ç­¾ä¹Ÿçº³å…¥æ˜ å°„ï¼ˆè‹¥å­˜åœ¨ï¼‰
            const existingNice = document.getElementById('voice-nice');
            const existingAmazing = document.getElementById('voice-amazing');
            if (existingNice) voiceAudioMap['nice'] = existingNice;
            if (existingAmazing) voiceAudioMap['amazing'] = existingAmazing;
            voiceInitialized = true;
        }
        // æ”¾å—éŸ³æ•ˆç”Ÿæˆå‡½æ•°
        function playPlaceBlockSound() {
            // ç™½å™ªå£°+ä½é€šæ»¤æ³¢+åŒ…ç»œï¼Œæ¨¡æ‹Ÿæœ¨å—è½åœ°å£°
            const duration = 0.07 + Math.random() * 0.02; // 0.07~0.09ç§’
            const volume = 0.6 + (Math.random() - 0.5) * 0.03; // 0.115~0.145
            const bufferSize = audioCtx.sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                // ç™½å™ªå£°ï¼Œå°¾éƒ¨å¿«é€Ÿè¡°å‡
                data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2);
            }
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            // ä½é€šæ»¤æ³¢
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(400 + Math.random() * 80, audioCtx.currentTime); // 400~480Hz
            // åŒ…ç»œ
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(volume, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + duration);
            noise.connect(filter).connect(gain).connect(audioCtx.destination);
            noise.start();
            noise.stop(audioCtx.currentTime + duration);
            noise.onended = () => {
                noise.disconnect();
                filter.disconnect();
                gain.disconnect();
            };
        }
        // æ‹¿èµ·å—æ—¶"å‘¼"çš„é£å£°
        function playPickupWhoosh() {
            if (globalGameInstance && !globalGameInstance.settings.soundEnabled) {
                return;
            }
            const duration = 0.12 + Math.random() * 0.08; // 120~200ms çŸ­ä¿ƒ
            const startTime = audioCtx.currentTime;
            const bufferSize = Math.floor(audioCtx.sampleRate * duration);
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            // ç™½å™ªå£°åŸºç¡€ï¼Œå¾®å¼±å°¾éƒ¨
            for (let i = 0; i < bufferSize; i++) {
                const t = i / audioCtx.sampleRate;
                const env = Math.pow(1 - t / duration, 2); // è‡ªç„¶è¡°å‡
                data[i] = (Math.random() * 2 - 1) * env * 0.6; // åŸå™ªå£°å¹…åº¦ï¼ˆåé¢è¿˜æœ‰å¢ç›ŠåŒ…ç»œï¼‰
            }
            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            // å¸¦é€šæ»¤æ³¢ï¼Œé¢‘ç‡è½»å¾®ä¸Šæ»‘å½¢æˆ"å‘¼"è´¨æ„Ÿ
            const bandpass = audioCtx.createBiquadFilter();
            bandpass.type = 'bandpass';
            bandpass.Q.setValueAtTime(0.9 + Math.random() * 0.6, startTime);
            bandpass.frequency.setValueAtTime(600, startTime);
            bandpass.frequency.linearRampToValueAtTime(1800, startTime + duration);
            // é¢å¤–é«˜é€šï¼Œå‰”é™¤ä½é¢‘è½°é¸£
            const highpass = audioCtx.createBiquadFilter();
            highpass.type = 'highpass';
            highpass.frequency.setValueAtTime(220, startTime);
            // éŸ³é‡åŒ…ç»œ
            const gain = audioCtx.createGain();
            const peak = 0.12 + Math.random() * 0.05; // 0.12~0.17
            gain.gain.setValueAtTime(0, startTime);
            gain.gain.linearRampToValueAtTime(peak, startTime + 0.03); // å¿«é€Ÿèµ·
            gain.gain.linearRampToValueAtTime(0.02, startTime + duration * 0.7); // å¿«é€Ÿæ‰å¤´
            gain.gain.linearRampToValueAtTime(0, startTime + duration);
            source.connect(bandpass).connect(highpass).connect(gain).connect(audioCtx.destination);
            source.start(startTime);
            source.stop(startTime + duration);
            source.onended = () => {
                try {
                    source.disconnect();
                    bandpass.disconnect();
                    highpass.disconnect();
                    gain.disconnect();
                } catch (_) {}
            };
        }
        // å…¨å±€æ¸¸æˆå®ä¾‹å¼•ç”¨ï¼ˆç”¨äºè®¾ç½®æ£€æŸ¥ï¼‰
        let globalGameInstance = null;
        
        // "duangâ€”â€”"éŸ³æ•ˆ
        function playEliminateSound(count, combo) {
            // æ£€æŸ¥éŸ³æ•ˆè®¾ç½®
            if (globalGameInstance && !globalGameInstance.settings.soundEnabled) {
                return;
            }
            // ä½ å¯ä»¥åœ¨è¿™é‡Œç”¨countå’Œcomboè°ƒæ•´éŸ³æ•ˆé¢‘ç‡
            const freq = 600+Math.min(((Math.max(0,((count-8)^0.1)*20))+0*combo),1400); // ä½ å¯ä»¥ç”¨countå’Œcomboè‡ªå®šä¹‰
            // 1. èµ·å§‹å†²å‡»ï¼šé«˜é¢‘triangleæ³¢+ç™½å™ªå£°
            /*const impactOsc = audioCtx.createOscillator();
            const impactGain = audioCtx.createGain();
            impactOsc.type = 'triangle';
            impactOsc.frequency.setValueAtTime(700, audioCtx.currentTime);
            impactGain.gain.setValueAtTime(0.22, audioCtx.currentTime);
            impactGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.05);
            impactOsc.connect(impactGain).connect(audioCtx.destination);
            impactOsc.start(audioCtx.currentTime);
            impactOsc.stop(audioCtx.currentTime + 0.05);
            // ç™½å™ªå£°å†²å‡»
            //const bufferSize = audioCtx.sampleRate * 0.05;
            /*const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2);
            }
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const noiseGain = audioCtx.createGain();
            noiseGain.gain.setValueAtTime(0.18, audioCtx.currentTime);
            noiseGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.05);
            noise.connect(noiseGain).connect(audioCtx.destination);
            noise.start(audioCtx.currentTime);
            noise.stop(audioCtx.currentTime + 0.05);*/
            // 2. æ‹–å°¾ï¼štriangleæ³¢é¢‘ç‡ä¸‹æ»‘
            const tailOsc = audioCtx.createOscillator();
            const tailGain = audioCtx.createGain();
            tailOsc.type = 'triangle';
            tailOsc.frequency.setValueAtTime(freq, audioCtx.currentTime + 0.05);
            tailOsc.frequency.linearRampToValueAtTime(freq, audioCtx.currentTime + 0.30+Math.max(0,((count-8)^0.05)*0.1));
            // æ¸å…¥ + æ¸å‡º
            tailGain.gain.setValueAtTime(0, audioCtx.currentTime + 0.04); // ä»0å¼€å§‹
            tailGain.gain.linearRampToValueAtTime(0.13, audioCtx.currentTime + 0.05); // æ¸å…¥åˆ°0.13
            tailGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.30+Math.max(0,((count-8)^0.05)*0.1));
            tailOsc.connect(tailGain).connect(audioCtx.destination);
            tailOsc.start(audioCtx.currentTime + 0.05);
            tailOsc.stop(audioCtx.currentTime + 0.30+Math.max(0,((count-8)^0.05)*0.1));
            tailOsc.onended = () => {
                tailOsc.disconnect();
                tailGain.disconnect();
            };
        }
        // å­˜æ¡£ç®¡ç†ç±»
        class SaveManager {
            static SAVE_KEY = 'blockBlastSave';
            
            // ä¿å­˜æ¸¸æˆ
            static saveGame(gameInstance) {
                try {
                    const saveData = {
                        grid: gameInstance.grid,
                        score: gameInstance.score,
                        comboMultiplier: gameInstance.comboMultiplier,
                        comboCount: gameInstance.comboCount,
                        lastRoundEliminated: gameInstance.lastRoundEliminated,
                        thisRoundEliminated: gameInstance.thisRoundEliminated,
                        blocksUsedInRound: gameInstance.blocksUsedInRound,
                        shapeId: gameInstance.shapeId,
                        currentShapes: gameInstance.currentShapes,
                        colors: gameInstance.colors,
                        maxShapeColors: gameInstance.maxShapeColors,
                        activeColors: gameInstance.activeColors,
                        dominantColor: gameInstance.dominantColor,
                        shapeColorPools: gameInstance.shapeColorPools,
                        laneNodes: gameInstance.laneNodes,
                        highScore: gameInstance.highScore,
                        timestamp: Date.now(),
                        version: '1.0',
                        __timer: {
                            startMs: gameInstance.timerStartMs,
                            pausedMs: gameInstance.pausedAccumMs,
                            savedAtMs: Date.now()
                        }
                    };
                    localStorage.setItem(this.SAVE_KEY, JSON.stringify(saveData));
                    console.log('æ¸¸æˆå·²è‡ªåŠ¨ä¿å­˜');
                } catch (error) {
                    console.error('ä¿å­˜å¤±è´¥:', error);
                }
            }
            
            // åŠ è½½æ¸¸æˆ
            static loadGame() {
                try {
                    const saveData = localStorage.getItem(this.SAVE_KEY);
                    if (!saveData) {
                        console.log('æ²¡æœ‰æ‰¾åˆ°å­˜æ¡£ï¼Œå¼€å§‹æ–°æ¸¸æˆ');
                        return null;
                    }
                    
                    const parsed = JSON.parse(saveData);
                    
                    // éªŒè¯å­˜æ¡£æ•°æ®å®Œæ•´æ€§
                    if (!this.validateSaveData(parsed)) {
                        console.log('å­˜æ¡£æ•°æ®ä¸å®Œæ•´ï¼Œå¼€å§‹æ–°æ¸¸æˆ');
                        localStorage.removeItem(this.SAVE_KEY);
                        return null;
                    }
                    
                    console.log('æ‰¾åˆ°æœ‰æ•ˆå­˜æ¡£ï¼ŒåŠ è½½æ¸¸æˆ');
                    return parsed;
                } catch (error) {
                    console.error('è¯»å–å­˜æ¡£å¤±è´¥:', error);
                    localStorage.removeItem(this.SAVE_KEY);
                    return null;
                }
            }
            
            // éªŒè¯å­˜æ¡£æ•°æ®
            static validateSaveData(data) {
                const requiredFields = [
                    'grid', 'score', 'comboMultiplier', 'currentShapes', 
                    'colors', 'maxShapeColors', 'activeColors', 'dominantColor', 'shapeColorPools', 'laneNodes', 'highScore', 'version'
                ];
                
                for (const field of requiredFields) {
                    if (!(field in data)) {
                        console.log(`å­˜æ¡£ç¼ºå°‘å­—æ®µ: ${field}`);
                        return false;
                    }
                }
                
                // æ£€æŸ¥gridæ˜¯å¦ä¸º8x8æ•°ç»„
                if (!Array.isArray(data.grid) || data.grid.length !== 8) {
                    console.log('å­˜æ¡£gridæ ¼å¼é”™è¯¯');
                    return false;
                }
                
                // æ£€æŸ¥currentShapesæ˜¯å¦ä¸ºæ•°ç»„
                if (!Array.isArray(data.currentShapes)) {
                    console.log('å­˜æ¡£currentShapesæ ¼å¼é”™è¯¯');
                    return false;
                }
                
                return true;
            }
            
            // æ¸…é™¤å­˜æ¡£
            static clearSave() {
                // ä¿å­˜æœ€é«˜åˆ†ï¼Œé¿å…è¢«æ¸…é™¤
                const independentHigh = this.loadHighScore();
                localStorage.removeItem(this.SAVE_KEY);
                // æ¢å¤æœ€é«˜åˆ†
                if (independentHigh > 0) {
                    this.saveHighScore(independentHigh);
                }
                console.log('å­˜æ¡£å·²æ¸…é™¤ï¼Œæœ€é«˜åˆ†å·²ä¿ç•™');
            }
            
            // è·å–å½“å‰æœ€é«˜åˆ†
            static getCurrentHighScore() {
                try {
                    const saveData = localStorage.getItem(this.SAVE_KEY);
                    if (saveData) {
                        const parsed = JSON.parse(saveData);
                        return parsed.highScore || 0;
                    }
                } catch (error) {
                    console.error('è¯»å–æœ€é«˜åˆ†å¤±è´¥:', error);
                }
                return 0;
            }
            
            // ä¿å­˜æœ€é«˜åˆ†
            static saveHighScore(highScore) {
                try {
                    localStorage.setItem('blockBlastHighScore', JSON.stringify({ highScore }));
                    console.log('æœ€é«˜åˆ†å·²ä¿å­˜:', highScore);
                } catch (error) {
                    console.error('ä¿å­˜æœ€é«˜åˆ†å¤±è´¥:', error);
                }
            }
            
            // åŠ è½½æœ€é«˜åˆ†
            static loadHighScore() {
                try {
                    const highScoreData = localStorage.getItem('blockBlastHighScore');
                    if (highScoreData) {
                        const parsed = JSON.parse(highScoreData);
                        return parsed.highScore || 0;
                    }
                } catch (error) {
                    console.error('åŠ è½½æœ€é«˜åˆ†å¤±è´¥:', error);
                }
                return 0;
            }
        }

        class BlockBlast {
            constructor(colorCount, maxShapeColors) {
                this.gridSize = 8;
                this.grid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(0));
                this.score = 0;
                this.currentShapes = [];
                this.draggedShape = null;
                this.dragOffset = { x: 0, y: 0 };
                this.comboCount = 0; // è¿å‡»è®¡æ•°ï¼ˆåŸºç¡€é€»è¾‘ï¼‰
                this.comboMultiplier = 1; // ç”± comboCount æ¨å¯¼ï¼š1 + 0.5*comboCount
                this.colors = colorCount; // é¢œè‰²ç§ç±»ç”±å‚æ•°å†³å®š
                this.maxShapeColors = maxShapeColors; // æ¯å—æœ€å¤šé¢œè‰²æ•°
                this.shapeId = 1; // å”¯ä¸€idè‡ªå¢
                // æ–°å¢ï¼šå®½æ¾è¿å‡»ç›¸å…³å˜é‡
                this.lastRoundEliminated = false;
                this.thisRoundEliminated = false;
                this.blocksUsedInRound = 0;
                // æ–°å¢ï¼šç®—æ³•æ³³é“ç›¸å…³å˜é‡
                this.dominantColor = 1; // é»˜è®¤é¢œè‰²1
                // æ–°å¢ï¼šæ¯ä¸ªå—çš„é¢œè‰²æ± ç®¡ç†
                this.shapeColorPools = [[], [], []]; // 3ä¸ªå—çš„é¢œè‰²æ± 
                // æ–°å¢ï¼šæ³³é“èŠ‚ç‚¹ç®¡ç†
                this.laneNodes = [0, 0, 0]; // 3ä¸ªæ³³é“èŠ‚ç‚¹åˆ†æ•°
                // æ³³é“å¾ªç¯ï¼ˆæŒ‰å›ºå®šé•¿åº¦å¾ªç¯åˆ†æ®µåˆ¤å®šï¼‰
                this.laneLoopEnabled = true;
                this.laneLoopLength = 8000; // åˆ†æ•°è¾¾åˆ°æ­¤å€¼å³å¾ªç¯å½’é›¶ï¼ˆå‡å»è¯¥å€¼ï¼‰
                // æ–°å¢ï¼šæœ¬å±€è¿è¡Œè®¡æ—¶å™¨ï¼ˆç§’ï¼‰
                this.timerStartMs = Date.now();
                this.pausedAccumMs = 0;
                this.pauseStartedMs = null;
                this.isTimerPaused = false;
                // è¯»æ¡£åæ˜¯å¦æ¢å¤è®¡æ—¶ï¼ˆé»˜è®¤å…³é—­ï¼šè¯»æ¡£åé‡ç½®è®¡æ—¶ï¼‰
                this.timerResumeFromSaveEnabled = false;
                // æ–°å¢ï¼šå®šæ—¶ç­–ç•¥è§¦å‘é…ç½®ï¼ˆä¸å«ç­–ç•¥ï¼Œä»…è§¦å‘æ¡ä»¶ä¸çŠ¶æ€ï¼‰
                this.timeTriggerEnabled = true; // åŸºç¡€å®šæ—¶è§¦å‘é»˜è®¤å¼€å¯
                this.timeEventActive = false; // æ˜¯å¦å¤„äºæ—¶é—´è§¦å‘æœŸ
                // åŸºç¡€é˜ˆå€¼è§¦å‘ï¼šå•ä½ç§’ï¼ˆè¾¾åˆ°åæ¯è½®éƒ½è§¦å‘ï¼‰
                this.timeTriggerThresholdSec = 300 + Math.floor(Math.random() * 60);
                // æ–°å¢ï¼šæœ€é«˜åˆ†è®°å½•
                this.highScore = SaveManager.loadHighScore(); // ä»ç‹¬ç«‹å­˜å‚¨åŠ è½½æœ€é«˜åˆ†
                
                // æ–°å¢ï¼šè®¾ç½®ç›¸å…³å˜é‡
                this.settings = this.loadSettings();
                // æ–°å¢ï¼šè¯­è¨€ï¼ˆzh/enï¼‰
                this.language = this.settings.language || 'zh';
                
                // æ–°å¢ï¼šæ­»äº¡æ£€æµ‹ç›¸å…³å˜é‡
                this.pendingGameOverCheck = false;
                this.gameOverCheckTimeout = null; // æ–°å¢ï¼šå»¶è¿Ÿæ£€æµ‹çš„å®šæ—¶å™¨å¼•ç”¨
                this.isPerformingGameOverCheck = false; // æ–°å¢ï¼šé˜²æ­¢é‡å¤æ£€æµ‹çš„æ ‡å¿—
                
                // æ–°å¢ï¼šæ­»äº¡åŠ¨ç”»ç›¸å…³å˜é‡
                this.isDeathAnimationPlaying = false; // é˜²æ­¢é‡å¤è§¦å‘åŠ¨ç”»
                this.deathAnimationStage = 0; // å½“å‰åŠ¨ç”»é˜¶æ®µ
                this.deathAnimationTimeouts = []; // åŠ¨ç”»å®šæ—¶å™¨æ•°ç»„
                
                // ä¸¤è‰²ä¸€è½®ç­–ç•¥ï¼ˆTCRï¼‰
                this.useTwoColorRoundStrategy = true; // å…¨å±€æœ€é«˜ä¼˜å…ˆçº§æµ‹è¯•å¼€å¯
                this.twoColorRoundState = { active: false, colors: [0, 0], usage: {} };

                // äºŒä¸‰åˆ†ç­–ç•¥ï¼ˆå‡†å¤‡çŠ¶æ€ï¼Œé»˜è®¤ä¸å¯ç”¨ï¼‰
                this.useErSanFenStrategy = false; // å¤–éƒ¨é˜¶æ®µåˆ‡æ¢æ—¶ç½®ä¸ºtrueå¯ç”¨
                this.useErSanFenAsync = false; // å˜ç§ï¼šå¼‚æ­¥äºŒä¸‰åˆ†ï¼Œä¸‰å—å„è‡ªéšæœºå–é¢ç§¯
                this.esfState = { active: false, sizes: [], index: 0, colors: [] };
                this.esfCycleCompleted = false; // å¼€å±€åªæ‰§è¡Œä¸€è½®Næ¬¡ï¼Œå®Œæˆåæ ‡è®°
                // æ–°ï¼šå•è½®ä¸‰åˆ†ç­–ç•¥ï¼ˆSingle Triple Split, STSï¼‰â€”â€”ä»…ä¸€è½®ï¼Œæ‹†æˆa,b,cä¸‰ä»½
                this.useSingleTripleSplitStrategy = false; // é»˜è®¤å…³é—­ï¼ŒæŒ‰éœ€å¼€å¯
                this.stsState = { active: false, sizes: [], color: 0, completed: false };
                 
                this.shapes = [
                    [[1]], // å•ç‚¹
                    [[1, 1]], // ä¸¤æ ¼æ¨ª
                    [[1], [1]], // ä¸¤æ ¼ç«–
                    [[1, 1, 1]], // ä¸‰æ ¼æ¨ª
                    [[1], [1], [1]], // ä¸‰æ ¼ç«–
                    [[1, 1], [1, 1]], // æ–¹å—
                    [[1, 1, 1], [1, 0, 0]], // Lå½¢
                    [[1, 1, 1], [0, 0, 1]], // åLå½¢
                    [[1, 1, 0], [0, 1, 1]], // Zå½¢
                    [[0, 1, 1], [1, 1, 0]], // åZå½¢
                    [[1, 1, 1, 1]], // å››æ ¼æ¨ª
                    [[1], [1], [1], [1]], // å››æ ¼ç«–
                    [[1, 1, 1], [0, 1, 0]], // Tå½¢
                    // æ–°å¢ï¼š
                    [[1,1,1,1,1]], // æ¨ª5æ ¼
                    [[1],[1],[1],[1],[1]], // ç«–5æ ¼
                    // 5æ ¼Lå½¢ï¼ˆ3x3ï¼‰
                    [[1,0,0],[1,0,0],[1,1,1]], // Lå½¢5æ ¼ å·¦ä¸‹
                    [[0,0,1],[0,0,1],[1,1,1]], // Lå½¢5æ ¼ å³ä¸‹
                    [[1,1,1],[1,0,0],[1,0,0]], // Lå½¢5æ ¼ å·¦ä¸Š
                    [[1,1,1],[0,0,1],[0,0,1]], // Lå½¢5æ ¼ å³ä¸Š
                    [[1,1,1],[1,1,1]], // 2x3 æ¨ª
                    [[1,1],[1,1],[1,1]], // 2x3 ç«–
                    [[1,1,1],[1,1,1],[1,1,1]], // 3x3 æ–¹å—
                    // æ–°å¢ï¼šå¯¹è§’çº¿å½¢çŠ¶ï¼ˆæš‚æ—¶æ³¨é‡Šï¼Œéš¾åº¦è¾ƒé«˜ï¼‰
                    // [[1,0],[0,1]], // Zå½¢2æ ¼ï¼ˆå·¦ä¸Šåˆ°å³ä¸‹ï¼‰
                    // [[0,1],[1,0]], // Zå½¢2æ ¼ï¼ˆå³ä¸Šåˆ°å·¦ä¸‹ï¼‰
                    // [[1,0,0],[0,1,0],[0,0,1]], // Zå½¢3æ ¼ï¼ˆå·¦ä¸Šåˆ°å³ä¸‹ï¼‰
                    // [[0,0,1],[0,1,0],[1,0,0]], // Zå½¢3æ ¼ï¼ˆå³ä¸Šåˆ°å·¦ä¸‹ï¼‰
                ];
                // æ–°å¢ï¼šæ¯å±€éšæœºé€‰Nç§é¢œè‰²
                this.activeColors = this.getRandomColors(this.colors);
                // åˆå§‹åŒ–æ¯ä¸ªå—çš„é¢œè‰²æ± 
                this.initializeShapeColorPools();
                // åˆå§‹åŒ–æ³³é“èŠ‚ç‚¹
                this.initializeLaneNodes();
                
                // å°è¯•åŠ è½½å­˜æ¡£
                const savedData = SaveManager.loadGame();
                if (savedData) {
                    this.loadFromSave(savedData);
                } else {
                    this.init(); // æ–°å»ºæ¸¸æˆ
                }
            }

            // é€‰æ‹©ä¸¤ç§æœ¬å±€é¢œè‰²å¹¶åˆå§‹åŒ–æœ¬è½®çŠ¶æ€
            prepareTwoColorRound() {
                try {
                    const pool = (this.activeColors && this.activeColors.length) ? [...this.activeColors] : [1,2,3];
                    while (pool.length < 2) pool.push(pool[0]);
                    // éšæœºä¸¤ç§
                    for (let i = pool.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [pool[i], pool[j]] = [pool[j], pool[i]]; }
                    const cA = pool[0];
                    // æ‰¾åˆ°ä¸ç­‰äº cA çš„è‰²ï¼Œå¦åˆ™å°±ç”¨ cA æœ¬èº«ï¼ˆå®¹é”™ï¼‰
                    const cB = pool.find(c => c !== cA) ?? cA;
                    this.twoColorRoundState = { active: true, colors: [cA, cB], usage: { [cA]: 0, [cB]: 0 } };
                } catch(_) {
                    this.twoColorRoundState = { active: true, colors: [1, 2], usage: { 1:0, 2:0 } };
                }
            }

            // ä¸ºç»™å®š pattern ç”Ÿæˆä¸¤è‰²çŸ©é˜µï¼š1+1 æ’­ç§ï¼Œå…¶ä½™éšæœºå¡«å……ï¼›n<2 æˆ– å•è‰²é™åˆ¶ æ—¶æŒ‰ç”¨é‡å‡è¡¡é€‰æ‹©
            buildTwoColorMatrix(pattern, colorsPair) {
                const fallbackColors = (this.activeColors && this.activeColors.length) ? this.activeColors : [1,2,3];
                const pair = Array.isArray(colorsPair) ? colorsPair.slice(0, 2) : [];
                let cA = Number(pair[0]);
                let cB = Number(pair[1]);
                if (!Number.isFinite(cA) || cA <= 0) cA = fallbackColors[0] || 1;
                if (!Number.isFinite(cB) || cB <= 0 || cB === cA) {
                    const alt = fallbackColors.find(c => c !== cA);
                    cB = (typeof alt === 'number') ? alt : cA;
                }
                const usage = this.twoColorRoundState && this.twoColorRoundState.usage ? this.twoColorRoundState.usage : { [cA]:0, [cB]:0 };
                const rows = pattern.length;
                const cols = pattern[0].length;
                const coords = [];
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        if (pattern[r][c]) coords.push([r, c]);
                    }
                }
                const n = coords.length;
                const out = Array.from({ length: rows }, () => Array(cols).fill(0));
                if (n === 0) return out;
                // å•è‰²é™åˆ¶æˆ–ä»…1æ ¼
                if (n === 1 || this.maxShapeColors <= 1) {
                    const prefer = (usage[cA] <= usage[cB]) ? cA : cB;
                    const [r0, c0] = coords[0];
                    out[r0][c0] = prefer;
                    usage[prefer] = (usage[prefer] || 0) + 1;
                    return out;
                }
                // 1+1 æ’­ç§
                for (let i = coords.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [coords[i], coords[j]] = [coords[j], coords[i]]; }
                const seedA = coords[0];
                const seedB = coords[1];
                out[seedA[0]][seedA[1]] = cA; usage[cA] = (usage[cA] || 0) + 1;
                out[seedB[0]][seedB[1]] = cB; usage[cB] = (usage[cB] || 0) + 1;
                // å…¶ä½™éšæœºå¡«å…… A/B
                for (let i = 2; i < coords.length; i++) {
                    const [r, c] = coords[i];
                    const pick = (Math.random() < 0.5) ? cA : cB;
                    out[r][c] = pick; usage[pick] = (usage[pick] || 0) + 1;
                }
                return out;
            }
            // ä»å­˜æ¡£åŠ è½½
            loadFromSave(savedData) {
                this.grid = savedData.grid;
                this.score = savedData.score;
                // å…¼å®¹æ—§å­˜æ¡£ï¼šä¼˜å…ˆè¯»å– comboCountï¼›å¦åˆ™ç”±å€ç‡åæ¨
                this.comboCount = typeof savedData.comboCount === 'number'
                    ? Math.max(0, Math.floor(savedData.comboCount))
                    : Math.max(0, Math.round(Math.max(1, savedData.comboMultiplier || 1) - 1) / 0.5);
                this.comboMultiplier = 1 + 0.5 * this.comboCount;
                this.lastRoundEliminated = savedData.lastRoundEliminated;
                this.thisRoundEliminated = savedData.thisRoundEliminated;
                this.blocksUsedInRound = savedData.blocksUsedInRound;
                this.shapeId = savedData.shapeId;
                this.currentShapes = savedData.currentShapes;
                this.colors = savedData.colors;
                this.maxShapeColors = savedData.maxShapeColors;
                this.activeColors = savedData.activeColors;
                this.dominantColor = savedData.dominantColor || 1;
                this.shapeColorPools = savedData.shapeColorPools || [[], [], []];
                this.laneNodes = savedData.laneNodes || [0, 0, 0];
                // ä¸ä»å­˜æ¡£è¦†ç›–æœ€é«˜åˆ†ï¼Œå§‹ç»ˆä»¥ç‹¬ç«‹å­˜å‚¨çš„æœ€é«˜åˆ†ä¸ºå‡†
                // è®¡æ—¶å™¨æ¢å¤ç­–ç•¥
                try {
                    if (this.timerResumeFromSaveEnabled && savedData.__timer) {
                        const t = savedData.__timer;
                        this.timerStartMs = typeof t.startMs === 'number' ? t.startMs : Date.now();
                        this.pausedAccumMs = typeof t.pausedMs === 'number' ? t.pausedMs : 0;
                        this.pauseStartedMs = null;
                        this.isTimerPaused = false;
                    } else {
                        // é»˜è®¤è¯»æ¡£åé‡ç½®è®¡æ—¶
                        this.timerStartMs = Date.now();
                        this.pausedAccumMs = 0;
                        this.pauseStartedMs = null;
                        this.isTimerPaused = false;
                    }
                } catch(_) {}
                
                this.createGrid();
                this.updateGrid();
                this.updateScore();
                this.updateCombo();
                // åç½®è¦†ç›–é’©å­ï¼šå…è®¸å¤–éƒ¨è¦†ç›–å·²ç»ç”Ÿæˆå¥½çš„3ä¸ªå—
                try {
                    if (window.CP8_HOOK && window.CP8_HOOK.enabled && window.CP8_HOOK.position === 'after') {
                        const res = (typeof window.CP8_generateShapes === 'function') ? window.CP8_generateShapes(this, this.currentShapes) : null;
                        if (Array.isArray(res) && res.length) {
                            this.currentShapes = res.slice(0, 3).map(s => ({ id: this.shapeId++, pattern: s.pattern, colors: s.colors }));
                        }
                    }
                } catch(_) {}
                this.renderShapes();
                this.setupEventListeners();
                // åº”ç”¨è¯­è¨€åˆ°UI
                this.applyLanguage();
                
                // æ’­æ”¾å¼€å±€æ¿€åŠ±BGMï¼ˆåŠ è½½å­˜æ¡£æ—¶ä¹Ÿæ’­æ”¾ï¼‰
                this.playStartupBGM();
                
                // åŠ è½½å­˜æ¡£åé‡æ–°åšä¸€æ¬¡æ­»äº¡åˆ¤å®š
                if (this.isGameOver()) {
                    console.log('åŠ è½½å­˜æ¡£åæ£€æµ‹åˆ°æ¸¸æˆç»“æŸçŠ¶æ€ï¼Œæ¸…é™¤å­˜æ¡£å¹¶é‡æ–°å¼€å§‹');
                    SaveManager.clearSave();
                    // ä½¿ç”¨å®Œæ•´çš„é‡æ–°å¼€å§‹æµç¨‹
                    this.init(); // é‡æ–°å¼€å§‹æ¸¸æˆ
                    return;
                }
            }

            // è‡ªåŠ¨ä¿å­˜
            autoSave() {
                SaveManager.saveGame(this);
            }

            // æ–°å¢ï¼šä»1~8ä¸­éšæœºé€‰nç§é¢œè‰²
            getRandomColors(n) {
                const arr = [1,2,3,4,5,6,7,8];
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                return arr.slice(0, n);
            }

            // æ–°å¢ï¼šåˆå§‹åŒ–æ¯ä¸ªå—çš„é¢œè‰²æ± 
            initializeShapeColorPools() {
                const baseColors = (this.activeColors && this.activeColors.length) ? this.activeColors : [1,2,3];
                for (let i = 0; i < 3; i++) {
                    // å¤åˆ¶æœ¬å±€æ´»è·ƒé¢œè‰²æ± ä½œä¸ºåˆå§‹å€¼ï¼ˆå…œåº•éç©ºï¼‰
                    this.shapeColorPools[i] = [...baseColors];
                }
                console.log('åˆå§‹åŒ–å—é¢œè‰²æ± :', this.shapeColorPools);
            }

            // åˆå§‹åŒ–æ³³é“èŠ‚ç‚¹ï¼ˆå½“å‰é˜ˆå€¼ï¼šçº¦2000/4000/6000 èµ·æ­¥ï¼Œå¸¦å°‘é‡æ³¢åŠ¨ï¼‰
            initializeLaneNodes() {
                this.laneNodes[0] = 2000 + Math.floor(Math.random() * 200);
                this.laneNodes[1] = 4000 + Math.floor(Math.random() * 400);
                this.laneNodes[2] = 6000 + Math.floor(Math.random() * 600);
                console.log('åˆå§‹åŒ–æ³³é“èŠ‚ç‚¹:', this.laneNodes);
            }

            // æ–°å¢ï¼šé¢œè‰²åˆ†é…ç­–ç•¥0 - å®Œæ•´é¢œè‰²æ± 
            updateColorPoolsStrategy0() {
                // åˆ·æ–°3ä¸ªå—çš„é¢œè‰²æ± ä¸ºæœ¬å±€çš„é¢œè‰²ï¼ˆå…œåº•éç©ºï¼‰
                const baseColors = (this.activeColors && this.activeColors.length) ? this.activeColors : [1,2,3];
                for (let i = 0; i < 3; i++) {
                    this.shapeColorPools[i] = [...baseColors];
                }
                
                console.log('é¢œè‰²åˆ†é…ç­–ç•¥0 - å®Œæ•´é¢œè‰²æ± :', {
                    activeColors: baseColors,
                    shapeColorPools: this.shapeColorPools
                });
            }

            // æ–°å¢ï¼šé¢œè‰²åˆ†é…ç­–ç•¥1 - å…±åŒé¢œè‰²+å‰©ä½™éšæœº1ç§
            updateColorPoolsStrategy1() {
                // ä»é¢œè‰²æ± ä¸­å–éšæœº1ç§é¢œè‰²ä½œä¸ºå…±åŒé¢œè‰²ï¼ˆå…œåº•éç©ºï¼‰
                const baseColors = (this.activeColors && this.activeColors.length) ? this.activeColors : [1,2,3];
                const commonColor = baseColors[Math.floor(Math.random() * baseColors.length)];
                
                // é¢œè‰²æ± ä¸­å‰©ä½™çš„é¢œè‰²
                const remainingColors = baseColors.filter(color => color !== commonColor);
                
                // ä¸ºæ¯ä¸ªå—åˆ†é…é¢œè‰²æ± ï¼šå…±åŒé¢œè‰² + å„è‡ªéšæœºçš„å¦ä¸€ç§é¢œè‰²ï¼ˆè‹¥æ— åˆ™é€€åŒ–ä¸ºå…±åŒè‰²ï¼‰
                for (let i = 0; i < 3; i++) {
                    const randomColor = remainingColors.length ? remainingColors[Math.floor(Math.random() * remainingColors.length)] : commonColor;
                    this.shapeColorPools[i] = [commonColor, randomColor];
                }
                
                console.log('é¢œè‰²åˆ†é…ç­–ç•¥1 - å…±åŒé¢œè‰²+å‰©ä½™éšæœº1ç§:', {
                    commonColor: commonColor,
                    remainingColors: remainingColors,
                    shapeColorPools: this.shapeColorPools
                });
            }

            // æ–°å¢ï¼šé¢œè‰²åˆ†é…ç­–ç•¥2 - å…±åŒé¢œè‰²+æœ¬å±€éšæœº1ç§
            updateColorPoolsStrategy2() {
                // ä»é¢œè‰²æ± ä¸­å–éšæœº1ç§é¢œè‰²ä½œä¸ºå…±åŒé¢œè‰²ï¼ˆå…œåº•éç©ºï¼‰
                const baseColors = (this.activeColors && this.activeColors.length) ? this.activeColors : [1,2,3];
                const commonColor = baseColors[Math.floor(Math.random() * baseColors.length)];
                
                // ä¸ºæ¯ä¸ªå—åˆ†é…é¢œè‰²æ± ï¼šå…±åŒé¢œè‰² + æœ¬å±€é¢œè‰²æ± ä¸­çš„éšæœº1ç§
                for (let i = 0; i < 3; i++) {
                    const randomColor = baseColors[Math.floor(Math.random() * baseColors.length)];
                    this.shapeColorPools[i] = [commonColor, randomColor];
                }
                
                console.log('é¢œè‰²åˆ†é…ç­–ç•¥2 - å…±åŒé¢œè‰²+æœ¬å±€éšæœº1ç§:', {
                    commonColor: commonColor,
                    activeColors: baseColors,
                    shapeColorPools: this.shapeColorPools
                });
            }

            // æ–°å¢ï¼šé¢œè‰²åˆ†é…ç­–ç•¥X - æ¯ä¸ªå—ç‹¬ç«‹ä»æœ¬å±€é¢œè‰²ä¸­éšæœºæŠ½ä¸¤è‰²ï¼ˆâ‰¤2è‰²ï¼‰
            // ä½ç½®ï¼šä»‹äº TCR ä¸ æœ€ç»ˆç­–ç•¥0 ä¹‹é—´ï¼›ä¸æœ€ç»ˆç­–ç•¥ä¸€è‡´åœ°ä¸å›ºå®š"å…±åŒè‰²"ï¼Œä½†é™åˆ¶æ¯å—ä¸¤è‰²
            updateColorPoolsStrategyPreferredPair() {
                try {
                    const pool = (this.activeColors && this.activeColors.length) ? [...this.activeColors] : [1,2,3];
                    for (let i = 0; i < 3; i++) {
                        // éšæœºæŠ½å–ä¸¤è‰²ï¼Œä¿è¯å°½é‡ä¸åŒï¼›ä¸è¶³åˆ™é€€åŒ–
                        const shuffled = [...pool];
                        for (let k = shuffled.length - 1; k > 0; k--) { const j = Math.floor(Math.random() * (k + 1)); [shuffled[k], shuffled[j]] = [shuffled[j], shuffled[k]]; }
                        const cA = shuffled[0];
                        const cB = shuffled.find(c => c !== cA) ?? cA;
                        this.shapeColorPools[i] = [cA, cB];
                    }
                    console.log('é¢œè‰²åˆ†é…ç­–ç•¥X - æ¯å—ç‹¬ç«‹ä¸¤è‰²:', { activeColors: this.activeColors, shapeColorPools: this.shapeColorPools });
                } catch (e) {
                    this.updateColorPoolsStrategy2();
                }
            }

            // æ–°å¢ï¼šTCR ä½œä¸ºå›ºå®šç­–ç•¥å‡½æ•°ï¼ˆä¾›æ³³é“æ®µ1è°ƒç”¨ï¼‰
            updateColorPoolsStrategyTCR() {
                try {
                    if (!this.twoColorRoundState || !this.twoColorRoundState.active) this.prepareTwoColorRound();
                    const [cA, cB] = this.twoColorRoundState.colors || [1, 2];
                    this.shapeColorPools[0] = [cA, cB];
                    this.shapeColorPools[1] = [cA, cB];
                    this.shapeColorPools[2] = [cA, cB];
                    this.twoColorRoundState.active = false;
                } catch (_) {
                    // å…œåº•ï¼šé€€å›ç­–ç•¥2
                    this.updateColorPoolsStrategy2();
                }
            }

            init() {
                // é‡ç½®æ¸¸æˆçŠ¶æ€
                this.grid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(0));
                this.score = 0;
                this.comboMultiplier = 1;
                this.currentShapes = [];
                this.draggedShape = null;
                this.lastRoundEliminated = false;
                this.thisRoundEliminated = false;
                this.blocksUsedInRound = 0;
                this.shapeId = 1;
                // é‡ç½®è®¡æ—¶å™¨
                this.timerStartMs = Date.now();
                this.pausedAccumMs = 0;
                this.pauseStartedMs = null;
                this.isTimerPaused = false;
                // é‡ç½®å®šæ—¶è§¦å‘ç›¸å…³çŠ¶æ€
                this.timeEventActive = false;
                // æ¸…ç©ºä¸Šä¸€æ¬¡æ”¾å—åˆ†å¾…åˆå¹¶ä¿¡æ¯
                this.pendingPlacementScore = 0;
                this.pendingPlacementAnchor = null;
                
                // é‡ç½®æ­»äº¡æ£€æµ‹çŠ¶æ€
                this.clearGameOverCheck();
                
                this.createGrid();
                // æ¯å±€é‡æ–°éšæœºé¢œè‰²
                this.activeColors = this.getRandomColors(this.colors);
                // åˆå§‹åŒ–æ¯ä¸ªå—çš„é¢œè‰²æ± 
                this.initializeShapeColorPools();
                // åˆå§‹åŒ–æ³³é“èŠ‚ç‚¹
                this.initializeLaneNodes();
                // å¼€å±€ç­–ç•¥ï¼šåŒæ­¥äºŒä¸‰åˆ† / å¼‚æ­¥äºŒä¸‰åˆ† / å•è½®ä¸‰åˆ†(STS) ç­‰æ¦‚ç‡é€‰æ‹©ä¸€ç§
                this.esfCycleCompleted = false;
                // æ¸…ç©ºæ‰€æœ‰å¼€åœºç­–ç•¥å¼€å…³
                this.useErSanFenStrategy = false;
                this.useErSanFenAsync = false;
                this.useSingleTripleSplitStrategy = false;
                // éšæœºé€‰æ‹©
                (function pickAndEnable(self){
                    const roll = Math.floor(Math.random() * 3); // 0 åŒæ­¥, 1 å¼‚æ­¥, 2 STS
                    if (roll === 0) {
                        self.useErSanFenStrategy = true;
                        self.useErSanFenAsync = false;
                        self.esfState.active = false; // é¦–æ¬¡ generate æ—¶åˆå§‹åŒ–ESF
                    } else if (roll === 1) {
                        self.useErSanFenStrategy = true;
                        self.useErSanFenAsync = true;
                        self.esfState.active = false;
                    } else {
                        self.useSingleTripleSplitStrategy = true;
                        self.stsState.active = false; // é¦–æ¬¡ generate æ—¶åˆå§‹åŒ–STS
                        self.stsState.completed = false;
                    }
                })(this);
                this.generateShapes();
                this.updateGrid();
                this.updateScore();
                this.updateCombo();
                this.setupEventListeners();
                
                // åº”ç”¨è¯­è¨€åˆ°UIï¼ˆé¦–æ¬¡å¯åŠ¨æ—¶ç¡®ä¿ä½¿ç”¨é»˜è®¤è¯­è¨€ï¼‰
                this.applyLanguage();
                
                // æ’­æ”¾å¼€å±€æ¿€åŠ±BGM
                this.playStartupBGM();
            }

            // æœ¬å±€å·²ç”¨æ—¶ï¼ˆç§’ï¼‰ï¼Œè‡ªåŠ¨å‰”é™¤æš‚åœæ—¶é•¿
            getElapsedSeconds() {
                const now = Date.now();
                const pausedNow = this.isTimerPaused && this.pauseStartedMs ? (now - this.pauseStartedMs) : 0;
                const effectivePaused = this.pausedAccumMs + (this.isTimerPaused ? pausedNow : 0);
                const elapsedMs = Math.max(0, now - this.timerStartMs - effectivePaused);
                return Math.floor(elapsedMs / 1000);
            }

            // æš‚åœ/æ¢å¤è®¡æ—¶å™¨ï¼ˆä¾›å¤–éƒ¨è°ƒç”¨ï¼Œå¦‚æ‰“å¼€è®¾ç½®é¢æ¿/å¤±ç„¦ç­‰ï¼‰
            pauseTimer() {
                if (this.isTimerPaused) return;
                this.isTimerPaused = true;
                this.pauseStartedMs = Date.now();
            }

            resumeTimer() {
                if (!this.isTimerPaused) return;
                const now = Date.now();
                if (this.pauseStartedMs) this.pausedAccumMs += Math.max(0, now - this.pauseStartedMs);
                this.isTimerPaused = false;
                this.pauseStartedMs = null;
            }

            createGrid() {
                const gridElement = document.getElementById('grid');
                gridElement.innerHTML = '';
                
                for (let i = 0; i < this.gridSize * this.gridSize; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.index = i;
                    gridElement.appendChild(cell);
                }
			}

            // è¾…åŠ©å‡½æ•°ï¼šæŸ¥æ‰¾æ‰€æœ‰å¯æ”¾å…¥ä½ç½®
            findAllValidPositions(grid, pattern) {
                const positions = [];
                for (let row = 0; row <= this.gridSize - pattern.length; row++) {
                    for (let col = 0; col <= this.gridSize - pattern[0].length; col++) {
                        let canPlace = true;
                        for (let r = 0; r < pattern.length; r++) {
                            for (let c = 0; c < pattern[r].length; c++) {
                                if (pattern[r][c] && grid[row + r][col + c]) {
                                    canPlace = false;
                                    break;
                                }
                            }
                            if (!canPlace) break;
                        }
                        if (canPlace) positions.push({row, col});
                    }
                }
                return positions;
            }

            // è¾…åŠ©å‡½æ•°ï¼šè¿”å›æ”¾ç½®åçš„æ–°grid
            placeShapeOnGrid(grid, pattern, colors, startRow, startCol) {
                const newGrid = grid.map(row => row.slice());
                for (let r = 0; r < pattern.length; r++) {
                    for (let c = 0; c < pattern[r].length; c++) {
                        if (pattern[r][c]) {
                            newGrid[startRow + r][startCol + c] = colors[r][c];
                        }
                    }
                }
                return newGrid;
            }

            // Fisher-Yates æ´—ç‰Œç®—æ³•
            shuffleArray(arr) {
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
            }

            // è·å–æ‰€æœ‰å¯èƒ½çš„èµ·ç‚¹å¹¶æ‰“ä¹±
            getShuffledPositions(maxRow, maxCol) {
                const positions = [];
                for (let row = 0; row <= maxRow; row++) {
                    for (let col = 0; col <= maxCol; col++) {
                        positions.push({row, col});
                    }
                }
                this.shuffleArray(positions);
                return positions;
            }

            // ç»Ÿè®¡ç›˜é¢å„é¢œè‰²æ•°é‡ï¼Œè¿”å›æœ€å¤šçš„é¢œè‰²
            getMostFrequentColor() {
                const colorCounts = {};
                
                // ç»Ÿè®¡æ¯ç§é¢œè‰²çš„æ•°é‡
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const color = this.grid[row][col];
                        if (color > 0) {
                            colorCounts[color] = (colorCounts[color] || 0) + 1;
                        }
                    }
                }
                
                // æ‰¾åˆ°æ•°é‡æœ€å¤šçš„é¢œè‰²
                let maxCount = 0;
                let mostFrequentColors = [];
                
                for (const color in colorCounts) {
                    const count = colorCounts[color];
                    if (count > maxCount) {
                        maxCount = count;
                        mostFrequentColors = [parseInt(color)];
                    } else if (count === maxCount) {
                        mostFrequentColors.push(parseInt(color));
                    }
                }
                
                // å¦‚æœæœ‰æœ€å¤šæ•°é‡çš„é¢œè‰²ï¼Œéšæœºé€‰æ‹©ä¸€ä¸ª
                if (mostFrequentColors.length > 0) {
                    return mostFrequentColors[Math.floor(Math.random() * mostFrequentColors.length)];
                }
                
                // å¦‚æœæ‰€æœ‰é¢œè‰²éƒ½ä¸º0ï¼Œä»æœ¬å±€é¢œè‰²ä¸­éšæœºé€‰æ‹©
                return this.activeColors[Math.floor(Math.random() * this.activeColors.length)];
            }

            generateShapes() {
                // è¦†ç›–é’©å­ï¼šå‰ç½®ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰
                try {
                    if (window.CP8_HOOK && window.CP8_HOOK.enabled && window.CP8_HOOK.position === 'before') {
                        const res = (typeof window.CP8_generateShapes === 'function') ? window.CP8_generateShapes(this) : null;
                        if (Array.isArray(res) && res.length) {
                            this.currentShapes = res.slice(0, 3).map(s => ({ id: this.shapeId++, pattern: s.pattern, colors: s.colors }));
                            this.renderShapes();
                            return;
                        }
                    }
                } catch(_) {}
                // ä¼˜å…ˆï¼šå•è½®ä¸‰åˆ†ç­–ç•¥ï¼ˆSTSï¼‰â€”â€”å•ç‹¬æµ‹è¯•æˆ–å¼€å±€å•è½®æ—¶ä½¿ç”¨
                if (this.useSingleTripleSplitStrategy) {
                    if (!this.stsState || !this.stsState.active) {
                        if (!this.stsState || !this.stsState.completed) this.initSingleTripleSplitStrategy();
                    }
                    if (this.stsState && this.stsState.active) {
                        const sizes = [...this.stsState.sizes];
                        for (let i = sizes.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [sizes[i], sizes[j]] = [sizes[j], sizes[i]];
                        }
                        const color = this.stsState.color;
                        // console è°ƒè¯•
                        try { console.log('STS å¼€å±€ï¼šsizes=', sizes, ' color=', color); } catch(_) {}
                        this.currentShapes = [];
                        for (let i = 0; i < 3; i++) {
                            const area = sizes[i % sizes.length];
                            const pattern = this.getRandomShapeByArea(area);
                            const colorMatrix = this.buildPureColorMatrix(pattern, color);
                            this.currentShapes.push({ id: this.shapeId++, pattern, colors: colorMatrix });
                        }
                        this.renderShapes();
                        this.completeSingleTripleSplit();
                        return;
                    }
                }
                 // è‹¥å¼€å¯äºŒä¸‰åˆ†ç­–ç•¥å¹¶å¤„äºæ´»åŠ¨é˜¶æ®µï¼Œåˆ™æŒ‰ESFè§„æ ¼ç”Ÿæˆä¸€æ‰¹3ä¸ªå—
                 if (this.useErSanFenStrategy) {
                     if (!this.esfState || !this.esfState.active) {
                         if (this.esfCycleCompleted) {
                             // å·²å®Œæˆä¸€è½®ï¼Œç›´æ¥å›é€€è‡³åŸé€»è¾‘
                         } else {
                             this.initErSanFenStrategy();
                         }
                     }
                     const spec = this.esfCycleCompleted ? null : this.getCurrentEsfSpec();
                     if (spec) {
                         const { area, colors } = spec;
                         // æ¯è½®éšæœºæ‰“ä¹±ä¸‰è‰²å¯¹åº”çš„å·¦å³ä¸­é¡ºåº
                         const shuffled = [...colors];
                         for (let i = shuffled.length - 1; i > 0; i--) {
                             const j = Math.floor(Math.random() * (i + 1));
                             [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                         }
                         // è‹¥å¯ç”¨å¼‚æ­¥äºŒä¸‰åˆ†ï¼šä»æ¯ä¸ªé¢œè‰²å¯¹åº”çš„bagä¸­"ä¸æ”¾å›"å–ä¸€ä¸ªé¢ç§¯ï¼Œç¡®ä¿Nè½®å†…å¯¹è¯¥é¢œè‰²çš„é¢ç§¯ä¸é‡å¤
                         const areasForRound = [];
                         if (this.useErSanFenAsync && this.esfAsync && this.esfAsync.bagsByColor) {
                             for (let k = 0; k < 3; k++) {
                                 const col = shuffled[k % shuffled.length];
                                 const bag = this.esfAsync.bagsByColor[col] || [];
                                 let pick = bag.length ? bag.pop() : this.esfState.sizes[Math.floor(Math.random()*this.esfState.sizes.length)];
                                 areasForRound.push(pick);
                             }
                         }
                         this.currentShapes = [];
                         for (let i = 0; i < 3; i++) {
                             // å˜ç§ï¼šæ¯ä¸ªå—ç‹¬ç«‹éšæœºé€‰å–é¢ç§¯ï¼ˆæ¥è‡ªæœ¬è½®sizesé›†åˆï¼‰
                             const pickArea = this.useErSanFenAsync ? areasForRound[i] : area;
                             const pattern = this.getRandomShapeByArea(pickArea);
                             const colorNum = shuffled[i % shuffled.length];
                             const colorMatrix = this.buildPureColorMatrix(pattern, colorNum);
                             this.currentShapes.push({ id: this.shapeId++, pattern, colors: colorMatrix });
                         }
                         this.renderShapes();
                         this.advanceEsfRound();
                         if (!this.esfState.active) {
                             // Nè½®å®Œæˆï¼šæ ‡è®°å¹¶å…³é—­ESFï¼Œåç»­å›è½æ³³é“
                             this.esfCycleCompleted = true;
                             this.useErSanFenStrategy = false;
                         }
                         return;
                     }
                     // è‹¥ESFå·²ç»“æŸï¼Œåˆ™ç»§ç»­èµ°åŸæœ‰é€»è¾‘
                 }
                 
                 // ç®—æ³•æ³³é“é€»è¾‘ï¼šæ›´æ–°æŒ‡å®šå˜é‡ä¸ºå½“å‰ç›˜é¢å—æ•°æœ€å¤šçš„é¢œè‰²ç§ç±»
                 this.dominantColor = this.getMostFrequentColor();
                 console.log('å½“å‰ç›˜é¢æœ€å¤šé¢œè‰²:', this.dominantColor);
                 
                 // å®šæ—¶ç­–ç•¥è§¦å‘æ£€æµ‹ï¼ˆä»…æ›´æ–°çŠ¶æ€ï¼Œä¸æ‰§è¡Œç­–ç•¥ï¼‰
                 try {
                     if (this.timeTriggerEnabled) {
                         const elapsed = this.getElapsedSeconds();
                         const prev = this._lastTimeProgressSec || 0;
                         const windowSec = 0; // ç®€åŒ–ï¼šä¸å†ä½¿ç”¨å®¹å·®çª—å£
                         // ç®€åŒ–ï¼šè¾¾åˆ°é˜ˆå€¼åæ¯è½®éƒ½è§¦å‘
                         if (elapsed >= (this.timeTriggerThresholdSec || 0)) {
                             this.timeEventActive = true;
                         } else {
                             this.timeEventActive = false;
                         }
                         // ç»“æŸç®€åŒ–
                         const nodes = Array.isArray(this.timeTriggerNodesSec) ? this.timeTriggerNodesSec : [];
                         let crossed = false;
                         for (const t of nodes) {
                             if (t >= prev && t <= elapsed + windowSec) { crossed = true; break; }
                         }
                         this._lastTimeProgressSec = elapsed;
                         if (crossed) {
                             this.timeEventRoundsLeft = Math.max(this.timeTriggerRounds || 1, 1);
                             this.timeEventActive = true;
                         }
                         if (this.timeEventRoundsLeft <= 0) this.timeEventActive = false;
                     }
                 } catch(_) {}

                 // å®šæ—¶ç­–ç•¥ï¼šä¼˜å…ˆäºæ³³é“
                 if (this.timeEventActive) {
                     this.updateColorPoolsStrategy0();
                        } else {
                    // æ³³é“é€»è¾‘ï¼šæ ¹æ®åˆ†æ•°é˜¶æ®µè°ƒç”¨ä¸åŒç­–ç•¥ï¼ˆæ”¯æŒå¾ªç¯ï¼‰
                    let laneProgress = this.score;
                    
                    // å¦‚æœå¯ç”¨å¾ªç¯ä¸”åˆ†æ•°è¶…è¿‡å¾ªç¯é•¿åº¦ï¼Œåˆ™è¿›è¡Œå¾ªç¯å¤„ç†
                    if (this.laneLoopEnabled && laneProgress >= this.laneLoopLength) {
                        const loopCount = Math.floor(laneProgress / this.laneLoopLength);
                        laneProgress = laneProgress % this.laneLoopLength;
                        console.log(`æ³³é“å¾ªç¯: åˆ†æ•° ${this.score} -> å¾ªç¯${loopCount}æ¬¡, å½“å‰è¿›åº¦ ${laneProgress}`);
                    }
                    
                    if (laneProgress < this.laneNodes[0]) {
                       // ç¬¬1æ®µï¼šTCR ä½œä¸ºå›ºå®šæ³³é“ç­–ç•¥
                       this.updateColorPoolsStrategyTCR();
                   } else if (laneProgress >= this.laneNodes[0] && laneProgress < this.laneNodes[1]) {
                    // ç¬¬2æ®µï¼šç­–ç•¥2
                    this.updateColorPoolsStrategy2();
                    } else if (laneProgress >= this.laneNodes[1] && laneProgress < this.laneNodes[2]) {
                    // ç¬¬3æ®µï¼šç­–ç•¥1
                    this.updateColorPoolsStrategy1();
                    } else if (laneProgress >= this.laneNodes[2]) {
                        // ç¬¬4æ®µï¼šå•å—åŒè‰²ç­–ç•¥ï¼ˆæ›¿æ¢åŸç­–ç•¥0ï¼‰
                        this.updateColorPoolsStrategyPreferredPair();
                    }
                }
                 
                 // æ–°å‡ºå—é€»è¾‘ï¼šå—æ± æ‰“ä¹±ï¼Œä¾æ¬¡å–å—ï¼Œä¾æ¬¡æ”¾ä¸‹3ä¸ªå—
                 try { console.log('å‡ºå—å‰è®¡æ—¶(ç§’):', this.getElapsedSeconds()); } catch(_) {}
                 let found = false;
                 let tryCount = 0;
                 const maxTries = 100;
                 let lastRandomShapes = [];
                 let selectedShapes = [];
                 let patterns = [];
                 let colorsArr = [];
                 while (!found && tryCount < maxTries) {
                     tryCount++;
                     let tempGrid = this.grid.map(row => row.slice());
                     // 1. å—æ± æ‰“ä¹±
                     const shapePool = this.shapes.slice();
                     this.shuffleArray(shapePool);
                     selectedShapes = [];
                     patterns = [];
                     colorsArr = [];
                     lastRandomShapes = [];
                     for (let i = 0; i < shapePool.length && selectedShapes.length < 3; i++) {
                         const pattern = shapePool[i];
                         // ä½¿ç”¨å¯¹åº”å—çš„é¢œè‰²æ± 
                         const blockIndex = selectedShapes.length; // å½“å‰æ˜¯ç¬¬å‡ ä¸ªå—
                         const rawPool = this.shapeColorPools[blockIndex];
                         const baseColors = (this.activeColors && this.activeColors.length) ? this.activeColors : [1,2,3];
                         const colorPool = (Array.isArray(rawPool) && rawPool.length) ? rawPool : baseColors;
                         // è‹¥ä¸ºå•å—åŒè‰²ç­–ç•¥ï¼ˆä¸¤è‰²æ± ï¼‰ä¸”å…è®¸å¤šè‰²ï¼Œä¼˜å…ˆä¿è¯ä¸¤è‰²éƒ½å‡ºç°ï¼ˆ1+1æ’­ç§ï¼‰ï¼Œå¦åˆ™ç›´æ¥éšæœº
                         let cellCount = 0; for (let rr = 0; rr < pattern.length; rr++) { for (let cc = 0; cc < pattern[rr].length; cc++) { if (pattern[rr][cc]) cellCount++; } }
                         const colors = (Array.isArray(colorPool) && colorPool.length === 2 && this.maxShapeColors > 1 && cellCount >= 2)
                             ? this.buildTwoColorMatrix(pattern, colorPool)
                             : pattern.map(row => row.map(cell => cell ? colorPool[Math.floor(Math.random() * colorPool.length)] : 0));
                         // 2. è·å–æ‰€æœ‰å¯èƒ½èµ·ç‚¹å¹¶æ‰“ä¹±
                         const maxRow = this.gridSize - pattern.length;
                         const maxCol = this.gridSize - pattern[0].length;
                         const positions = this.getShuffledPositions(maxRow, maxCol);
                         let placed = false;
                         for (const pos of positions) {
                             // æ£€æŸ¥èƒ½å¦æ”¾ä¸‹
                             let canPlace = true;
                             for (let r = 0; r < pattern.length; r++) {
                                 for (let c = 0; c < pattern[r].length; c++) {
                                     if (pattern[r][c] && tempGrid[pos.row + r][pos.col + c]) {
                                         canPlace = false;
                                         break;
                                     }
                                 }
                                 if (!canPlace) break;
                             }
                             if (canPlace) {
                                 // æ”¾ä¸‹
                                 tempGrid = this.placeShapeOnGrid(tempGrid, pattern, colors, pos.row, pos.col);
                                 selectedShapes.push({pattern, colors});
                                 patterns.push(pattern);
                                 colorsArr.push(colors);
                                 placed = true;
                                 break;
                             }
                         }
                         // è®°å½•æ‰€æœ‰å°è¯•è¿‡çš„shapeå’Œé…è‰²
                         lastRandomShapes.push({ pattern, colors });
                     }
                     if (selectedShapes.length === 3) {
                         found = true;
                     }
                 }
                 // æ„é€ æœ€ç»ˆçš„3ä¸ªå—
                 this.currentShapes = [];
                 let idx = 0;
                 for (; idx < selectedShapes.length && idx < 3; idx++) {
                     this.currentShapes.push({
                         id: this.shapeId++,
                         pattern: selectedShapes[idx].pattern,
                         colors: selectedShapes[idx].colors
                     });
                 }
                 // è¡¥è¶³åˆ°3ä¸ª
                 while (this.currentShapes.length < 3) {
                     // éšæœºé€‰ä¸€ä¸ªshapeå’Œé…è‰²
                     let randomShape;
                     if (lastRandomShapes.length > 0) {
                         randomShape = lastRandomShapes[Math.floor(Math.random() * lastRandomShapes.length)];
                     } else {
                         // å…œåº•
                         const pattern = this.shapes[0];
                         const blockIndex = this.currentShapes.length; // å½“å‰æ˜¯ç¬¬å‡ ä¸ªå—
                         const rawPool = this.shapeColorPools[blockIndex];
                         const baseColors = (this.activeColors && this.activeColors.length) ? this.activeColors : [1,2,3];
                         const colorPool = (Array.isArray(rawPool) && rawPool.length) ? rawPool : baseColors;
                         // ä¸ä¸Šæ–¹ä¸€è‡´çš„è§„åˆ™ï¼šåŒè‰²æ± æ—¶ä¼˜å…ˆåŒ…å«ä¸¤è‰²
                         let __cells = 0; for (let r2 = 0; r2 < pattern.length; r2++) { for (let c2 = 0; c2 < pattern[r2].length; c2++) { if (pattern[r2][c2]) __cells++; } }
                         const colors = (Array.isArray(colorPool) && colorPool.length === 2 && this.maxShapeColors > 1 && __cells >= 2)
                             ? this.buildTwoColorMatrix(pattern, colorPool)
                             : pattern.map(row => row.map(cell => cell ? colorPool[Math.floor(Math.random() * colorPool.length)] : 0));
                         randomShape = { pattern, colors };
                     }
                     this.currentShapes.push({
                         id: this.shapeId++,
                         pattern: randomShape.pattern,
                         colors: randomShape.colors
                     });
                 }
                 this.renderShapes();
                 // é‡ç½®è¿å‡»å€ç‡
                 /*this.comboMultiplier = 1;
                 this.updateCombo();*/
             }

            renderShapes() {
                for (let i = 0; i < 3; i++) {
                    const slot = document.getElementById(`shape-slot-${i}`);
                    slot.innerHTML = '';
                    const shape = this.currentShapes[i];
                    if (shape && shape.pattern) this.createShapeElement(shape, i);
                }
            }

            createShapeElement(shapeWithColors, slotIndex) {
                const slot = document.getElementById(`shape-slot-${slotIndex}`);
                const shapeDiv = document.createElement('div');
                shapeDiv.className = 'shape';
                shapeDiv.dataset.shapeId = shapeWithColors.id;
                shapeDiv.dataset.slotIndex = slotIndex;

                const grid = document.createElement('div');
                grid.className = 'shape-grid';
                grid.style.gridTemplateColumns = `repeat(${shapeWithColors.pattern[0].length}, 1fr)`;

                // åªå¯¹æœ€å¤§è¾¹å¤§äº4çš„shapeç¼©æ”¾ï¼Œå¦åˆ™ä¿æŒåŸå§‹æ¯”ä¾‹
                const maxCell = Math.max(shapeWithColors.pattern.length, shapeWithColors.pattern[0].length);
                const slotSize = 80; // px
                const cellGap = 2; // gap px
                let cellSize;
                if (maxCell > 4) {
                    // ç¼©æ”¾
                    cellSize = (slotSize - cellGap * (maxCell - 1)) / maxCell;
                    grid.style.width = (cellSize * shapeWithColors.pattern[0].length + cellGap * (shapeWithColors.pattern[0].length - 1)) + 'px';
                    grid.style.height = (cellSize * shapeWithColors.pattern.length + cellGap * (shapeWithColors.pattern.length - 1)) + 'px';
                } else {
                    // ä¿æŒåŸå§‹æ¯”ä¾‹ï¼Œå•å…ƒæ ¼æœ€å¤§20px
                    cellSize = 20;
                    grid.style.width = (cellSize * shapeWithColors.pattern[0].length + cellGap * (shapeWithColors.pattern[0].length - 1)) + 'px';
                    grid.style.height = (cellSize * shapeWithColors.pattern.length + cellGap * (shapeWithColors.pattern.length - 1)) + 'px';
                }
                grid.style.justifySelf = 'center';
                grid.style.alignSelf = 'center';

                for (let r = 0; r < shapeWithColors.pattern.length; r++) {
                    for (let c = 0; c < shapeWithColors.pattern[r].length; c++) {
                        const cell = shapeWithColors.pattern[r][c];
                        const color = shapeWithColors.colors[r][c];
                        const cellDiv = document.createElement('div');
                        if (cell) {
                            cellDiv.className = `shape-cell filled color-${color}`;
                        } else {
                            cellDiv.className = 'shape-cell empty';
                        }
                        cellDiv.style.width = cellSize + 'px';
                        cellDiv.style.height = cellSize + 'px';
                        grid.appendChild(cellDiv);
                    }
                }

                shapeDiv.appendChild(grid);
                slot.appendChild(shapeDiv);
            }

            setupEventListeners() {
                // é¼ æ ‡äº‹ä»¶
                document.addEventListener('mousedown', this.handleMouseDown.bind(this));
                document.addEventListener('mousemove', this.handleMouseMove.bind(this));
                document.addEventListener('mouseup', this.handleMouseUp.bind(this));

                // è§¦æ‘¸äº‹ä»¶ - æ·»åŠ  passive: false ä»¥ç¡®ä¿å¯ä»¥preventDefault
                document.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                document.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                document.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });
                
                // é˜²æ­¢é¡µé¢æ»šåŠ¨å¹²æ‰°æ‹–æ‹½
                document.addEventListener('touchmove', (e) => {
                    if (this.draggedShape) {
                        e.preventDefault();
                    }
                }, { passive: false });

                // æ‹–æ‹½ç»“æŸæ—¶å…¨å±€æ¸…ç†æŠ•å½±ï¼ˆå…œåº•ï¼‰
                document.addEventListener('mouseup', () => {
                    const cells = document.getElementById('grid').children;
                    Array.from(cells).forEach(cell => {
                        cell.classList.remove('projection');
                        cell.style.opacity = '';
                    });
                });
                document.addEventListener('touchend', () => {
                    const cells = document.getElementById('grid').children;
                    Array.from(cells).forEach(cell => {
                        cell.classList.remove('projection');
                        cell.style.opacity = '';
                    });
                });
                // æ‰©å¤§å¯æ‹¾å–åŒºåŸŸï¼šå·¦å³å¯¹é½æ£‹ç›˜ï¼ˆæˆ–å±å¹•è¾¹ç•Œï¼‰ï¼Œä»æ£‹ç›˜ä¸‹æ²¿å»¶ç”³è‡³å±å¹•åº•éƒ¨
                const shapesContainer = document.getElementById('shapes-container');
                if (shapesContainer) {
                    shapesContainer.addEventListener('mousedown', (ev) => {
                        if (ev.target.closest('.shape')) return;
                        if (this.isInExpandedPickRegion(ev.clientX, ev.clientY)) this.pickShapeByZone(ev.clientX, ev.clientY);
                    });
                    shapesContainer.addEventListener('touchstart', (ev) => {
                        if (ev.target.closest('.shape')) return;
                        ev.preventDefault();
                        const t = ev.touches[0];
                        if (this.isInExpandedPickRegion(t.clientX, t.clientY)) this.pickShapeByZone(t.clientX, t.clientY);
                    }, { passive: false });
                    document.addEventListener('mousedown', (ev) => {
                        if (ev.target.closest('.shape') || ev.target.closest('#grid')) return;
                        if (this.isInExpandedPickRegion(ev.clientX, ev.clientY)) this.pickShapeByZone(ev.clientX, ev.clientY);
                    });
                    document.addEventListener('touchstart', (ev) => {
                        if (ev.target.closest('.shape') || ev.target.closest('#grid')) return;
                        const t = ev.touches[0];
                        if (this.isInExpandedPickRegion(t.clientX, t.clientY)) { ev.preventDefault(); this.pickShapeByZone(t.clientX, t.clientY); }
                    }, { passive: false });
                }
            }

            handleMouseDown(e) {
                const shape = e.target.closest('.shape');
                if (shape) {
                    const shapeId = parseInt(shape.dataset.shapeId);
                    const slotIndex = parseInt(shape.dataset.slotIndex);
                    const shapeObj = this.currentShapes.find(s => s && s.id === shapeId);
                    if (!shapeObj) return;
                    this.startDrag(shape, e.clientX, e.clientY);
                } else if (e.target.closest('#shapes-container')) {
                    this.pickShapeByZone(e.clientX, e.clientY);
                }
            }

            handleTouchStart(e) {
                const shape = e.target.closest('.shape');
                if (shape) {
                    const shapeId = parseInt(shape.dataset.shapeId);
                    const slotIndex = parseInt(shape.dataset.slotIndex);
                    const shapeObj = this.currentShapes.find(s => s && s.id === shapeId);
                    if (!shapeObj) return;
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.startDrag(shape, touch.clientX, touch.clientY);
                } else if (e.target.closest('#shapes-container')) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.pickShapeByZone(touch.clientX, touch.clientY);
                }
            }

            // æ‰©å±•æ‹¾å–å‘½ä¸­ï¼šå·¦å³ä»¥æ£‹ç›˜ä¸ºåŸºå‡†ï¼ˆè´´ä¸¤ä¾§ï¼‰ï¼Œä¸Šè¾¹è´´è¿‘æ£‹ç›˜ä¸‹æ²¿ï¼Œä¸‹è‡³å±å¹•åº•
            isInExpandedPickRegion(clientX, clientY) {
                const grid = document.getElementById('grid');
                if (!grid) return false;
                const g = grid.getBoundingClientRect();
                const left = g.left;   // ä¸¥æ ¼ä½¿ç”¨æ£‹ç›˜å·¦å³ä½œä¸ºè¾¹ç•Œ
                const right = g.right;
                const top = g.bottom + 8;
                const bottom = window.innerHeight;
                return clientX >= left && clientX <= right && clientY >= top && clientY <= bottom;
            }

            // å°†æ‰©å±•åŒºåŸŸæŒ‰å®½åº¦ä¸‰ç­‰åˆ†ï¼Œç‚¹å‡»ä»»ä¸€åŒºåŸŸæ‹¿èµ·å¯¹åº”æ§½ä½çš„å—ï¼ˆä¸¥æ ¼æŒ‰æ£‹ç›˜å®½åº¦ç­‰åˆ†ï¼‰
            pickShapeByZone(clientX, clientY) {
                try {
                    const grid = document.getElementById('grid');
                    if (!grid) return;
                    const g = grid.getBoundingClientRect();
                    const left = g.left;   // ä¸¥æ ¼ä½¿ç”¨æ£‹ç›˜å·¦å³ä½œä¸ºè¾¹ç•Œ
                    const right = g.right;
                    const clampedX = Math.min(right, Math.max(left, clientX));
                    const relX = clampedX - left;
                    const zone = Math.min(2, Math.max(0, Math.floor(relX / ((right - left) / 3)))); // 0/1/2
                    const slot = document.getElementById(`shape-slot-${zone}`);
                    if (!slot) return;
                    const shapeEl = slot.querySelector('.shape');
                    if (!shapeEl) return;
                    const startX = clientX;
                    const startY = Math.max(clientY, g.bottom + 8);
                    this.startDrag(shapeEl, startX, startY);
                } catch(_){ }
            }

            startDrag(shapeElement, x, y, anchorAtPointer = false) {
                const shapeId = parseInt(shapeElement.dataset.shapeId);
                const slotIndex = parseInt(shapeElement.dataset.slotIndex);
                const shapeObj = this.currentShapes.find(s => s && s.id === shapeId);
                if (!shapeObj) return;
                if (this.draggedShape) return;
                // æ’­æ”¾æ‹¿èµ·å—çš„é£å£°
                playPickupWhoosh();
                const slot = document.getElementById(`shape-slot-${slotIndex}`);
                const slotRect = slot.getBoundingClientRect();
                // æ‹–æ‹½æ—¶åˆ‡æ¢ä¸ºå›ºå®šcellå¤§å°
                const grid = shapeElement.querySelector('.shape-grid');
                const gridElement = document.getElementById('grid');
                const firstCell = gridElement.children[0];
                const cellSize = firstCell.offsetWidth;
                const cellGap = 2;
                grid.style.width = (cellSize * shapeObj.pattern[0].length + cellGap * (shapeObj.pattern[0].length - 1)) + 'px';
                grid.style.height = (cellSize * shapeObj.pattern.length + cellGap * (shapeObj.pattern.length - 1)) + 'px';
                grid.style.justifySelf = 'center';
                grid.style.alignSelf = 'center';
                const cells = grid.querySelectorAll('.shape-cell');
                cells.forEach(cell => {
                    cell.style.width = cellSize + 'px';
                    cell.style.height = cellSize + 'px';
                });

                // è®¾ç½®æ‹–æ‹½å¤–è§‚ä¸å±‚çº§
                shapeElement.classList.add('dragging');
                shapeElement.style.position = 'fixed';
                shapeElement.style.zIndex = 1000;
                shapeElement.style.pointerEvents = 'none';
                document.body.appendChild(shapeElement);

                // è®¡ç®—åˆå§‹é”šç‚¹
                const halfW = shapeElement.offsetWidth / 2;
                const halfH = shapeElement.offsetHeight / 2;
                const defaultCenterX = slotRect.left + slotRect.width / 2;
                const defaultTopY = slotRect.top - 20;
                const slotStartX = anchorAtPointer ? x : defaultCenterX;
                const slotStartY = anchorAtPointer ? (y - halfH) : defaultTopY;
                const dragYOffset = anchorAtPointer ? 0 : -60;

                this.draggedShape = {
                    element: shapeElement,
                    shapeWithColors: shapeObj,
                    id: shapeId,
                    slotIndex: slotIndex,
                    slotStartX: slotStartX,
                    slotStartY: slotStartY,
                    dragStartX: x,
                    dragStartY: y,
                    dragYOffset: dragYOffset
                };

                // è®¾ç½®åˆå§‹ä½ç½®
                shapeElement.style.left = (slotStartX - halfW) + 'px';
                shapeElement.style.top = (slotStartY + dragYOffset) + 'px';
            }

            handleMouseMove(e) {
                if (this.draggedShape) {
                    this.updateDragPosition(e.clientX, e.clientY);
                }
            }

            handleTouchMove(e) {
                if (this.draggedShape) {
                    e.preventDefault();
                    e.stopPropagation();  // é˜²æ­¢äº‹ä»¶å†’æ³¡
                    const touch = e.touches[0];
                    this.updateDragPosition(touch.clientX, touch.clientY);
                }
            }

            updateDragPosition(x, y) {
                const element = this.draggedShape.element;
                // é¼ æ ‡ç§»åŠ¨é‡
                const dx = (x - this.draggedShape.dragStartX) * 1.5;
                const dy = (y - this.draggedShape.dragStartY) * 1.5;
                // ä»¥ slot ä¸Šæ–¹ä¸ºé”šç‚¹
                const left = this.draggedShape.slotStartX - element.offsetWidth / 2 + dx;
                const top = this.draggedShape.slotStartY + dy + this.draggedShape.dragYOffset;
                requestAnimationFrame(() => {
                    element.style.left = left + 'px';
                    element.style.top = top + 'px';
                });
                this.highlightValidPositions(x, y);
            }

            highlightValidPositions(x, y) {
                const gridElement = document.getElementById('grid');
                const gridRect = gridElement.getBoundingClientRect();
                const cells = gridElement.children;
                // åªæ¸…ç† projectionã€highlightã€invalid å’Œ projection cell çš„ color-xï¼Œä¸å½±å“å·²æ”¾ç½®å—
                Array.from(cells).forEach(cell => {
                    if (cell.classList.contains('projection')) {
                        for (let i = 1; i <= 8; i++) cell.classList.remove('color-' + i);
                        cell.classList.remove('projection');
                        cell.style.opacity = '';
                    }
                    cell.classList.remove('highlight', 'invalid', 'pre-clear');
                    for (let i = 1; i <= 8; i++) cell.classList.remove('pre-clear-color-' + i);
                });

                let judgeX = x, judgeY = y;
                if (this.draggedShape && this.draggedShape.shapeWithColors) {
                    const el = this.draggedShape.element;
                    const left = parseFloat(el.style.left);
                    const top = parseFloat(el.style.top);
                    judgeX = left + el.offsetWidth / 2;
                    judgeY = top + el.offsetHeight / 2;
                }
                // shape pattern anchorï¼ˆä¸­å¿ƒï¼‰
                if (!this.draggedShape || !this.draggedShape.shapeWithColors || !this.draggedShape.shapeWithColors.pattern) return;
                const pattern = this.draggedShape.shapeWithColors.pattern;
                const anchorOffsetX = pattern[0].length / 2;
                const anchorOffsetY = pattern.length / 2;
                const cellSize = gridRect.width / this.gridSize;
                // è®©shapeä¸­å¿ƒå¯¹å‡†é¼ æ ‡/è§†è§‰ä¸­å¿ƒï¼Œæ”¯æŒåŠæ ¼
                const anchorGridX = Math.round((judgeX - gridRect.left) / cellSize - anchorOffsetX + 0.5);
                const anchorGridY = Math.round((judgeY - gridRect.top) / cellSize - anchorOffsetY + 0.5);

                // æœç´¢1æ ¼èŒƒå›´å†…æ‰€æœ‰å¯æ”¾ç½®ç‚¹ï¼Œé€‰æœ€è¿‘çš„
                let minDist = Infinity;
                let bestPos = null;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const gx = anchorGridX + dx;
                        const gy = anchorGridY + dy;
                        if (gx >= 0 && gx < this.gridSize && gy >= 0 && gy < this.gridSize) {
                            if (this.canPlaceShape(pattern, gy, gx)) {
                                // è®¡ç®—shapeä¸­å¿ƒç‚¹è½åœ¨ç›˜é¢ä¸Šçš„å®é™…åƒç´ åæ ‡
                                const gridCenterX = gridRect.left + (gx + anchorOffsetX) * cellSize;
                                const gridCenterY = gridRect.top + (gy + anchorOffsetY) * cellSize;
                                const dist = Math.hypot(judgeX - gridCenterX, judgeY - gridCenterY);
                                if (dist < minDist) {
                                    minDist = dist;
                                    bestPos = {gx, gy};
                                }
                            }
                        }
                    }
                }
                this._currentProjection = null;
                if (bestPos) {
                    this.highlightShape(pattern, bestPos.gy, bestPos.gx, true);
                    this._currentProjection = {gx: bestPos.gx, gy: bestPos.gy};

                    // é¢„æ¶ˆé™¤é«˜äº®ï¼šæ¨¡æ‹Ÿè½å—ï¼ŒæŸ¥æ‰¾æ¶ˆé™¤åŒºåŸŸ
                    const tempGrid = this.grid.map(row => row.slice());
                    // æ¨¡æ‹Ÿæ”¾ç½® shape
                    for (let r = 0; r < pattern.length; r++) {
                        for (let c = 0; c < pattern[r].length; c++) {
                            if (pattern[r][c]) {
                                const gridRow = bestPos.gy + r;
                                const gridCol = bestPos.gx + c;
                                if (gridRow >= 0 && gridRow < this.gridSize && gridCol >= 0 && gridCol < this.gridSize) {
                                    tempGrid[gridRow][gridCol] = this.draggedShape.shapeWithColors.colors[r][c];
                                }
                            }
                        }
                    }
                    // ç”¨ findConnectedGroupsOnGrid æŸ¥æ‰¾æ¶ˆé™¤åŒºåŸŸ
                    const cellsToRemove = this.findConnectedGroupsOnGrid(tempGrid);
                    if (cellsToRemove.length > 0) {
                        // é«˜äº®è¿™äº› cell
                        cellsToRemove.forEach(({row, col}) => {
                            const cellIndex = row * this.gridSize + col;
                            const cell = cells[cellIndex];
                            cell.classList.add('pre-clear');
                            // å…ˆç§»é™¤æ‰€æœ‰é¢œè‰²é«˜äº®
                            for (let i = 1; i <= 8; i++) cell.classList.remove('pre-clear-color-' + i);
                            // å–è¯¥cellé¢œè‰²
                            const color = tempGrid[row][col];
                            if (color) cell.classList.add('pre-clear-color-' + color);
                        });
                    }
                }
            }

            highlightShape(shape, startRow, startCol, valid) {
                // åªè´Ÿè´£æ¸²æŸ“æŠ•å½±ï¼Œä¸å†æ¸…ç†
                const cells = document.getElementById('grid').children;
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[r].length; c++) {
                        if (shape[r][c]) {
                            const gridRow = startRow + r;
                            const gridCol = startCol + c;
                            if (gridRow >= 0 && gridRow < this.gridSize && gridCol >= 0 && gridCol < this.gridSize) {
                                const cellIndex = gridRow * this.gridSize + gridCol;
                                const cell = cells[cellIndex];
                                if (valid) {
                                    // åªåŠ  projection å’Œ color-xï¼Œä¸åŠ  filled
                                    cell.classList.remove('highlight', 'invalid', 'projection');
                                    for (let i = 1; i <= 8; i++) cell.classList.remove('color-' + i);
                                    cell.classList.add('projection');
                                    const color = this.draggedShape.shapeWithColors.colors[r][c];
                                    if (color) cell.classList.add('color-' + color);
                                    cell.style.opacity = '0.5';
                                } else {
                                    cell.classList.add('invalid');
                                }
                            }
                        }
                    }
                }
            }

            handleMouseUp(e) {
                if (this.draggedShape) {
                    this.handleDrop(e.clientX, e.clientY);
                }
                
                // æ£€æŸ¥æ˜¯å¦æœ‰å¾…å¤„ç†çš„æ­»äº¡æ£€æµ‹
                if (this.pendingGameOverCheck) {
                    this.pendingGameOverCheck = false;
                    // å»¶è¿Ÿä¸€å¸§æ‰§è¡Œï¼Œç¡®ä¿æ‹–æ‹½çŠ¶æ€å·²å®Œå…¨æ¸…ç†
                    requestAnimationFrame(() => {
                        this.performGameOverCheck();
                    });
                }
            }

            handleTouchEnd(e) {
                if (this.draggedShape) {
                    const touch = e.changedTouches[0];
                    this.handleDrop(touch.clientX, touch.clientY);
                }
                
                // æ£€æŸ¥æ˜¯å¦æœ‰å¾…å¤„ç†çš„æ­»äº¡æ£€æµ‹
                if (this.pendingGameOverCheck) {
                    this.pendingGameOverCheck = false;
                    // å»¶è¿Ÿä¸€å¸§æ‰§è¡Œï¼Œç¡®ä¿æ‹–æ‹½çŠ¶æ€å·²å®Œå…¨æ¸…ç†
                    requestAnimationFrame(() => {
                        this.performGameOverCheck();
                    });
                }
            }

            handleDrop(x, y) {
                const gridElement = document.getElementById('grid');
                const gridRect = gridElement.getBoundingClientRect();
                const cellSize = gridRect.width / this.gridSize;
                let judgeX = x, judgeY = y;
                if (this.draggedShape) {
                    // ä½¿ç”¨ shape-grid çš„ç²¾ç¡®å‡ ä½•ï¼Œé¿å…å®¹å™¨ padding/transform å½±å“
                    const el = this.draggedShape.element;
                    const grid = el.querySelector('.shape-grid');
                    const gridRect = grid ? grid.getBoundingClientRect() : el.getBoundingClientRect();
                    judgeX = gridRect.left + gridRect.width / 2;
                    judgeY = gridRect.top + gridRect.height / 2;
                }
                if (this.draggedShape) {
                    // ä½¿ç”¨ shape-grid çš„ç²¾ç¡®å‡ ä½•ï¼Œé¿å…å®¹å™¨ padding/transform å½±å“
                    const el = this.draggedShape.element;
                    const grid = el.querySelector('.shape-grid');
                    const gridRect = grid ? grid.getBoundingClientRect() : el.getBoundingClientRect();
                    judgeX = gridRect.left + gridRect.width / 2;
                    judgeY = gridRect.top + gridRect.height / 2;
                }
                // ä¼˜å…ˆç”¨æŠ•å½±ç‚¹
                let placed = false;
                if (this._currentProjection) {
                    const {gx, gy} = this._currentProjection;
                    if (this.canPlaceShape(this.draggedShape.shapeWithColors.pattern, gy, gx)) {
                        this.placeShape(this.draggedShape.shapeWithColors.pattern, this.draggedShape.shapeWithColors.colors, gy, gx);
                        this.removeShapeById(this.draggedShape.id);
                        placed = true;
                    }
                }
                this._currentProjection = null;
                this.cleanupDrag(placed);
                if (placed) {
                    this.clearLines();
                    this.updateGrid();
                    this.updateScore();
                    const remainingShapes = this.currentShapes.filter(s => s !== null);
                    if (remainingShapes.length === 0) {
                        // å…ˆåˆ‡æ¢è½®æ¬¡
                        this.lastRoundEliminated = this.thisRoundEliminated;
                        this.thisRoundEliminated = false;
                        this.blocksUsedInRound = 0;
                        // å†åˆ¤æ–­æ˜¯å¦éœ€è¦å½’é›¶combo
                        console.log('åˆ¤å®šå½’é›¶', this.thisRoundEliminated, this.lastRoundEliminated);
                        if (!this.thisRoundEliminated && !this.lastRoundEliminated) {
                            this.comboCount = 0;
                            this.comboMultiplier = 1 + 0.5 * this.comboCount;
                            this.updateCombo();
                        }
                        this.generateShapes();
                    }
                    // å»¶è¿Ÿæ­»äº¡æ£€æµ‹ï¼Œç»™ç©å®¶æ“ä½œæ—¶é—´
                    this.checkGameOverWithDelay();
                    // è‡ªåŠ¨ä¿å­˜æ¸¸æˆ
                    this.autoSave();
                } /*else {
                    this.comboMultiplier = Math.max(1, this.comboMultiplier - 0.2);
                    this.updateCombo();
                }*/
            }

            cleanupDrag(placed) {
                const element = this.draggedShape.element;
                if (placed) {
                    if (element.parentNode) {
                        element.parentNode.removeChild(element);
                    }
                } else {
                    element.classList.remove('dragging');
                    element.style.position = '';
                    element.style.left = '';
                    element.style.top = '';
                    element.style.zIndex = '';
                    element.style.pointerEvents = '';
                    // æ¢å¤åˆ°åŸæ¥çš„ slot
                    const slot = document.getElementById(`shape-slot-${this.draggedShape.slotIndex}`);
                    slot.appendChild(element);
                    // æ¢å¤ä¸ºslotç¼©æ”¾
                    const grid = element.querySelector('.shape-grid');
                    const shapeWithColors = this.draggedShape.shapeWithColors;
                    // åªå¯¹æœ€å¤§è¾¹å¤§äº4çš„shapeç¼©æ”¾ï¼Œå¦åˆ™ä¿æŒåŸå§‹æ¯”ä¾‹
                    const maxCell = Math.max(shapeWithColors.pattern.length, shapeWithColors.pattern[0].length);
                    const slotSize = 80; // px
                    const cellGap = 2; // gap px
                    let cellSize;
                    if (maxCell > 4) {
                        cellSize = (slotSize - cellGap * (maxCell - 1)) / maxCell;
                        grid.style.width = (cellSize * shapeWithColors.pattern[0].length + cellGap * (shapeWithColors.pattern[0].length - 1)) + 'px';
                        grid.style.height = (cellSize * shapeWithColors.pattern.length + cellGap * (shapeWithColors.pattern.length - 1)) + 'px';
                    } else {
                        cellSize = 20;
                        grid.style.width = (cellSize * shapeWithColors.pattern[0].length + cellGap * (shapeWithColors.pattern[0].length - 1)) + 'px';
                        grid.style.height = (cellSize * shapeWithColors.pattern.length + cellGap * (shapeWithColors.pattern.length - 1)) + 'px';
                    }
                    grid.style.justifySelf = 'center';
                    grid.style.alignSelf = 'center';
                    const cells = grid.querySelectorAll('.shape-cell');
                    cells.forEach(cell => {
                        cell.style.width = cellSize + 'px';
                        cell.style.height = cellSize + 'px';
                    });
                }
                // æ¸…é™¤é«˜äº®å’Œ projection
                const cells = document.getElementById('grid').children;
                Array.from(cells).forEach(cell => {
                    cell.classList.remove('highlight', 'invalid', 'projection', 'pre-clear');
                    cell.style.opacity = '';
                    for (let i = 1; i <= 8; i++) cell.classList.remove('pre-clear-color-' + i);
                });
                this.draggedShape = null;
            }

            canPlaceShape(shape, startRow, startCol) {
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[r].length; c++) {
                        if (shape[r][c]) {
                            const gridRow = startRow + r;
                            const gridCol = startCol + c;
                            if (gridRow >= this.gridSize || gridCol >= this.gridSize || 
                                gridRow < 0 || gridCol < 0 || this.grid[gridRow][gridCol]) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            placeShape(pattern, colors, startRow, startCol) {
                playPlaceBlockSound();
                
                // è®¡ç®—æ”¾ç½®çš„æ ¼æ•°
                let placedCells = 0;
                for (let r = 0; r < pattern.length; r++) {
                    for (let c = 0; c < pattern[r].length; c++) {
                        if (pattern[r][c]) {
                            this.grid[startRow + r][startCol + c] = colors[r][c];
                            placedCells++;
                        }
                    }
                }
                
                // æ·»åŠ æ”¾ç½®åˆ†ï¼šæ”¾ç½®å—æ ¼æ•° Ã— 1
                const placementScore = placedCells * 1;
                this.score += placementScore;
                
                // æ”¾å—ä½ç½®åæ ‡ï¼ˆç”¨äºåŠ¨æ•ˆé”šç‚¹ï¼‰
                const gridElement = document.getElementById('grid');
                const gridRect = gridElement.getBoundingClientRect();
                const cellSize = gridRect.width / this.gridSize;
                const x = gridRect.left + startCol * cellSize + (pattern[0].length * cellSize) / 2;
                const y = gridRect.top + startRow * cellSize + (pattern.length * cellSize) / 2;
                const placeAnchor = { x, y };
                
                // æš‚åœæ”¾å—åˆ†çš„è§†è§‰æ•ˆæœä¸åˆå¹¶é€»è¾‘
                this.pendingPlacementScore = 0;
                this.pendingPlacementAnchor = null;
                
                // æ–°å¢ï¼šç»Ÿè®¡æœ¬è½®å·²ç”¨å—æ•°
                this.blocksUsedInRound++;
            }

            removeShapeById(id) {
                const idx = this.currentShapes.findIndex(s => s && s.id === id);
                if (idx !== -1) this.currentShapes[idx] = null;
                // è¦†ç›–é’©å­ï¼šåç½®ï¼ˆå¯æ›¿æ¢é€šç”¨ç»“æœï¼‰
                try {
                    if (window.CP8_HOOK && window.CP8_HOOK.enabled && window.CP8_HOOK.position === 'after') {
                        const res = (typeof window.CP8_generateShapes === 'function') ? window.CP8_generateShapes(this) : null;
                        if (Array.isArray(res) && res.length) {
                            this.currentShapes = res.slice(0, 3).map(s => ({ id: this.shapeId++, pattern: s.pattern, colors: s.colors }));
                        }
                    }
                } catch(_) {}
                this.renderShapes();
            }

            clearLines() {
                const cellsToRemove = this.findConnectedGroups();
                
                if (cellsToRemove.length > 0) {
                    this.thisRoundEliminated = true;
                    console.log('æœ¬è½®æœ‰æ¶ˆé™¤ï¼Œè®¾ç½®thisRoundEliminatedä¸ºtrue');
                    // å…ˆè·å–æ¶ˆé™¤å—æ•°å’Œè¿å‡»æ¬¡æ•°
                    const eliminatedCount = cellsToRemove.length;
                    const comboCount = this.comboCount || 0; // ä½¿ç”¨å¢é‡å‰çš„è¿å‡»è®¡æ•°
                    const compositeCue = eliminatedCount + comboCount; // ç»Ÿä¸€ç”¨äºé…éŸ³ä¸æ¿€åŠ±è¯
                    playEliminateSound(eliminatedCount, comboCount);
                    this.animateClearance(cellsToRemove);
                    // è¯­éŸ³æ’­æŠ¥ï¼ˆæœ¬åœ°éŸ³é¢‘ï¼‰â€” ä½¿ç”¨ç»Ÿä¸€çš„ compositeCue
                    this.playVoiceForElimination(compositeCue);
                    // åœ¨æ¸…é™¤å‰ç»Ÿè®¡æœ¬æ¬¡æ¶ˆé™¤é¢œè‰²é›†åˆï¼ˆç”¨äºæŒ‰å­—ç¬¦å¾ªç¯ä¸Šè‰²ï¼‰
                    const colorNumbers = this.collectColorsFromCells(cellsToRemove);
                    
                    // æ¸…é™¤æ–¹å—
                    cellsToRemove.forEach(({row, col}) => {
                        this.grid[row][col] = 0;
                    });
                    
                    // è®¡ç®—åˆ†æ•°
                    const baseScore = cellsToRemove.length * 10;
                    // æš‚åœæ”¾å—åˆ†å¹¶å…¥æ¶ˆé™¤åˆ†
                    const mergedPlacement = 0;
                    
                    // å…ˆæŒ‰ comboCount æ¨å¯¼å€ç‡ï¼Œå†è®¡ç®—å¥–åŠ±
                    this.comboMultiplier = 1 + 0.5 * this.comboCount;
                    let bonusScore = 0;
                    if (this.comboMultiplier > 1) {
                        bonusScore = Math.floor(baseScore * (this.comboMultiplier - 1));
                    }
                    
                    this.score += baseScore + bonusScore + mergedPlacement;
                    
                    // æœ¬è½®æ”¾å—åˆ†å·²è®¡å…¥æ€»åˆ†ï¼›æ¶ˆé™¤æ—¶ä¸å•ç‹¬æ’­æ”¾æ”¾å—åˆ†åŠ¨æ•ˆ
                    // æ˜¾ç¤ºåˆå¹¶çš„æ¶ˆé™¤åˆ†ï¼ˆåŸºç¡€åˆ†+è¿å‡»å¥–åŠ±ï¼‰
                    const totalScore = baseScore + bonusScore + mergedPlacement;
                    // ç»Ÿä¸€é”šç‚¹
                    const gridElement = document.getElementById('grid');
                    const gridRect = gridElement.getBoundingClientRect();
                    const cellSize = gridRect.width / this.gridSize;
                    let totalRow = 0, totalCol = 0;
                    cellsToRemove.forEach(({row, col}) => { totalRow += row; totalCol += col; });
                    const centerRow = totalRow / cellsToRemove.length;
                    const centerCol = totalCol / cellsToRemove.length;
                    const anchor = {
                        x: gridRect.left + centerCol * cellSize + cellSize / 2,
                        y: gridRect.top + centerRow * cellSize + cellSize / 2
                    };
                    this.showEliminationScoreWithColor(totalScore, cellsToRemove, anchor, colorNumbers.length ? colorNumbers : (this.dominantColor || 1));
                    // ä¿æŒå…³é—­åˆå¹¶é€»è¾‘
                    
                    // æ˜¾ç¤ºè¿å‡»ç‰¹æ•ˆï¼ˆæš‚æ—¶å…³é—­ï¼‰
                    // if (this.comboMultiplier > 1) {
                    //     const comboCount = Math.round((this.comboMultiplier - 1) / 0.5) + 1;
                    //     this.showComboEffect(comboCount);
                    // }
                    
                    // æ¶ˆé™¤éœ‡åŠ¨
                    this.vibrateOnElimination(cellsToRemove.length);
                    
                    // è¯­éŸ³æ’­æŠ¥ï¼šæ¶ˆé™¤9æ ¼åŠä»¥ä¸Šæ—¶æ’­æŠ¥"good"ï¼ˆæš‚æ—¶å…³é—­ï¼‰
                    // if (cellsToRemove.length >= 9) {
                    //     this.speakGood();
                    // }
                    
                    // å¢åŠ  combo è®¡æ•°ï¼ˆä¸ºä¸‹æ¬¡æ¶ˆé™¤åšå‡†å¤‡ï¼‰
                    this.comboCount = Math.min(this.comboCount + 1, 8);
                    this.comboMultiplier = 1 + 0.5 * this.comboCount;
                    this.updateCombo();
                    // æ˜¾ç¤º"Combo N"åŠ¨æ•ˆï¼Œä¾¿äºæ ¡éªŒ
                    const dict = this.getI18n()[this.language] || this.getI18n().zh;
                    const label = (this.language === 'zh' ? 'è¿å‡»' : 'Combo');
                    const text = `${label} ${this.comboCount}`;
                    // ä½¿ç”¨æœ¬æ¬¡æ¶ˆé™¤çš„é¢œè‰²é›†åˆï¼ˆä¸åŠ åˆ†ä¸€è‡´ï¼Œæ•°ç»„å°†è§¦å‘é€å­—ç¬¦å¾ªç¯ç€è‰²ï¼‰
                    const comboColorSpec = colorNumbers.length ? colorNumbers : (this.dominantColor || 1);
                    // ä¸æ¿€åŠ±è¯ã€åŠ åˆ†å…±ç”¨ä¸€ä¸ªé”šç‚¹ï¼šå¤ç”¨ä¸Šæ–¹è®¡ç®—çš„ anchor
                    // ä¸Šæ–¹æ˜¾ç¤ºæ¿€åŠ±è¯ï¼ˆè‹¥å­˜åœ¨ï¼‰ä½¿ç”¨ä¸é…éŸ³ä¸€è‡´çš„ compositeCueï¼ˆè¿å‡»è‡ªå¢å‰ï¼‰
                    if (this.settings && this.settings.motivationEnabled) {
                    const cue = this.getBestVoiceCueId(compositeCue);
                    if (cue) this.addComboText(this.formatVoiceLabel(cue), comboColorSpec, 'top', anchor);
                    }
                    // ä¸­é—´æ˜¾ç¤ºè¿å‡»æç¤º
                    this.addComboText(text, comboColorSpec, 'center', anchor);
                    // ä¸‹æ–¹æ˜¾ç¤ºåŠ åˆ†åŠ¨æ•ˆï¼ˆä¸ä¸Šé¢é—´è·ä¸€è‡´ï¼‰
                    // è®©åŠ åˆ†é¢œè‰²ä¸ä¸Šæ–¹æ–‡æ¡ˆä¿æŒä¸€è‡´
                    this.showEliminationScoreWithColor(totalScore, cellsToRemove, anchor, comboColorSpec);
                }
            }

            // æ’­æ”¾æœ¬åœ°æ¿€åŠ±è¯è¯­éŸ³ï¼šæ ¹æ® VOICE_CUES ä¸­çš„é˜ˆå€¼è¡¨é€‰æ‹©æœ€å¼ºåŒ¹é…
            playVoiceForElimination(eliminatedCount) {
                try {
                    if (!this.settings || !this.settings.soundEnabled || !this.settings.voiceEnabled) {
                        return;
                    }
                    const now = performance.now();
                    if (now - lastVoicePlayTs < VOICE_COOLDOWN_MS) return;
                    initVoiceAudios();
                    // é€‰æ‹©é˜ˆå€¼<=æ¶ˆé™¤æ•°çš„æœ€å¤§é¡¹
                    let chosen = null;
                    for (let i = 0; i < VOICE_CUES.length; i++) {
                        if (eliminatedCount >= VOICE_CUES[i].threshold) {
                            chosen = VOICE_CUES[i];
                        } else {
                            break;
                        }
                    }
                    if (!chosen) return;
                    // åœæ­¢æ‰€æœ‰å·²åŠ è½½çš„è¯­éŸ³ï¼Œé¿å…å éŸ³
                    Object.values(voiceAudioMap).forEach(a => {
                        if (a) {
                            try { a.pause(); a.currentTime = 0; } catch (_) {}
                        }
                    });
                    const target = voiceAudioMap[chosen.id];
                    if (target) {
                        const r = target.play();
                        lastVoicePlayTs = now;
                        if (r && typeof r.catch === 'function') r.catch(() => {});
                    }
                } catch (err) {
                    console.log('è¯­éŸ³æ’­æ”¾å¤±è´¥:', err);
                }
            }

            findConnectedGroups() {
                const visited = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(false));
                const cellsToRemove = [];
                
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (!visited[row][col] && this.grid[row][col] > 0) {
                            const group = this.getConnectedGroup(row, col, this.grid[row][col], visited);
                            if (group.length >= 8) {
                                cellsToRemove.push(...group);
                            }
                        }
                    }
                }
                
                return cellsToRemove;
            }

            getConnectedGroup(startRow, startCol, color, visited) {
                const stack = [{row: startRow, col: startCol}];
                const group = [];
                const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]; // å³ï¼Œä¸‹ï¼Œå·¦ï¼Œä¸Š
                
                while (stack.length > 0) {
                    const {row, col} = stack.pop();
                    
                    if (row < 0 || row >= this.gridSize || col < 0 || col >= this.gridSize || 
                        visited[row][col] || this.grid[row][col] !== color) {
                        continue;
                    }
                    
                    visited[row][col] = true;
                    group.push({row, col});
                    
                    // æ£€æŸ¥å››ä¸ªæ–¹å‘
                    directions.forEach(([dr, dc]) => {
                        stack.push({row: row + dr, col: col + dc});
                    });
                }
                
                return group;
            }

            animateClearance(cells) {
                const eliminatedCount = cells.length;
                const comboCount = this.comboMultiplier > 1 ? Math.round((this.comboMultiplier - 1) / 0.5) : 0;
                const composite = eliminatedCount + comboCount;
                // é¢œè‰²ç»Ÿè®¡é€»è¾‘ç§»è‡³ collectColorsFromCells
                
                // åŸºç¡€é—ªçƒæ•ˆæœï¼ˆä¿æŒç°æœ‰ï¼‰
                cells.forEach(({ row, col }) => {
                    const cellIndex = row * this.gridSize + col;
                    const cellElement = document.getElementById('grid').children[cellIndex];
                    // å…ˆç§»é™¤æ‰€æœ‰clearing-color-x
                    for (let i = 1; i <= 8; i++) cellElement.classList.remove('clearing-color-' + i);
                    // è·å–å½“å‰cellé¢œè‰²
                    const color = this.grid[row][col];
                    if (color) cellElement.classList.add('clearing-color-' + color);
                    cellElement.classList.add('clearing');
                    setTimeout(() => {
                        cellElement.classList.remove('clearing');
                        for (let i = 1; i <= 8; i++) cellElement.classList.remove('clearing-color-' + i);
                    }, 500);
                });
                
                // åˆ†çº§å¢å¼ºæ•ˆæœ
                if (composite >= 16) {
                    // è¶…å¤§æ¶ˆé™¤ï¼ˆ16+å—ï¼‰ï¼šå¼ºçƒˆæ•ˆæœ
                    this.addScreenShake(6, 150); // å¼ºçƒˆéœ‡åŠ¨
                    this.addParticleExplosion(cells, 30); // å¤§é‡ç²’å­
                } else if (composite >= 14) {
                    // å¤§æ¶ˆé™¤ï¼ˆ14-15å—ï¼‰ï¼šæ˜æ˜¾æ•ˆæœ
                    this.addScreenShake(4, 100); // æ˜æ˜¾éœ‡åŠ¨
                    this.addParticleExplosion(cells, 20); // ä¸­ç­‰ç²’å­
                } else if (composite >= 12) {
                    // ä¸­æ¶ˆé™¤ï¼ˆ12-13å—ï¼‰ï¼šè½»å¾®æ•ˆæœ
                    this.addScreenShake(2, 50); // è½»å¾®éœ‡åŠ¨
                    this.addParticleExplosion(cells, 10); // å°‘é‡ç²’å­
                }
                // å°æ¶ˆé™¤ï¼ˆ8å—ï¼‰ï¼šä¿æŒåŸºç¡€æ•ˆæœ
            }

            // é€‰æ‹©ä¸æœ¬æ¬¡æ¶ˆé™¤æ•°åŒ¹é…çš„æœ€ä½³è¯­éŸ³ cue id
            getBestVoiceCueId(eliminatedCount) {
                let chosen = null;
                for (let i = 0; i < VOICE_CUES.length; i++) {
                    if (eliminatedCount >= VOICE_CUES[i].threshold) {
                        chosen = VOICE_CUES[i].id;
                    } else {
                        break;
                    }
                }
                return chosen;
            }

            // å°† cue id è½¬ä¸ºå±•ç¤ºæ–‡æ¡ˆ
            formatVoiceLabel(id) {
                const special = {
                    goodjob: 'GOOD JOB',
                    welldone: 'WELL DONE'
                };
                if (special[id]) return special[id];
                return id.replace(/[-_]/g, ' ').toUpperCase();
            }
            
            // æ–°å¢ï¼šå±å¹•éœ‡åŠ¨æ•ˆæœ
            addScreenShake(intensity, duration) {
                const gameBoard = document.querySelector('.game-board');
                const originalTransform = gameBoard.style.transform;
                
                // åˆ›å»ºéœ‡åŠ¨åŠ¨ç”»
                let shakeCount = 0;
                const maxShakes = Math.floor(duration / 20); // æ¯50msä¸€æ¬¡éœ‡åŠ¨
                
                const shake = () => {
                    if (shakeCount >= maxShakes) {
                        gameBoard.style.transform = originalTransform;
                        return;
                    }
                    
                    const x = (Math.random() - 0.5) * intensity;
                    const y = (Math.random() - 0.5) * intensity;
                    gameBoard.style.transform = `translate(${x}px, ${y}px)`;
                    
                    shakeCount++;
                    setTimeout(shake, 50);
                };
                
                shake();
            }
            
            // æ–°å¢ï¼šç²’å­çˆ†ç‚¸æ•ˆæœ
            addParticleExplosion(cells, particleCount) {
                const gameBoard = document.querySelector('.game-board');
                const rect = gameBoard.getBoundingClientRect();
                
                // è®¡ç®—æ¶ˆé™¤åŒºåŸŸä¸­å¿ƒ
                let centerX = 0, centerY = 0;
                cells.forEach(({ row, col }) => {
                    const cellIndex = row * this.gridSize + col;
                    const cellElement = document.getElementById('grid').children[cellIndex];
                    const cellRect = cellElement.getBoundingClientRect();
                    centerX += cellRect.left + cellRect.width / 2;
                    centerY += cellRect.top + cellRect.height / 2;
                });
                centerX /= cells.length;
                centerY /= cells.length;
                
                // åˆ›å»ºç²’å­
                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    
                    // éšæœºè¿åŠ¨æ–¹å‘å’Œè·ç¦»
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 50 + Math.random() * 100;
                    const endX = Math.cos(angle) * distance;
                    const endY = Math.sin(angle) * distance;
                    
                    particle.style.cssText = `
                        position: fixed;
                        left: ${centerX}px;
                        top: ${centerY}px;
                        width: 4px;
                        height: 4px;
                        background: ${this.getRandomParticleColor()};
                        border-radius: 50%;
                        pointer-events: none;
                        z-index: 1000;
                        --x: ${endX}px;
                        --y: ${endY}px;
                        animation: particleExplosion 0.8s ease-out forwards;
                    `;
                    
                    document.body.appendChild(particle);
                    
                    // æ¸…ç†ç²’å­
                    setTimeout(() => {
                        if (particle.parentNode) {
                            particle.parentNode.removeChild(particle);
                        }
                    }, 800);
                }
            }
            
            // æ–°å¢ï¼šè¿å‡»æ–‡å­—æ•ˆæœ
            addComboText(text, colorSpec = 0, position = 'center', anchor = null) {
                const gameBoard = document.querySelector('.game-board');
                const rect = gameBoard.getBoundingClientRect();
                // è®¡ç®—é”šç‚¹ï¼šä¼˜å…ˆä½¿ç”¨ä¼ å…¥çš„æ ¼å­ä¸­å¿ƒåæ ‡ï¼Œå¦åˆ™ä½¿ç”¨æ£‹ç›˜ä¸­å¿ƒ
                const baseX = anchor && anchor.x ? anchor.x : (rect.left + rect.width / 2);
                const baseY = anchor && anchor.y ? anchor.y : (rect.top + rect.height / 2);
                let yOffset = 0;
                let fontSize = 36;
                if (position === 'top') { yOffset = -46; fontSize = 42; }
                else if (position === 'bottom') { yOffset = 40; fontSize = 28; }
                else { fontSize = 34; }

                const comboText = document.createElement('div');
                comboText.className = 'combo-text';
                comboText.textContent = text;
                comboText.style.cssText = `
                    position: fixed;
                    left: ${baseX}px;
                    top: ${baseY + yOffset}px;
                    transform: translate(-50%, -50%);
                    font-size: ${fontSize}px;
                    font-weight: bold;
                    color: ${this.getColorByNumber(typeof colorSpec === 'number' ? colorSpec : 0) || '#ff6b6b'};
                    text-shadow: 2px 2px 4px rgba(0,0,0,0.45);
                    pointer-events: none;
                    z-index: 1001;
                    animation: comboText 0.8s ease-out forwards;
                `;

                // åº”ç”¨é¢œè‰²ï¼šæ•°ç»„åˆ™æŒ‰å­—ç¬¦è½®æ¢ï¼Œå¤šè‰²å¾ªç¯ï¼›å•è‰²åˆ™ç›´æ¥ç€è‰²
                if (Array.isArray(colorSpec)) {
                    this.applyPerCharColoring(comboText, text, colorSpec);
                } else {
                    this.applyTextColorStyle(comboText, colorSpec);
                }

                document.body.appendChild(comboText);

                // æ¸…ç†æ–‡å­—
                setTimeout(() => {
                    if (comboText.parentNode) {
                        comboText.parentNode.removeChild(comboText);
                    }
                }, 800);
            }
            
            // ç»Ÿè®¡ä¸€ç»„è¢«æ¶ˆé™¤æ ¼å­çš„é¢œè‰²ï¼ŒæŒ‰æ•°é‡é™åºè¿”å›é¢œè‰²ç¼–å·æ•°ç»„
            collectColorsFromCells(cells) {
                const counts = {};
                try {
                    cells.forEach(({ row, col }) => {
                        const color = this.grid[row][col];
                        if (color > 0) counts[color] = (counts[color] || 0) + 1;
                    });
                } catch (_) {}
                const entries = Object.entries(counts).sort((a, b) => b[1] - a[1]);
                return entries.map(e => parseInt(e[0]));
            }

            // ä»ä¸€æ¬¡æ¶ˆé™¤çš„æ ¼å­ä¸­é€‰å®š"ä¸»å¯¼é¢œè‰²"ï¼šå—æ•°æœ€å¤šï¼›è‹¥å¹¶åˆ—åˆ™éšæœº
            getDominantColorFromCells(cells) {
                    const counts = {};
                try {
                    cells.forEach(({ row, col }) => {
                        const color = this.grid[row][col];
                        if (color > 0) counts[color] = (counts[color] || 0) + 1;
                    });
                } catch (_) {}
                let max = 0;
                let candidates = [];
                    Object.keys(counts).forEach(k => {
                    const v = counts[k];
                    if (v > max) { max = v; candidates = [parseInt(k)]; }
                    else if (v === max) { candidates.push(parseInt(k)); }
                });
                if (candidates.length === 0) return this.dominantColor || 1;
                if (candidates.length === 1) return candidates[0];
                return candidates[Math.floor(Math.random() * candidates.length)];
            }

            // å°†é¢œè‰²è§„æ ¼ï¼ˆå•ä¸ªç¼–å·/æ•°ç»„/å­—ç¬¦ä¸²ï¼‰åº”ç”¨åˆ°æ–‡å­—å…ƒç´ 
            applyTextColorStyle(el, colorSpec) {
                try {
                    // æ•°ç»„ï¼šå¤šè‰²æ¸å˜
                    if (Array.isArray(colorSpec)) {
                        // ä½¿ç”¨"æ¯ä¸ªç¼–å·çš„ä¸»è‰²"åšæ¸å˜ï¼ˆé¿å…å¤šé‡ç«¯ç‚¹é€ æˆåè‰²ï¼‰
                        const palette = colorSpec
                            .filter(n => typeof n === 'number' && n > 0)
                            .map(n => this.getColorByNumber(n));
                        if (palette.length === 0) return;
                        // å»é‡è¿ç»­ç›¸åŒè‰²ï¼Œé¿å…æ¡çº¹
                        const dedup = [palette[0]];
                        for (let i = 1; i < palette.length; i++) {
                            if (palette[i] !== dedup[dedup.length - 1]) dedup.push(palette[i]);
                        }
                        if (dedup.length === 1) {
                            el.style.background = '';
                            el.style.webkitBackgroundClip = '';
                            el.style.backgroundClip = '';
                            el.style.color = dedup[0];
                            return;
                        }
                        // ç­‰åˆ†åˆ†å¸ƒé¢œè‰²åœç‚¹ï¼Œé¿å…"æ–­å±‚"
                        const stops = dedup.map((c, i) => {
                            const p = Math.round((i / (dedup.length - 1)) * 100);
                            return `${c} ${p}%`;
                        });
                        // ç®€åŒ–åˆ°ä¸¤ä¸ªä¸»è‰²æ—¶ï¼Œç›´æ¥åœ¨ 45Â° åšåŒç«¯æ¸å˜
                        // ä¸¤è‰²æ—¶ï¼Œç¨å¾®æé«˜æœ€æš—ç«¯çš„äº®åº¦é¿å…æ•´ä½“åæš—
                        const gradient = dedup.length === 2
                            ? `linear-gradient(45deg, ${dedup[0]} 0%, ${dedup[1]} 100%)`
                            : `linear-gradient(45deg, ${stops.join(', ')})`;
                        el.style.background = gradient;
                        el.style.webkitBackgroundClip = 'text';
                        el.style.backgroundClip = 'text';
                        el.style.color = 'transparent';
                        return;
                    }
                    // å­—ç¬¦ä¸²ï¼šç›´æ¥ä½¿ç”¨ï¼ˆå¯ä¸ºæ¸å˜ï¼‰
                    if (typeof colorSpec === 'string') {
                        if (colorSpec.startsWith('linear-gradient')) {
                            el.style.background = colorSpec;
                            el.style.webkitBackgroundClip = 'text';
                            el.style.backgroundClip = 'text';
                            el.style.color = 'transparent';
                    } else {
                            el.style.background = '';
                            el.style.webkitBackgroundClip = '';
                            el.style.backgroundClip = '';
                            el.style.color = colorSpec;
                        }
                        return;
                    }
                    // æ•°å­—ï¼šå•è‰²
                    if (typeof colorSpec === 'number') {
                        const c = this.getColorByNumber(colorSpec);
                        el.style.background = '';
                        el.style.webkitBackgroundClip = '';
                        el.style.backgroundClip = '';
                        el.style.color = c;
                    }
                } catch (_) {}
            }

            // æ–°å¢ï¼šæŒ‰å­—ç¬¦å¾ªç¯ç€è‰²ï¼ˆç”¨äºå¤šè‰²æ¶ˆé™¤æ—¶çš„æ–‡å­—ï¼‰
            applyPerCharColoring(el, text, palette) {
                try {
                    const colors = (palette || [])
                        .map(c => (typeof c === 'number' ? this.getColorByNumber(c) : c))
                        .filter(Boolean);
                    if (colors.length === 0) { el.textContent = text; return; }
                    el.innerHTML = '';
                    const start = Math.floor(Math.random() * colors.length);
                    for (let i = 0; i < text.length; i++) {
                        const ch = text[i];
                        const span = document.createElement('span');
                        span.textContent = ch;
                        if (ch.trim() !== '') {
                            span.style.color = colors[(start + i) % colors.length];
                        }
                        el.appendChild(span);
                    }
                } catch (_) {
                    el.textContent = text;
                }
            }
            
            // æ–°å¢ï¼šè·å–éšæœºç²’å­é¢œè‰²
            getRandomParticleColor() {
                // ä»ä¸»è‰²è¡¨éšæœºå–ä¸€ä¸ªç«¯ç‚¹è‰²
                const ids = Object.keys(COLOR_STYLES);
                const id = ids[Math.floor(Math.random() * ids.length)];
                const pair = COLOR_STYLES[id];
                return pair[Math.floor(Math.random() * pair.length)] || '#ffd700';
            }
            
            getColorByNumber(colorNumber) {
                // è¿”å›è¯¥ç¼–å·ç”¨äº"æ–‡å­—"çš„ä¸»è‰²ï¼šé€‰æ‹©æ›´äº®çš„ä¸€ç«¯
                const pair = COLOR_STYLES[colorNumber];
                if (pair && pair.length) return pickTextPrimaryColor(pair);
                return '#ffffff';
            }
            
            loadSettings() {
                const defaultSettings = {
                    soundEnabled: true,    // éŸ³æ•ˆå¼€å¯
                    vibrationEnabled: true, // éœ‡åŠ¨å¼€å¯
                    voiceEnabled: WX_MINIPROGRAM_MODE ? false : true,    // å°ç¨‹åºå…³é—­é…éŸ³
                    motivationEnabled: WX_MINIPROGRAM_MODE ? false : true, // å°ç¨‹åºå…³é—­è‹±æ–‡æ¿€åŠ±è¯
                    language: WX_MINIPROGRAM_MODE ? 'zh' : 'en'         // å°ç¨‹åºå¼ºåˆ¶ä¸­æ–‡
                };
                
                try {
                    const savedSettings = localStorage.getItem('blockBlastSettings');
                    if (savedSettings) {
                        const merged = { ...defaultSettings, ...JSON.parse(savedSettings) };
                        if (WX_MINIPROGRAM_MODE) {
                            merged.language = 'zh';
                            merged.voiceEnabled = false;
                            merged.motivationEnabled = false;
                        }
                        return merged;
                    }
                } catch (error) {
                    console.log('åŠ è½½è®¾ç½®å¤±è´¥:', error);
                }
                
                return defaultSettings;
            }
            
            saveSettings() {
                try {
                    localStorage.setItem('blockBlastSettings', JSON.stringify(this.settings));
                } catch (error) {
                    console.log('ä¿å­˜è®¾ç½®å¤±è´¥:', error);
                }
            }
            
            updateSetting(key, value) {
                this.settings[key] = value;
                this.saveSettings();
                if (key === 'language') {
                    this.language = value;
                    this.applyLanguage();
                }
            }

            // å¤šè¯­è¨€è¯æ¡
            getI18n() {
                return {
                    zh: {
                        combo: 'è¿å‡»',
                        gameOver: 'æ¸¸æˆç»“æŸ',
                        finalScore: 'åˆ†æ•°',
                        highScore: 'æœ€é«˜åˆ†',
                        restart: 'é‡æ–°å¼€å§‹',
                        settings: 'è®¾ç½®',
                        sound: 'éŸ³æ•ˆ',
                        vibration: 'éœ‡åŠ¨',
                        voice: 'è¯­éŸ³æ’­æŠ¥',
                        language: 'è¯­è¨€',
                        privacy: 'éšç§æ”¿ç­–',
                        confirm: 'ç¡®å®š'
                    },
                    en: {
                        combo: 'Combo',
                        gameOver: 'Game Over',
                        finalScore: 'Score',
                        highScore: 'Best',
                        restart: 'Restart',
                        settings: 'Settings',
                        sound: 'Sound',
                        vibration: 'Vibration',
                        voice: 'Voice',
                        language: 'Language',
                        privacy: 'Privacy Policy',
                        confirm: 'OK'
                    }
                };
            }

            // åº”ç”¨è¯­è¨€åˆ°ç•Œé¢æ–‡æœ¬
            applyLanguage() {
                const dict = this.getI18n()[this.language] || this.getI18n().zh;
                const el = (id) => document.getElementById(id);
                const setText = (id, text) => { const n = el(id); if (n) n.textContent = text; };
                setText('combo-text', dict.combo);
                setText('game-over-title', dict.gameOver);
                setText('final-score-label', dict.finalScore);
                setText('high-score-label', dict.highScore);
                const restartBtn = el('restart-btn'); if (restartBtn) restartBtn.textContent = dict.restart;
                setText('settings-title', dict.settings);
                setText('sound-label', dict.sound);
                setText('vibration-label', dict.vibration);
                setText('voice-label', dict.voice);
                setText('language-label', dict.language);
                setText('privacy-link', dict.privacy);
                // è®¾ç½®å¼¹çª—çš„"ç¡®å®š"æŒ‰é’®
                const settingsContent = document.querySelector('.settings-content button');
                if (settingsContent) settingsContent.textContent = dict.confirm;
                // è®¾ç½®è¯­è¨€é€‰æ‹©æ¡†
                const langSelect = document.getElementById('language-select');
                if (langSelect) langSelect.value = this.language;
            }

            updateGrid() {
                const cells = document.getElementById('grid').children;
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const cellIndex = row * this.gridSize + col;
                        const cell = cells[cellIndex];
                        
                        // æ¸…é™¤æ‰€æœ‰é¢œè‰²ç±»
                        cell.classList.remove('filled', 'color-1', 'color-2', 'color-3', 'color-4', 'color-5', 'color-6', 'color-7', 'color-8');
                        
                        if (this.grid[row][col] > 0) {
                            cell.classList.add('filled', `color-${this.grid[row][col]}`);
                        }
                    }
                }
            }

            updateScore() {
                // åˆ†æ•°é€’å¢åŠ¨ç”»
                if (scoreAnimationFrame) cancelAnimationFrame(scoreAnimationFrame);
                const targetScore = this.score;
                const step = () => {
                    if (displayScore === targetScore) return;
                    // è®¡ç®—æ­¥é•¿ï¼Œè·¨åº¦å¤§æ—¶åŠ å¿«åŠ¨ç”»
                    let diff = targetScore - displayScore;
                    let delta = Math.ceil(Math.abs(diff) / 10);
                    if (diff > 0) {
                        displayScore = Math.min(displayScore + delta, targetScore);
                    } else {
                        displayScore = Math.max(displayScore - delta, targetScore);
                    }
                    document.getElementById('score').textContent = displayScore;
                    if (displayScore !== targetScore) {
                        scoreAnimationFrame = requestAnimationFrame(step);
                    }
                };
                step();
            }

            updateCombo() {
                document.getElementById('combo').textContent = `x${this.comboMultiplier.toFixed(1)}`;
            }

            showComboBonus(bonus) {
                // ä½¿ç”¨æ¶ˆé™¤åˆ†çš„åŠ¨æ•ˆæ˜¾ç¤ºè¿å‡»å¥–åŠ±
                this.showEliminationScore(bonus, 'è¿å‡»å¥–åŠ±!');
            }
            
            showEliminationScore(score, cellsToRemove = null, anchor = null) {
                const scoreElement = document.createElement('div');
                scoreElement.className = 'elimination-score';
                scoreElement.textContent = `+${score}`; // æ¢å¤åŠ å·
                // ä½¿ç”¨ fixed å®šä½åˆ°è§†çª—ï¼Œç»Ÿä¸€ä¸å…¶ä»–æç¤ºä¸€è‡´
                document.body.appendChild(scoreElement);
                
                // å¦‚æœæœ‰æ¶ˆé™¤ä½ç½®ä¿¡æ¯ï¼Œè®¡ç®—æ˜¾ç¤ºä½ç½®
                if (anchor && typeof anchor.x === 'number' && typeof anchor.y === 'number') {
                    const x = anchor.x;
                    const y = anchor.y + 46; // ä¸ä¸Šæ–¹æ¿€åŠ±è¯å’Œä¸­é—´è¿å‡»çš„é—´è·ä¸€è‡´
                    scoreElement.style.left = x + 'px';
                    scoreElement.style.top = y + 'px';
                    scoreElement.style.transform = 'translate(-50%, -50%)';
                    scoreElement.style.fontSize = '26px';
                } else if (Array.isArray(cellsToRemove) && cellsToRemove.length > 0) {
                    let totalRow = 0, totalCol = 0;
                    cellsToRemove.forEach(({row, col}) => {
                        totalRow += row;
                        totalCol += col;
                    });
                    const centerRow = totalRow / cellsToRemove.length;
                    const centerCol = totalCol / cellsToRemove.length;
                    const gridElement = document.getElementById('grid');
                    const gridRect = gridElement.getBoundingClientRect();
                    const cellSize = gridRect.width / this.gridSize;
                    const x = gridRect.left + centerCol * cellSize + cellSize / 2;
                    const y = gridRect.top + centerRow * cellSize + cellSize / 2 + 46; // ä¸æ¿€åŠ±è¯/è¿å‡»çš„é—´è·ä¸€è‡´
                    scoreElement.style.left = x + 'px';
                    scoreElement.style.top = y + 'px';
                    scoreElement.style.transform = 'translate(-50%, -50%)';
                    scoreElement.style.fontSize = '26px';
                }
                setTimeout(() => {
                    if (scoreElement.parentNode) {
                        scoreElement.parentNode.removeChild(scoreElement);
                    }
                }, 1000);
            }

            // åŒæ­¥é¢œè‰²ç‰ˆï¼šä¼ å…¥å…·ä½“é¢œè‰²
            showEliminationScoreWithColor(score, cellsToRemove = null, anchor = null, colorSpec = '#ffd700') {
                const el = document.createElement('div');
                el.className = 'elimination-score';
                el.textContent = `+${score}`;
                // é»˜è®¤æŒ‰å•è‰²å˜é‡èµ°åŠ¨ç”»
                if (!Array.isArray(colorSpec) && typeof colorSpec === 'string' && !colorSpec.startsWith('linear-gradient')) {
                    el.style.setProperty('--elim-color', colorSpec);
                }
                document.body.appendChild(el);

                if (anchor && typeof anchor.x === 'number' && typeof anchor.y === 'number') {
                    const x = anchor.x;
                    const y = anchor.y + 46;
                    el.style.left = x + 'px';
                    el.style.top = y + 'px';
                    el.style.transform = 'translate(-50%, -50%)';
                    el.style.fontSize = '26px';
                } else if (Array.isArray(cellsToRemove) && cellsToRemove.length > 0) {
                    let totalRow = 0, totalCol = 0;
                    cellsToRemove.forEach(({row, col}) => { totalRow += row; totalCol += col; });
                    const centerRow = totalRow / cellsToRemove.length;
                    const centerCol = totalCol / cellsToRemove.length;
                    const gridElement = document.getElementById('grid');
                    const gridRect = gridElement.getBoundingClientRect();
                    const cellSize = gridRect.width / this.gridSize;
                    const x = gridRect.left + centerCol * cellSize + cellSize / 2;
                    const y = gridRect.top + centerRow * cellSize + cellSize / 2 + 46;
                    el.style.left = x + 'px';
                    el.style.top = y + 'px';
                    el.style.transform = 'translate(-50%, -50%)';
                    el.style.fontSize = '26px';
                }
                // åº”ç”¨å•è‰²æˆ–æŒ‰å­—ç¬¦å¾ªç¯è‰²ï¼ˆè¦†ç›–é»˜è®¤é¢œè‰²å˜é‡ï¼‰
                if (Array.isArray(colorSpec)) {
                    this.applyPerCharColoring(el, `+${score}` , colorSpec);
                } else {
                    this.applyTextColorStyle(el, colorSpec);
                }
                // æ¸å˜/å¤šè‰²æ—¶é˜´å½±å®¹æ˜“å‹æš—ï¼Œä¿æŒè¾ƒè½»
                el.style.textShadow = '2px 2px 4px rgba(0,0,0,0.35)';
                setTimeout(() => { if (el.parentNode) el.parentNode.removeChild(el); }, 1000);
            }
            
            showComboEffect(comboCount) {
                if (comboCount < 2) return; // åªæœ‰2è¿å‡»ä»¥ä¸Šæ‰æ˜¾ç¤º
                
                // åˆ›å»ºè¿å‡»ç‰¹æ•ˆå…ƒç´ 
                const comboElement = document.createElement('div');
                comboElement.className = 'combo-effect';
                comboElement.textContent = `${comboCount}è¿å‡»ï¼`;
                
                // ç›´æ¥æ·»åŠ åˆ°bodyï¼Œç¡®ä¿ç»å¯¹å®šä½æ­£ç¡®
                document.body.appendChild(comboElement);
                
                // å±å¹•éœ‡åŠ¨æ•ˆæœ
                this.shakeScreen(comboCount);
                
                // 1.2ç§’åç§»é™¤
                setTimeout(() => {
                    if (comboElement.parentNode) {
                        comboElement.parentNode.removeChild(comboElement);
                    }
                }, 1200);
            }
            
            shakeScreen(comboCount) {
                const gamePanel = document.querySelector('.game-panel');
                const intensity = Math.min(comboCount * 2, 10); // è¿å‡»æ•°è¶Šé«˜éœ‡åŠ¨è¶Šå¼ºï¼Œæœ€å¤§10px
                
                // æ·»åŠ éœ‡åŠ¨åŠ¨ç”»
                gamePanel.style.animation = `screenShake 0.3s ease-in-out`;
                
                // ç§»é™¤åŠ¨ç”»ç±»
                setTimeout(() => {
                    gamePanel.style.animation = '';
                }, 300);
                
                // è®¾å¤‡éœ‡åŠ¨
                this.vibrateDevice(comboCount);
            }
            
            vibrateDevice(comboCount) {
                // æ£€æŸ¥è®¾ç½®æ˜¯å¦å¼€å¯éœ‡åŠ¨
                if (!this.settings.vibrationEnabled) {
                    return;
                }
                
                // æ£€æŸ¥æ˜¯å¦æ”¯æŒéœ‡åŠ¨API
                if ('vibrate' in navigator) {
                    try {
                        // æ ¹æ®è¿å‡»æ•°è®¾ç½®éœ‡åŠ¨æ¨¡å¼
                        let vibrationPattern;
                        if (comboCount >= 5) {
                            // 5è¿å‡»ä»¥ä¸Šï¼šå¼ºçƒˆéœ‡åŠ¨
                            vibrationPattern = [100, 50, 100, 50, 100, 50, 200];
                        } else if (comboCount >= 3) {
                            // 3-4è¿å‡»ï¼šä¸­ç­‰éœ‡åŠ¨
                            vibrationPattern = [80, 40, 80, 40, 150];
                        } else {
                            // 2è¿å‡»ï¼šè½»å¾®éœ‡åŠ¨
                            vibrationPattern = [50, 30, 100];
                        }
                        
                        navigator.vibrate(vibrationPattern);
                        console.log('è®¾å¤‡éœ‡åŠ¨:', vibrationPattern);
                    } catch (error) {
                        console.log('éœ‡åŠ¨å¤±è´¥:', error);
                    }
                } else {
                    console.log('è®¾å¤‡ä¸æ”¯æŒéœ‡åŠ¨');
                }
            }
            
            vibrateOnElimination(eliminatedCount) {
                // æ£€æŸ¥è®¾ç½®æ˜¯å¦å¼€å¯éœ‡åŠ¨
                if (!this.settings.vibrationEnabled) {
                    return;
                }
                
                // æ£€æŸ¥æ˜¯å¦æ”¯æŒéœ‡åŠ¨API
                if ('vibrate' in navigator) {
                    try {
                        // æ ¹æ®æ¶ˆé™¤æ•°é‡è®¾ç½®éœ‡åŠ¨å¼ºåº¦
                        let vibrationPattern;
                        if (eliminatedCount >= 20) {
                            // å¤§é‡æ¶ˆé™¤ï¼šå¼ºçƒˆéœ‡åŠ¨
                            vibrationPattern = [120, 60, 120, 60, 120, 60, 250];
                        } else if (eliminatedCount >= 12) {
                            // ä¸­ç­‰æ¶ˆé™¤ï¼šä¸­ç­‰éœ‡åŠ¨
                            vibrationPattern = [80, 40, 80, 40, 150];
                        } else {
                            // å°‘é‡æ¶ˆé™¤ï¼šè½»å¾®éœ‡åŠ¨
                            vibrationPattern = [40, 20, 80];
                        }
                        
                        navigator.vibrate(vibrationPattern);
                        console.log('æ¶ˆé™¤éœ‡åŠ¨:', vibrationPattern);
                    } catch (error) {
                        console.log('éœ‡åŠ¨å¤±è´¥:', error);
                    }
                }
            }
            
            speakGood() {
                // æ£€æŸ¥è®¾ç½®æ˜¯å¦å¼€å¯è¯­éŸ³æ’­æŠ¥
                if (!this.settings.voiceEnabled) {
                    return;
                }
                
                // æ£€æŸ¥æ˜¯å¦æ”¯æŒè¯­éŸ³åˆæˆ
                if ('speechSynthesis' in window) {
                    try {
                        // åœæ­¢å½“å‰æ­£åœ¨æ’­æ”¾çš„è¯­éŸ³
                        speechSynthesis.cancel();
                        
                        // åˆ›å»ºè¯­éŸ³åˆæˆå¯¹è±¡
                        const utterance = new SpeechSynthesisUtterance('good');
                        
                        // è®¾ç½®è¯­éŸ³å‚æ•°
                        utterance.lang = 'en-US';        // è‹±è¯­
                        utterance.rate = 0.8;            // è¯­é€Ÿç¨æ…¢ï¼Œæ›´æœ‰åŠ›é‡æ„Ÿ
                        utterance.pitch = 0.7;           // éŸ³è°ƒè¾ƒä½ï¼Œæˆç†Ÿç”·éŸ³
                        utterance.volume = 0.9;          // éŸ³é‡é€‚ä¸­
                        
                        // å°è¯•é€‰æ‹©ç”·å£°
                        const voices = speechSynthesis.getVoices();
                        const maleVoice = voices.find(voice => 
                            voice.lang.includes('en') && 
                            voice.name.toLowerCase().includes('male')
                        );
                        
                        if (maleVoice) {
                            utterance.voice = maleVoice;
                        }
                        
                        // æ’­æ”¾è¯­éŸ³
                        speechSynthesis.speak(utterance);
                        
                        console.log('è¯­éŸ³æ’­æŠ¥: good');
                    } catch (error) {
                        console.log('è¯­éŸ³æ’­æŠ¥å¤±è´¥:', error);
                    }
                } else {
                    console.log('æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³åˆæˆ');
                }
            }
            
            showPlacementScore(score) {
                // æ—§å‡½æ•°ä¿ç•™å ä½ï¼Œä¸å†ä½¿ç”¨
            }

            // æ–°ï¼šä»…æ”¾ç½®å¾—åˆ†çš„ç°ç™½å°å­—åŠ¨æ•ˆï¼ˆæ— æ¶ˆé™¤æ—¶æ˜¾ç¤ºï¼‰
            showPlacementOnlyScore(score, anchor) {
                if (!score || !anchor) return;
                const el = document.createElement('div');
                el.className = 'placement-score';
                el.textContent = `+${score}`;
                el.style.left = anchor.x + 'px';
                el.style.top = anchor.y + 'px';
                el.style.transform = 'translate(-50%, -50%)';
                document.body.appendChild(el);
                setTimeout(() => { if (el.parentNode) el.parentNode.removeChild(el); }, 600);
            }

            isGameOver() {
                const remainingShapes = this.currentShapes.filter(s => s !== null);
                if (remainingShapes.length === 0) return false;

                return !remainingShapes.some(shapeWithColor => {
                    for (let row = 0; row < this.gridSize; row++) {
                        for (let col = 0; col < this.gridSize; col++) {
                            if (this.canPlaceShape(shapeWithColor.pattern, row, col)) {
                                return true;
                            }
                        }
                    }
                    return false;
                });
            }
            
            // æ£€æŸ¥æ­»äº¡æ—¶è€ƒè™‘æ‹–æ‹½ä¸­çš„æ–¹å—
            isGameOverWithDraggedShape() {
                const remainingShapes = this.currentShapes.filter(s => s !== null);
                if (remainingShapes.length === 0) return false;
                
                // å¦‚æœæœ‰æ‹–æ‹½ä¸­çš„æ–¹å—ï¼Œå°†å…¶åŠ å…¥æ£€æµ‹
                const shapesToCheck = [...remainingShapes];
                if (this.draggedShape && this.draggedShape.shapeWithColors) {
                    shapesToCheck.push(this.draggedShape.shapeWithColors);
                }

                return !shapesToCheck.some(shapeWithColor => {
                    for (let row = 0; row < this.gridSize; row++) {
                        for (let col = 0; col < this.gridSize; col++) {
                            if (this.canPlaceShape(shapeWithColor.pattern, row, col)) {
                                return true;
                            }
                        }
                    }
                    return false;
                });
            }
            
            checkGameOverWithDelay() {
                // æ¸…é™¤ä¹‹å‰çš„å»¶è¿Ÿæ£€æµ‹
                if (this.gameOverCheckTimeout) {
                    clearTimeout(this.gameOverCheckTimeout);
                    this.gameOverCheckTimeout = null;
                }
                
                // å»¶è¿Ÿ1ç§’åæ£€æµ‹æ­»äº¡
                this.gameOverCheckTimeout = setTimeout(() => {
                    this.gameOverCheckTimeout = null;
                    this.performGameOverCheck();
                }, 1000);
            }
            
            performGameOverCheck() {
                // é˜²æ­¢é‡å¤æ£€æµ‹
                if (this.isPerformingGameOverCheck) {
                    return;
                }
                
                this.isPerformingGameOverCheck = true;
                
                try {
                    // å¦‚æœæ­£åœ¨æ‹–æ‹½ï¼Œç­‰å¾…ç©å®¶æ¾æ‰‹
                    if (this.draggedShape) {
                        // è®¾ç½®ä¸€ä¸ªæ ‡è®°ï¼Œåœ¨æ¾æ‰‹æ—¶æ£€æŸ¥
                        this.pendingGameOverCheck = true;
                        return;
                    }
                    
                    // æ£€æŸ¥æ­»äº¡ï¼ˆè€ƒè™‘æ‹–æ‹½ä¸­çš„æ–¹å—ï¼‰
                    if (this.isGameOverWithDraggedShape()) {
                        // æ­»äº¡åˆ¤å®šé€šè¿‡ï¼Œå¼€å§‹æ­»äº¡åŠ¨ç”»
                        this.startDeathAnimation();
                    }
                } finally {
                    this.isPerformingGameOverCheck = false;
                }
            }
            
            // æ–°å¢ï¼šæ­»äº¡åŠ¨ç”»å¯åŠ¨å‡½æ•°
            startDeathAnimation() {
                if (this.isDeathAnimationPlaying) {
                    return;
                }
                this.isDeathAnimationPlaying = true;
                
                // ç›´æ¥å¼€å§‹ç›˜é¢å¡«æ»¡åŠ¨ç”»
                this.fillGridDirectly();
            }
            
            // æ–°å¢ï¼šç›˜é¢å¡«æ»¡åŠ¨ç”»
            fillGridDirectly() {
                // æ‰¾åˆ°æ‰€æœ‰ç©ºä½ç½®
                const emptyPositions = [];
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (this.grid[row][col] === 0) {
                            emptyPositions.push({row, col});
                        }
                    }
                }
                // è‹¥æ— ç©ºä½ï¼ˆæ£‹ç›˜å·²æ»¡ï¼‰ï¼Œç›´æ¥å®Œæˆæ­»äº¡æµç¨‹å¹¶æ’­æ”¾BGM
                if (emptyPositions.length === 0) {
                    try { this.playDescendingBGM(); } catch(_) {}
                    setTimeout(() => { this.onDeathAnimationComplete(); }, 300);
                    return;
                }
                
                // éšæœºæ‰“ä¹±ç©ºä½ç½®é¡ºåº
                for (let i = emptyPositions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [emptyPositions[i], emptyPositions[j]] = [emptyPositions[j], emptyPositions[i]];
                }
                
                // é€æ ¼å¡«æ»¡
                emptyPositions.forEach(({row, col}, index) => {
                    setTimeout(() => {
                        // ä½¿ç”¨å…¨é¢œè‰²æ± 
                        const fullColorPool = [1, 2, 3, 4, 5, 6, 7, 8];
                        const randomColor = fullColorPool[Math.floor(Math.random() * fullColorPool.length)];
                        this.grid[row][col] = randomColor;
                        this.updateGrid();
                        
                        // æ’­æ”¾å¡«æ»¡éŸ³æ•ˆ
                        this.playFillSound();
                        
                        // æœ€åä¸€ä¸ªæ–¹å—å¡«æ»¡åï¼Œå®Œæˆæ­»äº¡åŠ¨ç”»
                        if (index === emptyPositions.length - 1) {
                            setTimeout(() => {
                                this.onDeathAnimationComplete();
                            }, 500);
                        }
                    }, index * 50);
                });
                
                // æ’­æ”¾é™è°ƒBGM
                this.playDescendingBGM();
            }
            
            // æ–°å¢ï¼šæ­»äº¡åŠ¨ç”»å®Œæˆå›è°ƒ
            onDeathAnimationComplete() {
                this.isDeathAnimationPlaying = false;
                this.deathAnimationStage = 0;
                this.deathAnimationTimeouts.forEach(timeout => clearTimeout(timeout));
                this.deathAnimationTimeouts = [];
                
                // ç»“æŸæ¸¸æˆ
                this.endGame();
            }
            
            // æ–°å¢ï¼šæ¸…ç†æ­»äº¡åŠ¨ç”»çŠ¶æ€
            clearDeathAnimation() {
                this.isDeathAnimationPlaying = false;
                this.deathAnimationStage = 0;
                this.deathAnimationTimeouts.forEach(timeout => clearTimeout(timeout));
                this.deathAnimationTimeouts = [];
                
                // ç§»é™¤ç›¸å…³CSSç±»
                const gameBoard = document.querySelector('.game-board');
                if (gameBoard) {
                    gameBoard.classList.remove('fill-grid');
                }
            }
            
            // æ–°å¢ï¼šæ’­æ”¾å¡«æ»¡éŸ³æ•ˆ
            playFillSound() {
                if (!this.settings.soundEnabled) return;
                
                // æ’­æ”¾æ¸…è„†çš„å¡«æ»¡éŸ³æ•ˆ
                const duration = 0.1;
                const bufferSize = audioCtx.sampleRate * duration;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    // æ¸…è„†çš„"å®"å£°
                    const t = i / audioCtx.sampleRate;
                    data[i] = Math.sin(2 * Math.PI * 800 * t) * Math.exp(-t * 10) * 0.07;
                }
                
                const source = audioCtx.createBufferSource();
                source.buffer = buffer;
                source.connect(audioCtx.destination);
                source.start();
            }
            
            // æ–°å¢ï¼šæ’­æ”¾é™è°ƒBGM
            playDescendingBGM() {
                if (!this.settings.soundEnabled) return;
                
                console.log('å¼€å§‹æ’­æ”¾é™è°ƒBGM');
                
                // å¸¦èŠ‚å¥æ„Ÿçš„é™è°ƒBGM
                const duration = 2.0; // 2ç§’BGM
                const bufferSize = audioCtx.sampleRate * duration;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate); // å•å£°é“
                const data = buffer.getChannelData(0);
                
                // å®šä¹‰èŠ‚å¥æ¨¡å¼ï¼šå“’å“’ï¼Œå“’å“’å“’å“’
                const rhythm = [
                    { freq: 500, duration: 0.2, start: 0.0 },    // å“’
                    { freq: 440, duration: 0.2, start: 0.3 },    // å“’
                    { freq: 415, duration: 0.15, start: 0.8 },   // å“’
                    { freq: 392, duration: 0.15, start: 0.96 },   // å“’
                    { freq: 370, duration: 0.2, start: 1.12 },    // æœ€åä¸¤ä¸ªé•¿éŸ³
                    { freq: 349, duration: 0.2, start: 1.3 }     // ç»“æŸ
                ];
                
                rhythm.forEach(note => {
                    const startSample = Math.floor(note.start * audioCtx.sampleRate);
                    const endSample = Math.floor((note.start + note.duration) * audioCtx.sampleRate);
                    
                    for (let i = startSample; i < endSample && i < bufferSize; i++) {
                        const t = (i - startSample) / audioCtx.sampleRate;
                        const envelope = Math.exp(-t * 3); // æ›´å¿«çš„è¡°å‡ï¼Œè¥é€ æ‰“å‡»æ„Ÿ
                        data[i] = Math.sin(2 * Math.PI * note.freq * t) * envelope * 0.3;
                    }
                });
                
                const source = audioCtx.createBufferSource();
                source.buffer = buffer;
                source.connect(audioCtx.destination);
                source.start();
                
                console.log('é™è°ƒBGMæ’­æ”¾å®Œæˆ');
            }
            
            // æ–°å¢ï¼šæ’­æ”¾å¼€å±€æ¿€åŠ±BGM
            playStartupBGM() {
                if (!this.settings.soundEnabled) return;
                
                console.log('å¼€å§‹æ’­æ”¾å¼€å±€BGM');
                
                // æ¸…è„†è½»å¿«çš„å¼€å±€BGM - 12ä¸ªéŸ³ç¬¦
                const duration = 0.7; // å¢åŠ æ€»æ—¶é•¿åˆ°0.8ç§’
                const bufferSize = audioCtx.sampleRate * duration;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate); // å•å£°é“
                const data = buffer.getChannelData(0);
                
                // 12ä¸ªæ¸…è„†çš„ä¸Šå‡éŸ³ç¬¦ - Cå¤§è°ƒ
                const notes = [523, 587, 659, 698, 784, 880, 988, 1047, 1175, 1319, 1397, 1568]; // C5, D5, E5, F5, G5, A5, B5, C6, D6, E6, F6, G6
                const noteDuration = duration / notes.length;
                
                notes.forEach((freq, noteIndex) => {
                    const startSample = Math.floor(noteIndex * noteDuration * audioCtx.sampleRate);
                    const endSample = Math.floor((noteIndex + 1) * noteDuration * audioCtx.sampleRate);
                    
                    // éŸ³é‡è¡°å‡ï¼šä»æŒ¯å¥‹(0.4)é€æ¸é™åˆ°æ²‰æµ¸(0.1)
                    const volumeDecay = 0.4 - (noteIndex / (notes.length - 1)) * 0.30;
                    
                    for (let i = startSample; i < endSample && i < bufferSize; i++) {
                        const t = (i - startSample) / audioCtx.sampleRate;
                        // æ›´æ…¢çš„è¡°å‡ï¼Œç¡®ä¿é«˜é¢‘éŸ³ç¬¦ä¹Ÿèƒ½å¬åˆ°
                        const envelope = Math.exp(-t * 2) * (1 - t / noteDuration);
                        // å‡å°‘è°æ³¢ï¼Œé¿å…é«˜é¢‘å¹²æ‰°
                        const fundamental = Math.sin(2 * Math.PI * freq * t);
                        const harmonic = Math.sin(2 * Math.PI * freq * 2 * t) * 0.1;
                        data[i] = (fundamental + harmonic) * envelope * volumeDecay;
                    }
                });
                
                const source = audioCtx.createBufferSource();
                source.buffer = buffer;
                source.connect(audioCtx.destination);
                source.start();
                
                console.log('å¼€å±€BGMæ’­æ”¾å®Œæˆ');
            }
            
            // æ–°å¢ï¼šæ¸…ç†æ­»äº¡æ£€æµ‹çŠ¶æ€
            clearGameOverCheck() {
                if (this.gameOverCheckTimeout) {
                    clearTimeout(this.gameOverCheckTimeout);
                    this.gameOverCheckTimeout = null;
                }
                this.pendingGameOverCheck = false;
                this.isPerformingGameOverCheck = false;
            }

            endGame() {
                // æ¸…ç†æ­»äº¡æ£€æµ‹çŠ¶æ€
                this.clearGameOverCheck();
                
                // æ¸…ç†æ­»äº¡åŠ¨ç”»çŠ¶æ€
                this.clearDeathAnimation();
                
                // æ›´æ–°æœ€é«˜åˆ†
                const isNewRecord = this.score > this.highScore;
                if (isNewRecord) {
                    this.highScore = this.score;
                    SaveManager.saveHighScore(this.highScore); // ä¿å­˜åˆ°ç‹¬ç«‹å­˜å‚¨
                    console.log('æ–°çºªå½•ï¼æœ€é«˜åˆ†æ›´æ–°ä¸º:', this.highScore);
                }
                
                // æ¸…é™¤æ¸¸æˆå­˜æ¡£ï¼Œé¿å…åŠ è½½æ—¶å¡åœ¨ç»“æŸçŠ¶æ€
                SaveManager.clearSave();
                
                // æ˜¾ç¤ºæ¸¸æˆç»“æŸç•Œé¢
                document.getElementById('game-over').classList.remove('hidden');
                
                // æ ¹æ®æ˜¯å¦æ–°çºªå½•è°ƒæ•´ç»“æŸå¼¹çª—æ ·å¼ä¸æ–‡æ¡ˆ
                const overPanel = document.querySelector('#game-over .game-over-content');
                const titleEl = document.getElementById('game-over-title');
                const finalScoreLabelEl = document.getElementById('final-score-label');
                const highScoreBlock = document.getElementById('high-score').parentNode; // æ•´ä¸ªæœ€é«˜åˆ†æ®µè½
                if (isNewRecord) {
                    overPanel.classList.add('best-record');
                    titleEl.textContent = (this.language === 'zh' ? 'æœ€é«˜åˆ†' : 'BestScore');
                    // éšè—åŸæœ‰çš„"Best Score"è¡Œ
                    highScoreBlock.style.display = 'none';
                    // å¾®è°ƒå¸ƒå±€ï¼šå°†å½“å‰åˆ†æ•°æ ‡ç­¾éšè—ï¼Œä»…ä¿ç•™æ•°å€¼æ›´çªå‡º
                    if (finalScoreLabelEl) finalScoreLabelEl.style.display = 'none';
                } else {
                    overPanel.classList.remove('best-record');
                    titleEl.textContent = (this.language === 'zh' ? 'æ¸¸æˆç»“æŸ' : 'Game Over');
                    highScoreBlock.style.display = '';
                    if (finalScoreLabelEl) finalScoreLabelEl.style.display = '';
                }
                
                // åˆ†æ•°åŠ¨æ•ˆï¼šä»å°åˆ°å¤§çš„æ•ˆæœ
                const finalScoreElement = document.getElementById('final-score');
                const highScoreElement = document.getElementById('high-score');
                
                // å…ˆè®¾ç½®æœ€é«˜åˆ†
                highScoreElement.textContent = this.highScore;
                
                // åˆ†æ•°åŠ¨æ•ˆï¼šä»0å¼€å§‹å¢é•¿åˆ°æœ€ç»ˆåˆ†æ•°
                let currentScore = 0;
                const targetScore = this.score;
                const duration = 800; // 0.8ç§’åŠ¨ç”»
                const startTime = Date.now();
                
                const animateScore = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°è®©åŠ¨ç”»æ›´è‡ªç„¶
                    const easeOutQuart = 1 - Math.pow(1 - progress, 4);
                    currentScore = Math.floor(easeOutQuart * targetScore);
                    
                    finalScoreElement.textContent = currentScore;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateScore);
                    } else {
                        // åŠ¨ç”»å®Œæˆï¼Œåœæ­¢è®¡åˆ†éŸ³æ•ˆå¹¶ç»™ç»“æŸæç¤º
                        stopScoreCountSfx(true);
                    }
                };
                
                // å¯åŠ¨è®¡åˆ†éŸ³æ•ˆï¼ˆéè¯­éŸ³ï¼‰å¹¶å¼€å§‹åŠ¨ç”»
                startScoreCountSfx();
                animateScore();
                // ç§»é™¤æ¸¸æˆç»“æŸæ—¶çš„è¯­éŸ³æ’­æ”¾ï¼Œé¿å…ä¸æ¶ˆé™¤éŸ³æ•ˆæ··æ·†
            }

            // æ–°å¢ï¼šåœ¨æŒ‡å®š grid ä¸ŠæŸ¥æ‰¾æ¶ˆé™¤åŒºåŸŸ
            findConnectedGroupsOnGrid(grid) {
                const visited = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(false));
                const cellsToRemove = [];
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (!visited[row][col] && grid[row][col] > 0) {
                            const group = this.getConnectedGroupOnGrid(row, col, grid[row][col], visited, grid);
                            if (group.length >= 8) {
                                cellsToRemove.push(...group);
                            }
                        }
                    }
                }
                return cellsToRemove;
            }
            // æ–°å¢ï¼šåœ¨æŒ‡å®š grid ä¸ŠæŸ¥æ‰¾è¿é€šå—
            getConnectedGroupOnGrid(startRow, startCol, color, visited, grid) {
                const stack = [{row: startRow, col: startCol}];
                const group = [];
                const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                while (stack.length > 0) {
                    const {row, col} = stack.pop();
                    if (row < 0 || row >= this.gridSize || col < 0 || col >= this.gridSize || 
                        visited[row][col] || grid[row][col] !== color) {
                        continue;
                    }
                    visited[row][col] = true;
                    group.push({row, col});
                    directions.forEach(([dr, dc]) => {
                        stack.push({row: row + dr, col: col + dc});
                    });
                }
                return group;
            }

            // ç”Ÿæˆ[min, max]çš„éšæœºæ•´æ•°
            randInt(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            // åˆå§‹åŒ–äºŒä¸‰åˆ†ç­–ç•¥ï¼ˆESFï¼‰ï¼šå°†8æ‹†ä¸ºNâˆˆ{2,3}ä¸ªæ­£æ•´æ•°ï¼Œä¸”æ¯ä¸ªâˆˆ[1..6]ï¼Œå¹¶ç¼“å­˜æœ¬å±€ä¸‰è‰²
            initErSanFenStrategy() {
                // ä»…å½“activeColors>=3æ—¶ä½¿ç”¨å‰ä¸‰ç§é¢œè‰²ï¼›ä¸è¶³åˆ™ç”¨å·²æœ‰é¢œè‰²å¾ªç¯
                const baseColors = this.activeColors.slice(0, 3);
                const colors = baseColors.length === 3 ? baseColors : (baseColors.length === 2 ? [...baseColors, baseColors[0]] : [1,2,3]);
                // éšæœºé€‰æ‹©N=2æˆ–3
                const N = Math.random() < 0.5 ? 2 : 3;
                // æ„é€ æ»¡è¶³å’Œä¸º8ã€æ¯ä¸ª1..6çš„Nå…ƒç»„
                let sizes = [];
                const attempts = 100;
                for (let t = 0; t < attempts; t++) {
                    if (N === 2) {
                        const a = this.randInt(1, 6);
                        const b = 8 - a;
                        if (b >= 1 && b <= 6) { sizes = [a, b]; break; }
                    } else {
                        const a = this.randInt(1, 6);
                        const b = this.randInt(1, 6);
                        const c = 8 - a - b;
                        if (c >= 1 && c <= 6) { sizes = [a, b, c]; break; }
                    }
                }
                if (sizes.length === 0) sizes = N === 2 ? [3,5] : [2,3,3];
                this.esfState = { active: true, sizes, index: 0, colors };
                // å¼‚æ­¥äºŒä¸‰åˆ†ï¼šä¸ºæ¯ä¸ªé¢œè‰²å‡†å¤‡ä¸€ä¸ª"ä¸æ”¾å›"çš„é¢ç§¯æ± ï¼ˆsizesçš„ä¹±åºæ‹·è´ï¼‰ï¼Œè·¨Nè½®é€ä¸ªå–ç”¨
                if (this.useErSanFenAsync) {
                    const bagsByColor = {};
                    colors.forEach(col => {
                        const bag = [...sizes];
                        for (let i = bag.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [bag[i], bag[j]] = [bag[j], bag[i]];
                        }
                        bagsByColor[col] = bag;
                    });
                    this.esfAsync = { bagsByColor };
                } else {
                    this.esfAsync = null;
                }
            }

            // å–å¾—å½“å‰ESFè½®çš„é¢ç§¯ä¸é¢œè‰²åºåˆ—
            getCurrentEsfSpec() {
                if (!this.esfState || !this.esfState.active) return null;
                const i = this.esfState.index % this.esfState.sizes.length;
                const area = this.esfState.sizes[i];
                // ä¸‰ä¸ªå—åˆ†åˆ«ä½¿ç”¨æœ¬å±€ä¸‰è‰²ä¸­çš„ä¸€ç§çº¯è‰²
                const colors = this.esfState.colors;
                return { area, colors };
            }

            // æ¨è¿›åˆ°ä¸‹ä¸€ESFè½®
            advanceEsfRound() {
                if (!this.esfState || !this.esfState.active) return;
                this.esfState.index++;
                if (this.esfState.index >= this.esfState.sizes.length) {
                    // ä¸€è½®ESFç»“æŸï¼Œå¯æŒ‰éœ€åœæ­¢æˆ–å¾ªç¯ï¼›æ­¤å¤„é»˜è®¤åœæ­¢å¹¶æ ‡è®°å®Œæˆ
                    this.esfState.active = false;
                }
            }

            // ä»å½¢çŠ¶åº“ä¸­éšæœºå–"é¢ç§¯æ°å¥½ä¸ºarea"çš„å½¢çŠ¶ï¼›è‹¥åº“ä¸­æ— ç²¾ç¡®é¢ç§¯ï¼Œæ„é€ é€€åŒ–å½¢çŠ¶
            getRandomShapeByArea(area) {
                try {
                    const candidates = [];
                    for (const pattern of this.shapes) {
                        let count = 0;
                        for (let r = 0; r < pattern.length; r++) {
                            for (let c = 0; c < pattern[r].length; c++) {
                                if (pattern[r][c]) count++;
                            }
                        }
                        if (count === area) candidates.push(pattern);
                    }
                    if (candidates.length > 0) {
                        return candidates[Math.floor(Math.random() * candidates.length)];
                    }
                    // å…œåº•ï¼šæ„é€ è¿ç»­æ¡å½¢ï¼ˆä¼˜å…ˆæ¨ªæ¡ï¼‰ï¼Œä¿è¯é¢ç§¯
                    const maxW = Math.min(area, 5);
                    const w = Math.min(area, maxW);
                    const h = Math.ceil(area / w);
                    const pattern = Array.from({ length: h }, () => Array.from({ length: w }, () => 1));
                    // è‹¥é¢ç§¯ä¸æ•´ï¼Œå»æ‰å°¾éƒ¨å¤šä½™æ ¼
                    let toRemove = w * h - area;
                    for (let r = h - 1; r >= 0 && toRemove > 0; r--) {
                        for (let c = w - 1; c >= 0 && toRemove > 0; c--) {
                            pattern[r][c] = 0; toRemove--;
                        }
                    }
                    return pattern;
                } catch (_) {
                    return [[1]];
                }
            }

            // ç”Ÿæˆçº¯è‰²çŸ©é˜µï¼Œä¸ç»™å®špatternçš„å½¢çŠ¶ä¸€è‡´
            buildPureColorMatrix(pattern, colorNumber) {
                const colors = [];
                for (let r = 0; r < pattern.length; r++) {
                    const row = [];
                    for (let c = 0; c < pattern[r].length; c++) {
                        row.push(pattern[r][c] ? colorNumber : 0);
                    }
                    colors.push(row);
                }
                return colors;
            }

            // åˆå§‹åŒ–å•è½®ä¸‰åˆ†ç­–ç•¥ï¼ˆSTSï¼‰ï¼šæŠŠ8æ‹†æˆä¸‰ä»½ a,b,cï¼Œå„âˆˆ[1..6] ä¸”å’Œä¸º8ï¼›ä¸‰å—ç»Ÿä¸€ä½¿ç”¨åŒä¸€ç§éšæœºé¢œè‰²
            initSingleTripleSplitStrategy() {
                // å°è¯•éšæœºæ‰¾åˆ° a+b+c=8 çš„è§£
                let sizes = [];
                for (let t = 0; t < 200; t++) {
                    const a = this.randInt(1, 6);
                    const b = this.randInt(1, 6);
                    const c = 8 - a - b;
                    if (c >= 1 && c <= 6) { sizes = [a, b, c]; break; }
                }
                if (sizes.length === 0) sizes = [2,3,3];
                // ä»å¯ç”¨è‰²ä¸­éšæœºæŒ‘ä¸€è‰²ï¼Œä¸‰å—ç»Ÿä¸€ä¸Šè‰²
                const baseColors = this.activeColors.length ? this.activeColors : [1,2,3];
                const color = baseColors[Math.floor(Math.random()*baseColors.length)];
                this.stsState = { active: true, sizes, color, completed: false };
            }

            // å®ŒæˆSTSåæ¸…ç†çŠ¶æ€
            completeSingleTripleSplit() {
                this.stsState.active = false;
                this.stsState.completed = true;
                this.useSingleTripleSplitStrategy = false;
            }
        }

        let game;

        function getSelectedColorCount() {
            const select = document.getElementById('color-count-select');
            return parseInt(select.value);
        }
        function getSelectedMaxShapeColors() {
            const select = document.getElementById('max-shape-color-select');
            return parseInt(select.value);
        }

        function startGame() {
            game = new BlockBlast(getSelectedColorCount(), getSelectedMaxShapeColors());
            globalGameInstance = game; // è®¾ç½®å…¨å±€å¼•ç”¨
        }

        function restartGame() {
            document.getElementById('game-over').classList.add('hidden');
            SaveManager.clearSave(); // æ¸…é™¤å­˜æ¡£
            startGame();
        }
        
        function showSettings() {
            // æ›´æ–°å¤é€‰æ¡†çŠ¶æ€
            document.getElementById('sound-toggle').checked = game.settings.soundEnabled;
            document.getElementById('vibration-toggle').checked = game.settings.vibrationEnabled;
            document.getElementById('voice-toggle').checked = game.settings.voiceEnabled;
            // æ›´æ–°è¯­è¨€é€‰æ‹©
            const langSelect = document.getElementById('language-select');
            if (langSelect) langSelect.value = game.language || 'zh';
            
            // æ˜¾ç¤ºè®¾ç½®å¼¹çª—
            document.getElementById('settings-modal').classList.remove('hidden');
        }
        
        function closeSettings() {
            // ä¿å­˜è®¾ç½®
            const soundEnabled = document.getElementById('sound-toggle').checked;
            const vibrationEnabled = document.getElementById('vibration-toggle').checked;
            const voiceEnabled = document.getElementById('voice-toggle').checked;
            const language = document.getElementById('language-select').value;
            
            game.updateSetting('soundEnabled', soundEnabled);
            game.updateSetting('vibrationEnabled', vibrationEnabled);
            game.updateSetting('voiceEnabled', voiceEnabled);
            game.updateSetting('language', language);
            
            // éšè—è®¾ç½®å¼¹çª—
            document.getElementById('settings-modal').classList.add('hidden');
        }

        // ç›‘å¬å‚æ•°å˜åŒ–ï¼Œè‡ªåŠ¨é‡å¼€æ¸¸æˆ
        const colorCountSelect = document.getElementById('color-count-select');
        colorCountSelect.addEventListener('change', () => {
            startGame();
        });
        const maxShapeColorSelect = document.getElementById('max-shape-color-select');
        maxShapeColorSelect.addEventListener('change', () => {
            startGame();
        });
        // å¯åŠ¨æ¸¸æˆ
        initDynamicColorStyles();
        startGame();

        // GMé¢æ¿å¼€å…³ï¼Œfalseä¸ºæ­£å¼ç‰ˆä¸æ˜¾ç¤ºï¼Œtrueä¸ºå¼€å‘è°ƒè¯•æ˜¾ç¤º
        const SHOW_DEV_PANEL = false;
        // é¡µé¢åŠ è½½ååªéšè—æ˜¾ç¤ºå’Œäº¤äº’ï¼Œä¸ç§»é™¤DOM
        window.addEventListener('DOMContentLoaded', function() {
            if (!SHOW_DEV_PANEL) {
                const devPanel = document.getElementById('developer-panel');
                if (devPanel) {
                    devPanel.style.display = 'none';
                    devPanel.style.pointerEvents = 'none';
                }
            }
        });

        // è®¡åˆ†éŸ³æ•ˆï¼ˆéè¯­éŸ³ï¼‰ï¼šéšåˆ†æ•°å¢é•¿çš„çŸ­ä¿ƒæç¤ºéŸ³ï¼Œä»…å— soundEnabled æ§åˆ¶
        let scoreCountSfxTimer = null;
        let scoreCountSfxStep = 0;

        function startScoreCountSfx() {
            if (globalGameInstance && !globalGameInstance.settings.soundEnabled) return;
            stopScoreCountSfx(false);
            scoreCountSfxStep = 0;
            const intervalMs = 60;
            scoreCountSfxTimer = setInterval(() => {
                try {
                    const base = 420;
                    const freq = base + Math.min(900, scoreCountSfxStep * 28);
                    scoreCountSfxStep++;
                    const osc = audioCtx.createOscillator();
                    osc.type = 'triangle';
                    const gain = audioCtx.createGain();
                    gain.gain.setValueAtTime(0.06, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.05);
                    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                    osc.connect(gain).connect(audioCtx.destination);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.05);
                } catch (e) {}
            }, intervalMs);
        }

        function stopScoreCountSfx(withFinalize) {
            if (scoreCountSfxTimer) {
                clearInterval(scoreCountSfxTimer);
                scoreCountSfxTimer = null;
            }
            if (!withFinalize) return;
            if (globalGameInstance && !globalGameInstance.settings.soundEnabled) return;
            try {
                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                gain.gain.setValueAtTime(0.08, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
                osc.connect(gain).connect(audioCtx.destination);
                osc.frequency.setValueAtTime(660, now);
                osc.frequency.linearRampToValueAtTime(770, now + 0.12);
                osc.start(now);
                osc.stop(now + 0.18);
            } catch(e) {}
        }

        // åˆ†æ•°éŸ³æ•ˆï¼šæ ¹æ®åˆ†æ•°å¤§å°æ’­æ”¾ä¸åŒçš„æ¿€åŠ±éŸ³æ•ˆ
        function playScoreSound(score) {
            if (globalGameInstance && !globalGameInstance.settings.soundEnabled) {
                return;
            }
            
            // æ ¹æ®åˆ†æ•°é€‰æ‹©éŸ³æ•ˆ
            let soundId = 'nice'; // é»˜è®¤éŸ³æ•ˆ
            
            if (score >= 1000) soundId = 'legendary';
            else if (score >= 800) soundId = 'unbelievable';
            else if (score >= 600) soundId = 'amazing';
            else if (score >= 400) soundId = 'incredible';
            else if (score >= 300) soundId = 'outstanding';
            else if (score >= 200) soundId = 'perfect';
            else if (score >= 150) soundId = 'wonderful';
            else if (score >= 100) soundId = 'fantastic';
            else if (score >= 80) soundId = 'awesome';
            else if (score >= 60) soundId = 'brilliant';
            else if (score >= 40) soundId = 'excellent';
            else if (score >= 30) soundId = 'great';
            else if (score >= 20) soundId = 'goodjob';
            else if (score >= 15) soundId = 'welldone';
            else if (score >= 10) soundId = 'sweet';
            else if (score >= 5) soundId = 'whoa';
            else if (score >= 3) soundId = 'wow';
            else soundId = 'cool';
            
            // æ’­æ”¾éŸ³æ•ˆ
            const target = voiceAudioMap[soundId];
            if (target) {
                try {
                    target.currentTime = 0;
                    target.play().catch(() => {});
                } catch (err) {
                    console.log('åˆ†æ•°éŸ³æ•ˆæ’­æ”¾å¤±è´¥:', err);
                }
            }
        }
        
        // æ§åˆ¶å°è°ƒè¯•æŒ‡ä»¤
        window.setScore = function(score) {
            if (typeof score !== 'number' || score < 0) {
                console.log('ç”¨æ³•: setScore(åˆ†æ•°) - ä¾‹å¦‚ setScore(1000)');
                return;
            }
            if (globalGameInstance) {
                globalGameInstance.score = score;
                globalGameInstance.updateScore();
                console.log('åˆ†æ•°å·²è®¾ç½®ä¸º:', score);
            } else {
                console.log('æ¸¸æˆæœªåˆå§‹åŒ–');
            }
        };
        
        window.addScore = function(points) {
            if (typeof points !== 'number') {
                console.log('ç”¨æ³•: addScore(åˆ†æ•°) - ä¾‹å¦‚ addScore(500)');
                return;
            }
            if (globalGameInstance) {
                globalGameInstance.score += points;
                globalGameInstance.updateScore();
                console.log('å·²å¢åŠ åˆ†æ•°:', points, 'å½“å‰åˆ†æ•°:', globalGameInstance.score);
            } else {
                console.log('æ¸¸æˆæœªåˆå§‹åŒ–');
            }
        };
        
        window.getScore = function() {
            if (globalGameInstance) {
                console.log('å½“å‰åˆ†æ•°:', globalGameInstance.score);
                return globalGameInstance.score;
            } else {
                console.log('æ¸¸æˆæœªåˆå§‹åŒ–');
                return 0;
            }
        };
        
        // æ³³é“è°ƒè¯•æŒ‡ä»¤
        window.getLaneInfo = function() {
            if (globalGameInstance) {
                const laneProgress = globalGameInstance.score;
                const loopCount = globalGameInstance.laneLoopEnabled ? Math.floor(laneProgress / globalGameInstance.laneLoopLength) : 0;
                const currentProgress = globalGameInstance.laneLoopEnabled ? (laneProgress % globalGameInstance.laneLoopLength) : laneProgress;
                
                console.log('=== æ³³é“ä¿¡æ¯ ===');
                console.log('å½“å‰åˆ†æ•°:', laneProgress);
                console.log('å¾ªç¯å¯ç”¨:', globalGameInstance.laneLoopEnabled);
                console.log('å¾ªç¯é•¿åº¦:', globalGameInstance.laneLoopLength);
                console.log('å¾ªç¯æ¬¡æ•°:', loopCount);
                console.log('å½“å‰è¿›åº¦:', currentProgress);
                console.log('æ³³é“èŠ‚ç‚¹:', globalGameInstance.laneNodes);
                
                // åˆ¤æ–­å½“å‰å¤„äºå“ªä¸ªæ³³é“æ®µ
                let currentSegment = 'æœªçŸ¥';
                if (currentProgress < globalGameInstance.laneNodes[0]) {
                    currentSegment = 'ç¬¬1æ®µ (TCRç­–ç•¥)';
                } else if (currentProgress >= globalGameInstance.laneNodes[0] && currentProgress < globalGameInstance.laneNodes[1]) {
                    currentSegment = 'ç¬¬2æ®µ (ç­–ç•¥2)';
                } else if (currentProgress >= globalGameInstance.laneNodes[1] && currentProgress < globalGameInstance.laneNodes[2]) {
                    currentSegment = 'ç¬¬3æ®µ (ç­–ç•¥1)';
                } else if (currentProgress >= globalGameInstance.laneNodes[2]) {
                    currentSegment = 'ç¬¬4æ®µ (å•å—åŒè‰²ç­–ç•¥)';
                }
                console.log('å½“å‰æ³³é“æ®µ:', currentSegment);
                
                return {
                    score: laneProgress,
                    loopCount: loopCount,
                    currentProgress: currentProgress,
                    currentSegment: currentSegment,
                    laneNodes: globalGameInstance.laneNodes
                };
            } else {
                console.log('æ¸¸æˆæœªåˆå§‹åŒ–');
                return null;
            }
        };
        
        window.testLaneLoop = function(targetScore) {
            if (typeof targetScore !== 'number' || targetScore < 0) {
                console.log('ç”¨æ³•: testLaneLoop(ç›®æ ‡åˆ†æ•°) - ä¾‹å¦‚ testLaneLoop(10000)');
                return;
            }
            if (globalGameInstance) {
                globalGameInstance.score = targetScore;
                globalGameInstance.updateScore();
                console.log(`åˆ†æ•°è®¾ç½®ä¸º ${targetScore}ï¼ŒæŸ¥çœ‹æ³³é“ä¿¡æ¯:`);
                getLaneInfo();
            } else {
                console.log('æ¸¸æˆæœªåˆå§‹åŒ–');
            }
        };
        
        // æ¸¸æˆå†…å¹¿å‘Šå’Œè´­ä¹°é›†æˆå‡½æ•°
        window.revivePlayer = function() {
            // å¤æ´»ç©å®¶é€»è¾‘
            console.log('ç©å®¶å¤æ´»');
            // è¿™é‡Œæ·»åŠ æ‚¨çš„å¤æ´»é€»è¾‘
        };
        
        window.addCoins = function(amount) {
            // æ·»åŠ é‡‘å¸é€»è¾‘
            if (!window.gameCoins) window.gameCoins = 0;
            window.gameCoins += amount;
            console.log(`è·å¾— ${amount} é‡‘å¸ï¼Œæ€»è®¡: ${window.gameCoins}`);
            // æ›´æ–°UIæ˜¾ç¤º
            const coinsDisplay = document.getElementById('coins-display');
            if (coinsDisplay) {
                coinsDisplay.textContent = window.gameCoins;
            }
        };
        
        window.giveHint = function() {
            // ç»™äºˆæç¤ºé€»è¾‘
            console.log('è·å¾—æç¤º');
            // è¿™é‡Œæ·»åŠ æ‚¨çš„æç¤ºé€»è¾‘
        };
        
        // æ¨ªå¹…å¹¿å‘Šæµ‹è¯•ä¸æ§åˆ¶ï¼ˆAdMob v1ï¼‰
        window.bannerConfig = {
            adUnitId: 'ca-app-pub-7061618651809737/4419786189',
            size: 'SMART_BANNER'
        };
        
        window.bannerCreate = async function(config) {
            if (typeof admob === 'undefined') throw new Error('AdMob æœªåŠ è½½');
            try {
                try { adDbg('è°ƒç”¨ banner.create ...'); } catch(_) {}
                const cfg = config || window.bannerConfig || {};
                const unitId = cfg.adUnitId;
                if (!unitId) throw new Error('missing adUnitId');
                if (window.__bannerAd && typeof window.__bannerAd.hide === 'function') {
                    try { await window.__bannerAd.hide(); } catch(_) {}
                }
                if (!admob.BannerAd) throw new Error('admob.BannerAd unavailable');
                const b = new admob.BannerAd({ adUnitId: unitId, position: 'bottom', offset: 0 });
                window.__bannerAd = b;
                try { await b.load(); } catch(_) {}
                try { adDbg('banner.create æˆåŠŸ(å®ä¾‹åŒ–)'); } catch(_) {}
                return b;
            } catch (e) {
                console.error('æ¨ªå¹…åˆ›å»ºå¤±è´¥:', e);
                try { adDbg('banner.create å¤±è´¥: ' + (e && (e.message||e.toString())), true); } catch(_) {}
                throw e;
            }
        };
        
        window.bannerShow = async function() {
            try {
                if (!window.__bannerAd) {
                    try { adDbg('banner.show è§¦å‘ï¼šå…ˆåˆ›å»º'); } catch(_) {}
                    await window.bannerCreate();
                }
                try { adDbg('è°ƒç”¨ banner.show ...'); } catch(_) {}
                await window.__bannerAd.show();
                try { adDbg('banner.show æˆåŠŸï¼Œæ˜¾ç¤ºä¸­'); } catch(_) {}
                var el = document.getElementById('admob-banner');
                if (el) el.style.display = 'none';
            } catch (e) {
                console.error('æ¨ªå¹…æ˜¾ç¤ºå¤±è´¥:', e);
                try { adDbg('banner.show å¤±è´¥: ' + (e && (e.message||e.toString())), true); } catch(_) {}
            }
        };
        
        window.bannerHide = function() {
            try {
                try { adDbg('è°ƒç”¨ banner.hide'); } catch(_) {}
                if (window.__bannerAd && typeof window.__bannerAd.hide === 'function') {
                    window.__bannerAd.hide();
                }
                var el = document.getElementById('admob-banner');
                if (el) el.style.display = 'none';
            } catch (e) {
                console.error('æ¨ªå¹…éšè—å¤±è´¥:', e);
            }
        };
        
        
        
        // æ¸¸æˆå¤±è´¥æ—¶æ˜¾ç¤ºæ¿€åŠ±è§†é¢‘é€‰é¡¹
        window.showReviveOption = function() {
            if (window.adManager && window.adManager.rewardedAd) {
                if (confirm('è§‚çœ‹å¹¿å‘Šå¤æ´»ï¼Ÿ')) {
                    window.adManager.offerRewardVideo('revive');
                }
            }
        };
        
        // æ‹¿èµ·å—æ—¶"å‘¼"çš„é£å£°
        
        // å¹¿å‘Šç³»ç»Ÿåˆå§‹åŒ– - å…¼å®¹"è„šæœ¬åœ¨devicereadyä¹‹åæ‰åŠ è½½"çš„æƒ…å†µ
        (function() {
            let inited = false;
            async function initAd() {
                if (inited) return;
                inited = true;
                try { adDbg('å¼€å§‹åˆå§‹åŒ–å¹¿å‘Šç³»ç»Ÿ...'); } catch(_) {}
                if (typeof admob === 'undefined') {
                    try { adDbg('AdMobæ’ä»¶æœªæ‰¾åˆ°ï¼', true); } catch(_) {}
                    return;
                }
                try {
                    // ä¸º start å¢åŠ è¶…æ—¶å…œåº•ï¼Œé¿å… Promise é•¿æ—¶é—´ä¸å›è°ƒ
                    const START_TIMEOUT_MS = 5000;
                    const started = await Promise.race([
                        (async () => { await admob.start(); return true; })(),
                        new Promise((_, reject) => setTimeout(() => reject(new Error('start-timeout')), START_TIMEOUT_MS))
                    ]);
                    if (started) {
                        try { adDbg('AdMobåˆå§‹åŒ–æˆåŠŸ'); } catch(_) {}
                    }
                    // æ”¹ä¸ºæŒ‰å†·å¯åŠ¨å»¶è¿Ÿå±•ç¤º
                    scheduleBannerShow();
                } catch (e) {
                    try { adDbg('å¹¿å‘Šåˆå§‹åŒ–/åˆ›å»ºå¤±è´¥: ' + (e && (e.message||e.toString())), true); } catch(_) {}
                    // å…œåº•ï¼šå³ä¾¿ start è¶…æ—¶ï¼Œä¹ŸæŒ‰å†·å¯åŠ¨å»¶è¿Ÿå†å°è¯•ä¸€æ¬¡
                    scheduleBannerShow();
                }
            }
            document.addEventListener('deviceready', requestATTrackingPermission, { once: true });
            // å¦‚æœæ­¤è„šæœ¬åœ¨ deviceready ä¹‹åæ‰æ³¨å…¥ï¼Œè¡¥å¿ä¸€æ¬¡
            if (window.cordova && window.cordova.platformId && document.readyState === 'complete') {
                setTimeout(requestATTrackingPermission, 0);
            }
        })();

        document.addEventListener('deviceready', function () {
            if (window.StatusBar && typeof StatusBar.overlaysWebView === 'function') {
                try { StatusBar.overlaysWebView(true); } catch (e) {}
            }
            if (window.StatusBar && typeof StatusBar.styleLightContent === 'function') {
                try { StatusBar.styleLightContent(); } catch (e) {}
            }
        }, { once: true });
        // å¦‚æœæ­¤è„šæœ¬åœ¨ deviceready ä¹‹åæ‰æ³¨å…¥ï¼Œè¡¥å¿ä¸€æ¬¡
    </script>
    
    <!-- å¹¿å‘Šè„šæœ¬ï¼šå·²å†…è”åˆå§‹åŒ–ï¼Œç§»é™¤å¤–éƒ¨è„šæœ¬ä»¥é¿å…å†²çªï¼ˆadmob v1ï¼‰ -->
    
    <!-- AdMobæ¨ªå¹…å¹¿å‘Š -->
    <div id="admob-banner" style="position: fixed; bottom: 0; left: 0; width: 100%; height: 50px; background: #f0f0f0; z-index: 1000; display: none;"></div>
    
    
</body>
</html>