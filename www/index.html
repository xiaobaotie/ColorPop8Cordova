<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Block Blast</title>
    <script type="text/javascript" src="cordova.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            user-select: none;
            touch-action: none; /* 防止触摸滚动 */
            overflow-x: hidden;
        }

        .container {
            display: flex;
            max-width: 1200px;
            margin: 0 auto;
            gap: 30px;
            /* 让内容在视口内垂直居中，上下多余空间对称分配（扣除 body 的上下 padding 各20） */
            min-height: calc(100vh - 40px);
            align-items: center;
        }

        .developer-panel {
            width: 250px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            height: fit-content;
        }

        .game-panel {
            flex: 1;
            text-align: center;
        }

        h1 {
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            font-size: 24px;
        }

        .score {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            color: white;
        }

        .combo {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 15px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            color: white;
        }

        .settings {
            margin-bottom: 20px;
        }

        .settings label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .settings select {
            width: 100%;
            padding: 8px;
            border-radius: 8px;
            border: none;
            background: rgba(255,255,255,0.2);
            color: white;
            margin-bottom: 15px;
        }

        .settings select option {
            background: #333;
            color: white;
        }

        .game-board {
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 20px;
            margin: 0 auto;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 10px;
            margin: 0 auto 30px;
            max-width: 400px;
        }

        .cell {
            aspect-ratio: 1;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            transition: all 0.2s ease;
            border: 1px solid rgba(255,255,255,0.2);
            position: relative;
            overflow: hidden;
        }

        .cell.filled {
            /* 盘面：去除亮边，只保留柔和的内暗边与内辉 */
            box-shadow:
                inset 0 -1px 2px rgba(0,0,0,0.18),
                inset 0 0 2px rgba(0,0,0,0.12);
            border-color: rgba(255,255,255,0.18);
        }
        .cell.filled::before, .cell.filled::after { content: none !important; }

        .cell.color-1 { background: linear-gradient(45deg, #ff6b6b, #ee5a24); }
        .cell.color-2 { background: linear-gradient(45deg, #4ecdc4, #44a08d); }
        .cell.color-3 { background: linear-gradient(45deg, #a8e6cf, #56ab2f); }
        .cell.color-4 { background: linear-gradient(45deg, #ffd93d, #ff9f40); }
        .cell.color-5 { background: linear-gradient(45deg, #b19cd9, #8e44ad); }
        .cell.color-6 { background: linear-gradient(45deg, #fd79a8, #e84393); }
        .cell.color-7 { background: linear-gradient(45deg, #74b9ff, #0984e3); }
        .cell.color-8 { background: linear-gradient(45deg, #fd79a8, #fdcb6e); }

        .cell.highlight {
            /* 不再使用原高亮 */
        }
        .cell.projection {
            /* 只做缩放，透明度用js控制 */
            transform: scale(1.0);
        }

        .cell.invalid {
            background: rgba(255,0,0,0.3);
        }

        .cell.pre-clear {
            z-index: 10;
        }
        .cell.pre-clear.pre-clear-color-1 { box-shadow: 0 0 0 3px #ff6b6b, 0 0 16px 6px #ff6b6b88; border-color: #ff6b6b !important; }
        .cell.pre-clear.pre-clear-color-2 { box-shadow: 0 0 0 3px #4ecdc4, 0 0 16px 6px #4ecdc488; border-color: #4ecdc4 !important; }
        .cell.pre-clear.pre-clear-color-3 { box-shadow: 0 0 0 3px #56ab2f, 0 0 16px 6px #56ab2f88; border-color: #56ab2f !important; }
        .cell.pre-clear.pre-clear-color-4 { box-shadow: 0 0 0 3px #ffd93d, 0 0 16px 6px #ffd93d88; border-color: #ffd93d !important; }
        .cell.pre-clear.pre-clear-color-5 { box-shadow: 0 0 0 3px #8e44ad, 0 0 16px 6px #8e44ad88; border-color: #8e44ad !important; }
        .cell.pre-clear.pre-clear-color-6 { box-shadow: 0 0 0 3px #e84393, 0 0 16px 6px #e8439388; border-color: #e84393 !important; }
        .cell.pre-clear.pre-clear-color-7 { box-shadow: 0 0 0 3px #0984e3, 0 0 16px 6px #0984e388; border-color: #0984e3 !important; }
        .cell.pre-clear.pre-clear-color-8 { box-shadow: 0 0 0 3px #fdcb6e, 0 0 16px 6px #fdcb6e88; border-color: #fdcb6e !important; }

        .shapes-container {
            display: flex;
            justify-content: center; /* 与棋盘居中对齐 */
            flex-wrap: nowrap;
            margin-left: 0; /* 移除固定偏移，避免左右不对齐 */
            width: 100%; /* 让容器占满棋盘宽度以便居中 */
        }
        .shape-slot {
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        /* 增大中间slot间隔 */
        .shape-slot:not(:last-child) {
            margin-right: 30px;
        }
        .shape-slot:nth-child(2) {
            margin-right: 60px;
        }

        .shape {
            /* 完全去除背板和边界效果 */
            background: none;
            border-radius: 10px;
            padding: 15px;
            cursor: grab;
            transition: all 0.3s ease;
            border: none;
            /* 临时关闭任何投影效果 */
            box-shadow: none;
        }

        /* 关闭悬停反馈：后续另做设计，这里保持静置外观一致 */
        .shape:hover { box-shadow: none; transform: none; }

        .shape.dragging {
            cursor: grabbing;
            /* 避免缩放导致中心点计算偏移 */
            transform: none;
            /* 避免内边距导致中心点计算偏移 */
            padding: 0;
            z-index: 1000;
            position: fixed;
            pointer-events: none;
            transition: none;
            /* 关闭拖拽投影 */
            box-shadow: none;
        }
        /* 拖拽中：仅保留内凹/凸起的内阴影，不加任何外投影 */
        .shape.dragging .shape-cell.filled {
            /* 拖拽中：与盘面一致的"无亮边"内阴影；无任何外影 */
            box-shadow:
                inset 0 -1px 2px rgba(0,0,0,0.18),
                inset 0 0 2px rgba(0,0,0,0.12) !important;
            border-color: rgba(255,255,255,0.12) !important;
        }

        /* 阴影模式开关（仅作用于出块区小格 .shape-cell） */
        /* hard：默认在 .shape-cell.filled 上定义，无需额外类 */
        body.shadow-soft .shape-cell.filled {
            /* 柔光模式：与盘面一致的"无亮边"凸起 + 柔光外影 */
            box-shadow:
                inset 0 -1px 2px rgba(0,0,0,0.18),
                inset 0 0 2px rgba(0,0,0,0.12),
                0 16px 36px rgba(0,0,0,0.24),
                0 32px 72px rgba(0,0,0,0.15);
            border-color: rgba(255,255,255,0.18);
        }
        body.shadow-none .shape-cell.filled { box-shadow: none !important; }

        .shape-grid {
            display: grid;
            gap: 1px; /* 减小单元间距，使阴影轮廓更聚合 */
        }

        .shape-cell {
            width: 25px;
            height: 25px;
            border-radius: 3px;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        .shape-cell.filled {
            /* 出块区：与盘面一致的"无亮边"凸起 + 硬边外影 */
            box-shadow:
                inset 0 -1px 2px rgba(0,0,0,0.18),
                inset 0 0 2px rgba(0,0,0,0.12),
                6px 6px 0 rgba(0,0,0,0.18);
            border: 1px solid rgba(255,255,255,0.18);
        }
        .shape-cell.filled::before, .shape-cell.filled::after { content: none !important; }

        .shape-cell.color-1 { background: linear-gradient(45deg, #ff6b6b, #ee5a24); }
        .shape-cell.color-2 { background: linear-gradient(45deg, #4ecdc4, #44a08d); }
        .shape-cell.color-3 { background: linear-gradient(45deg, #a8e6cf, #56ab2f); }
        .shape-cell.color-4 { background: linear-gradient(45deg, #ffd93d, #ff9f40); }
        .shape-cell.color-5 { background: linear-gradient(45deg, #b19cd9, #8e44ad); }
        .shape-cell.color-6 { background: linear-gradient(45deg, #fd79a8, #e84393); }
        .shape-cell.color-7 { background: linear-gradient(45deg, #74b9ff, #0984e3); }
        .shape-cell.color-8 { background: linear-gradient(45deg, #fd79a8, #fdcb6e); }

        .shape-cell.empty {
            background: transparent;
        }

        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .game-over-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            position: relative;
        }
        /* 新纪录样式 */
        .game-over-content.best-record #game-over-title {
            color: #FFD700;
            font-weight: 900;
            font-size: 40px; /* 保持与普通结束相近的比例 */
            letter-spacing: 1px;
            text-shadow: 0 0 12px rgba(255,215,0,0.7), 2px 2px 6px rgba(0,0,0,0.5);
        }
        .game-over-content.best-record #final-score {
            color: #FFD700;
            font-size: 54px; /* 与默认最终分数一致，避免撑大弹窗 */
        }
        /* 强化读数的可读性 */
        .game-over-content #final-score {
            display: block;
            font-size: 54px;
            line-height: 1.1;
            margin-top: 6px;
            font-weight: 800;
        }
        .game-over-content #high-score {
            display: block;
            font-size: 40px;
            line-height: 1.1;
            margin-top: 6px;
            font-weight: 800;
        }
        .game-over-content #final-score-label,
        .game-over-content #high-score-label {
            font-size: 16px;
            opacity: 0.9;
        }
        
        .game-over-content #high-score {
            color: #FFD700;
            font-weight: bold;
            font-size: 14px;
        }
        
        .settings-icon {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            width: 40px;
            height: 40px;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }
        
        .settings-icon:hover {
            transform: rotate(90deg);
        }

        .restart-btn {
            background: linear-gradient(45deg, #56ab2f, #a8e6cf);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }



        .restart-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
        }
        
        .settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2100;
        }
        
        .settings-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            min-width: 280px;
        }
        
        .settings-content h3 {
            margin: 0 0 25px 0;
            color: white;
            font-size: 24px;
        }
        
        .setting-item {
            margin: 20px 0;
            text-align: left;
        }
        
        .setting-item label {
            display: flex;
            align-items: center;
            gap: 15px;
            cursor: pointer;
            font-size: 18px;
            color: white;
            font-weight: 500;
        }
        
        .setting-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #4CAF50;
        }
        
        .settings-content button {
            background: linear-gradient(45deg, #56ab2f, #a8e6cf);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 20px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 25px;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .settings-content button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
        }

        .hidden {
            display: none;
        }

        @keyframes clearAnimation {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); background: #ffd700; }
            100% { transform: scale(1); }
        }
        @keyframes clearAnimation-1 { 0%{transform:scale(1);} 50%{transform:scale(1.2);background:#ff6b6b;} 100%{transform:scale(1);} }
        @keyframes clearAnimation-2 { 0%{transform:scale(1);} 50%{transform:scale(1.2);background:#4ecdc4;} 100%{transform:scale(1);} }
        @keyframes clearAnimation-3 { 0%{transform:scale(1);} 50%{transform:scale(1.2);background:#56ab2f;} 100%{transform:scale(1);} }
        @keyframes clearAnimation-4 { 0%{transform:scale(1);} 50%{transform:scale(1.2);background:#ffd93d;} 100%{transform:scale(1);} }
        @keyframes clearAnimation-5 { 0%{transform:scale(1);} 50%{transform:scale(1.2);background:#8e44ad;} 100%{transform:scale(1);} }
        @keyframes clearAnimation-6 { 0%{transform:scale(1);} 50%{transform:scale(1.2);background:#e84393;} 100%{transform:scale(1);} }
        @keyframes clearAnimation-7 { 0%{transform:scale(1);} 50%{transform:scale(1.2);background:#0984e3;} 100%{transform:scale(1);} }
        @keyframes clearAnimation-8 { 0%{transform:scale(1);} 50%{transform:scale(1.2);background:#fdcb6e;} 100%{transform:scale(1);} }

        .clearing.clearing-color-1 { animation: clearAnimation-1 0.5s ease; }
        .clearing.clearing-color-2 { animation: clearAnimation-2 0.5s ease; }
        .clearing.clearing-color-3 { animation: clearAnimation-3 0.5s ease; }
        .clearing.clearing-color-4 { animation: clearAnimation-4 0.5s ease; }
        .clearing.clearing-color-5 { animation: clearAnimation-5 0.5s ease; }
        .clearing.clearing-color-6 { animation: clearAnimation-6 0.5s ease; }
        .clearing.clearing-color-7 { animation: clearAnimation-7 0.5s ease; }
        .clearing.clearing-color-8 { animation: clearAnimation-8 0.5s ease; }

        .combo-bonus {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 1500;
            animation: comboFade 2s ease-out forwards;
        }

        @keyframes comboFade {
            0% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1.2);
            }
            50% { 
                opacity: 1; 
                transform: translate(-50%, -80%) scale(1);
            }
            100% { 
                opacity: 0; 
                transform: translate(-50%, -100%) scale(0.8);
            }
        }
        
        .placement-score {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            font-weight: bold;
            color: #00ff00;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 1400;
            animation: placementFade 1.5s ease-out forwards;
        }
        
        @keyframes placementFade {
            0% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1);
            }
            50% { 
                opacity: 1; 
                transform: translate(-50%, -60%) scale(1.1);
            }
            100% { 
                opacity: 0; 
                transform: translate(-50%, -70%) scale(0.9);
            }
        }
        
        .elimination-score {
            position: fixed;
            font-size: 32px;
            font-weight: bold;
            color: var(--elim-color, #ff6b6b);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 1600;
            animation: eliminationFade 0.6s ease-out forwards;
        }
        /* 仅放置得分（无消除时） */
        .placement-score {
            position: fixed;
            font-size: 18px;
            font-weight: bold;
            color: rgba(255,255,255,0.9);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.6);
            pointer-events: none;
            z-index: 1500;
            animation: placementScoreFade 0.5s ease-out forwards;
        }
        @keyframes placementScoreFade {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -60%) scale(0.9); }
        }
        
        @keyframes eliminationFade {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(2);
            }
            20% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2);
            }
            90% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
        }
        
        .combo-effect {
            position: absolute;
            top: 50%;
            left: 50%;
            font-size: 48px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8), 0 0 20px rgba(255,215,0,0.5);
            pointer-events: none;
            z-index: 2000;
            animation: comboEffect 1.2s ease-out forwards;
        }
        
        @keyframes comboEffect {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.3);
                color: #ff6b6b;
            }
            15% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.8);
                color: #ffd700;
            }
            25% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.3);
                color: #ffd700;
            }
            70% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.3);
                color: #ffd700;
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
                color: #ffd700;
            }
        }
        
        @keyframes screenShake {
            0%, 100% { transform: translateX(0); }
            10% { transform: translateX(-5px); }
            20% { transform: translateX(5px); }
            30% { transform: translateX(-5px); }
            40% { transform: translateX(5px); }
            50% { transform: translateX(-3px); }
            60% { transform: translateX(3px); }
            70% { transform: translateX(-2px); }
            80% { transform: translateX(2px); }
            90% { transform: translateX(-1px); }
        }
        
        @keyframes particleExplosion {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--x, 100px), var(--y, -100px)) scale(0);
                opacity: 0;
            }
        }
        
        /* 连击文字动画 */
        @keyframes comboText {
            0% {
                transform: translate(-50%, -50%) scale(0.3);
                opacity: 0;
            }
            15% {
                transform: translate(-50%, -50%) scale(1.4);
                opacity: 1;
            }
            70% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(1.6);
                opacity: 0;
            }
        }
        @media (max-width: 600px) {
            html, body {
                height: 100vh;
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }
            .game-panel {
                min-height: 100vh;
                width: 100vw;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: flex-start;
                padding: 0;
                padding-top: 12vh;
                padding-bottom: 4vh;
            }
            .score {
                width: 95vw;
                max-width: 95vw;
                text-align: center;
                font-size: 11vw;
                margin: 0 auto 4vw auto;
                padding: 0;
            }
            .game-board {
                width: 95vw;
                max-width: 95vw;
                margin: 0 auto 10vw auto;
                padding: 0;
                background: none !important;
                box-shadow: none !important;
                border-radius: 0 !important;
                box-sizing: border-box;
            }
            .grid {
                width: 100%;
                max-width: 100%;
                aspect-ratio: 1/1;
                margin: 0 auto;
                box-sizing: border-box;
            }
            .shapes-container {
                width: 95vw;
                max-width: 95vw;
                margin: 6vw auto 6vw auto;
                display: flex;
                justify-content: center;
                flex-wrap: wrap;
            }
            .shape-slot {
                width: 18vw;
                height: 18vw;
                max-width: 80px;
                max-height: 80px;
                margin-right: 3vw;
            }
            .shape-slot:last-child {
                margin-right: 0;
            }
        }
    </style>
</head>
<body>
    <audio id="eliminate-audio" src="https://cdn.pixabay.com/audio/2022/07/26/audio_124bfae5c7.mp3" preload="auto"></audio>
    <audio id="voice-nice" src="audio/nice.mp3" preload="auto"></audio>
    <audio id="voice-amazing" src="audio/amazing.mp3" preload="auto"></audio>
    <div class="container">
        <div class="developer-panel" id="developer-panel">
            <h1>🧩 Block Blast</h1>
            
            <div class="settings">
                <label>颜色种类：</label>
                <select id="color-count-select">
                    <option value="3" selected>3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                    <option value="8">8</option>
                </select>
                
                <label>每块最多颜色数：</label>
                <select id="max-shape-color-select">
                    <option value="1">1</option>
                    <option value="2" selected>2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                </select>
            </div>
            
            <div class="combo">
                <span id="combo-text">Combo</span>: <span id="combo">x1.0</span>
            </div>
        </div>
        
        <div class="game-panel">
            <div class="score">
                <span id="score">0</span>
            </div>
            
            <div class="game-board">
                <div class="grid" id="grid"></div>
                <div class="shapes-container" id="shapes-container">
                    <div class="shape-slot" id="shape-slot-0"></div>
                    <div class="shape-slot" id="shape-slot-1"></div>
                    <div class="shape-slot" id="shape-slot-2"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="game-over hidden" id="game-over">
        <div class="game-over-content">
            <button class="settings-icon" onclick="showSettings()">⚙️</button>
            <h2 id="game-over-title">Game Over</h2>
            <p><span id="final-score-label">Score</span><br/><span id="final-score">0</span></p>
            <p style="margin-top: 14px;"><span id="high-score-label">Best Score</span><br/><span id="high-score">0</span></p>
            <button id="restart-btn" class="restart-btn" onclick="restartGame()">Restart</button>
        </div>
    </div>
    
            <div id="settings-modal" class="settings-modal hidden">
            <div class="settings-content">
                <h3 id="settings-title">Settings</h3>
                <div class="setting-item">
                    <label>
                        <input type="checkbox" id="sound-toggle" checked>
                        <span id="sound-label">Sound</span>
                    </label>
                </div>
                <div class="setting-item">
                    <label>
                        <input type="checkbox" id="vibration-toggle">
                        <span id="vibration-label">Vibration</span>
                    </label>
                </div>
                <div class="setting-item">
                    <label>
                        <input type="checkbox" id="voice-toggle" checked>
                        <span id="voice-label">Voice</span>
                    </label>
                </div>
                <div class="setting-item">
                    <label>
                        <span id="language-label">Language</span>
                        <select id="language-select">
                            <option value="zh">中文</option>
                            <option value="en">English</option>
                        </select>
                    </label>
                </div>
                <div class="setting-item">
                    <a id="privacy-link" href="privacy-policy.html">Privacy Policy</a>
                </div>
                <button onclick="closeSettings()">OK</button>
        </div>
    </div>

    <script>
        // ATT 权限请求（仅 iOS 生效）
        function requestATTrackingPermission() {
            // 检查是否在 iOS 平台
            if (window.device && window.device.platform === 'iOS') {
                // 检查 iOS 版本是否支持 ATT
                if (window.device.version && parseFloat(window.device.version) >= 14.5) {
                    // 请求 ATT 权限
                    if (typeof window.requestTrackingPermission === 'function') {
                        window.requestTrackingPermission().then(function(status) {
                            console.log('ATT Permission Status:', status);
                            // 权限请求完成后初始化 AdMob
                            initAd();
                        }).catch(function(error) {
                            console.log('ATT Permission Error:', error);
                            // 即使失败也初始化 AdMob
                            initAd();
                        });
                    } else {
                        // 如果不支持 ATT，直接初始化 AdMob
                        initAd();
                    }
                } else {
                    // iOS 版本太低，直接初始化 AdMob
                    initAd();
                }
            } else {
                // 非 iOS 平台，直接初始化 AdMob
                initAd();
            }
        }

        // 轻量级广告调试叠层（无需 logcat）。发布前可将 AD_DEBUG_ENABLED 设为 false。
        const AD_DEBUG_ENABLED = false;
        function adDbg(message, isError) {
            if (!AD_DEBUG_ENABLED) return;
            try {
                let el = document.getElementById('ad-debug-overlay');
                if (!el) {
                    el = document.createElement('div');
                    el.id = 'ad-debug-overlay';
                    el.style.cssText = [
                        'position:fixed','left:8px','right:8px','bottom:60px','max-height:40vh','overflow:auto',
                        'background:rgba(0,0,0,0.6)','color:#c8f7c5','font:12px/1.4 monospace','padding:6px 8px',
                        'border-radius:6px','z-index:3000','box-shadow:0 2px 8px rgba(0,0,0,0.4)'
                    ].join(';');
                    document.body.appendChild(el);
                }
                const line = document.createElement('div');
                line.textContent = `${new Date().toLocaleTimeString()}  ${message}`;
                if (isError) line.style.color = '#ff6b6b';
                el.appendChild(line);
                // 限制行数
                while (el.children.length > 80) el.removeChild(el.firstChild);
            } catch(_) {}
        }
        window.__adDbg = adDbg;
        // 简单曝光控制：冷启动延迟（毫秒）。可通过 window.CP8_BANNER_DELAY_MS 覆盖。
        const BANNER_DELAY_MS = (typeof window.CP8_BANNER_DELAY_MS === 'number' && window.CP8_BANNER_DELAY_MS >= 0)
            ? window.CP8_BANNER_DELAY_MS
            : 90000;
        function scheduleBannerShow() {
            try { adDbg('已计划在 ' + Math.round(BANNER_DELAY_MS/1000) + ' 秒后展示横幅'); } catch(_) {}
            setTimeout(() => {
                try { adDbg('冷启动延迟到期，尝试创建并显示横幅...'); } catch(_) {}
                window.bannerShow();
            }, BANNER_DELAY_MS);
        }
        // 微信小程序适配开关：true 开启小程序适配（强制中文、关闭英文激励词与配音）
        const WX_MINIPROGRAM_MODE = false;
        // 拖拽时小格的像素宽高（可自行调整）
        // const DRAG_CELL_SIZE = 42; // 已删除，改用动态尺寸
        let displayScore = 0;
        // 可插拔：出块覆盖钩子（外部可修改）。enabled: 是否启用；position: 'before' | 'after'
        window.CP8_HOOK = window.CP8_HOOK || { enabled: false, position: 'before' };
        // 自定义生成函数：入参为 game 实例；返回 null/undefined 跳过；
        // 覆盖时返回形如 [{ pattern: number[][], colors: number[][] }, ...] 的数组（取前3个）。
        window.CP8_generateShapes = window.CP8_generateShapes || function(game){ return null; };
        let scoreAnimationFrame = null;
        // 全局唯一音频上下文
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        // 语音激励映射（弱→强），阈值为"本次消除块数"
        const VOICE_CUES = [
            { id: 'cool', threshold: 12 },
            { id: 'wow', threshold: 13 },
            { id: 'whoa', threshold: 14 },
            { id: 'nice', threshold: 15 },
            { id: 'great', threshold: 16 },
            { id: 'goodjob', threshold: 17 },
            { id: 'welldone', threshold: 18 },
            { id: 'sweet', threshold: 19 },
            { id: 'excellent', threshold: 20 },
            { id: 'brilliant', threshold: 21 },
            { id: 'awesome', threshold: 22 },
            { id: 'fantastic', threshold: 23 },
            { id: 'wonderful', threshold: 24 },
            { id: 'perfect', threshold: 25 },
            { id: 'outstanding', threshold: 26 },
            { id: 'incredible', threshold: 27 },
            { id: 'amazing', threshold: 28 },
            { id: 'unbelievable', threshold: 30 },
            { id: 'legendary', threshold: 32 },
            { id: 'boom', threshold: 34 }
        ];
        let voiceAudioMap = {};
        let voiceInitialized = false;
        let lastVoicePlayTs = 0;
        const VOICE_COOLDOWN_MS = 900;
        
        // =====================
        // 测试节点（最高优先级可选）
        // - TEST_NODE_PRE_ENABLED: 在原逻辑之前调用 testNodePre，若返回形状则直接使用并跳过原逻辑
        // - TEST_NODE_POST_ENABLED: 在原逻辑生成后调用 testNodePost，若返回形状则覆盖原逻辑结果
        // - 回调需返回形如 [{pattern:number[][], colors:number[][]}, ...] 的数组（最多3个）
        // - 默认均为关闭，由你按需切换
        // =====================
        const TEST_NODE_PRE_ENABLED = false;
        const TEST_NODE_POST_ENABLED = false;

        function testNodePre(gameInstance) {
            // 返回 null 表示不接管（走原逻辑）
            return null;
        }

        function testNodePost(gameInstance, generatedShapes) {
            // 返回 null 表示不覆盖；返回新数组则覆盖原逻辑的 currentShapes
            return null;
        }

        // 可选：前置钩子实现（默认不启用）。当前版本不包含任何策略，始终返回 null（不接管）。
        window.CP8_generateShapes = function(game) {
            return null;
        };
        // 单一真源：颜色映射（编号 -> 渐变两端颜色）
        const COLOR_STYLES = {
            1: ['#ff6b6b', '#ee5a24'],
            2: ['#4ecdc4', '#44a08d'],
            3: ['#a8e6cf', '#56ab2f'],
            4: ['#ffd93d', '#ff9f40'],
            5: ['#b19cd9', '#8e44ad'],
            6: ['#fd79a8', '#e84393'],
            7: ['#74b9ff', '#0984e3'],
            8: ['#fd79a8', '#fdcb6e']
        };
        // 计算文本用的主色：挑选渐变中更亮的一端
        function getLuminance(hex) {
            try {
                const m = /^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i.exec(hex);
                if (!m) return 0;
                const r = parseInt(m[1], 16) / 255;
                const g = parseInt(m[2], 16) / 255;
                const b = parseInt(m[3], 16) / 255;
                const srgb = [r, g, b].map(v => (v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4)));
                return 0.2126 * srgb[0] + 0.7152 * srgb[1] + 0.0722 * srgb[2];
            } catch (_) { return 0; }
        }
        function pickTextPrimaryColor(pair) {
            if (!pair || !pair.length) return '#ffffff';
            if (pair.length === 1) return pair[0];
            const [c1, c2] = pair;
            return getLuminance(c1) >= getLuminance(c2) ? c1 : c2;
        }
        // 由 JS 注入覆盖色块样式，保证 CSS 与动效一致
        function initDynamicColorStyles() {
            try {
                const styleElId = 'dynamic-color-styles';
                let styleEl = document.getElementById(styleElId);
                if (!styleEl) {
                    styleEl = document.createElement('style');
                    styleEl.id = styleElId;
                    document.head.appendChild(styleEl);
                }
                let css = '';
                Object.keys(COLOR_STYLES).forEach(k => {
                    const [c1, c2] = COLOR_STYLES[k];
                    const gradient = `linear-gradient(45deg, ${c1}, ${c2})`;
                    css += `.cell.color-${k} { background: ${gradient}; }\n`;
                    css += `.shape-cell.color-${k} { background: ${gradient}; }\n`;
                });
                styleEl.textContent = css;
            } catch (_) {}
        }
        function initVoiceAudios() {
            if (voiceInitialized) return;
            VOICE_CUES.forEach(({ id }) => {
                const elId = `voice-${id}`;
                let el = document.getElementById(elId);
                if (!el) {
                    el = document.createElement('audio');
                    el.id = elId;
                    el.preload = 'auto';
                    el.src = `audio/${id}.mp3`;
                    document.body.appendChild(el);
                }
                voiceAudioMap[id] = el;
            });
            // 已有的 nice/amazing 标签也纳入映射（若存在）
            const existingNice = document.getElementById('voice-nice');
            const existingAmazing = document.getElementById('voice-amazing');
            if (existingNice) voiceAudioMap['nice'] = existingNice;
            if (existingAmazing) voiceAudioMap['amazing'] = existingAmazing;
            voiceInitialized = true;
        }
        // 放块音效生成函数
        function playPlaceBlockSound() {
            // 白噪声+低通滤波+包络，模拟木块落地声
            const duration = 0.07 + Math.random() * 0.02; // 0.07~0.09秒
            const volume = 0.6 + (Math.random() - 0.5) * 0.03; // 0.115~0.145
            const bufferSize = audioCtx.sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                // 白噪声，尾部快速衰减
                data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2);
            }
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            // 低通滤波
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(400 + Math.random() * 80, audioCtx.currentTime); // 400~480Hz
            // 包络
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(volume, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + duration);
            noise.connect(filter).connect(gain).connect(audioCtx.destination);
            noise.start();
            noise.stop(audioCtx.currentTime + duration);
            noise.onended = () => {
                noise.disconnect();
                filter.disconnect();
                gain.disconnect();
            };
        }
        // 拿起块时"呼"的风声
        function playPickupWhoosh() {
            if (globalGameInstance && !globalGameInstance.settings.soundEnabled) {
                return;
            }
            const duration = 0.12 + Math.random() * 0.08; // 120~200ms 短促
            const startTime = audioCtx.currentTime;
            const bufferSize = Math.floor(audioCtx.sampleRate * duration);
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            // 白噪声基础，微弱尾部
            for (let i = 0; i < bufferSize; i++) {
                const t = i / audioCtx.sampleRate;
                const env = Math.pow(1 - t / duration, 2); // 自然衰减
                data[i] = (Math.random() * 2 - 1) * env * 0.6; // 原噪声幅度（后面还有增益包络）
            }
            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            // 带通滤波，频率轻微上滑形成"呼"质感
            const bandpass = audioCtx.createBiquadFilter();
            bandpass.type = 'bandpass';
            bandpass.Q.setValueAtTime(0.9 + Math.random() * 0.6, startTime);
            bandpass.frequency.setValueAtTime(600, startTime);
            bandpass.frequency.linearRampToValueAtTime(1800, startTime + duration);
            // 额外高通，剔除低频轰鸣
            const highpass = audioCtx.createBiquadFilter();
            highpass.type = 'highpass';
            highpass.frequency.setValueAtTime(220, startTime);
            // 音量包络
            const gain = audioCtx.createGain();
            const peak = 0.12 + Math.random() * 0.05; // 0.12~0.17
            gain.gain.setValueAtTime(0, startTime);
            gain.gain.linearRampToValueAtTime(peak, startTime + 0.03); // 快速起
            gain.gain.linearRampToValueAtTime(0.02, startTime + duration * 0.7); // 快速掉头
            gain.gain.linearRampToValueAtTime(0, startTime + duration);
            source.connect(bandpass).connect(highpass).connect(gain).connect(audioCtx.destination);
            source.start(startTime);
            source.stop(startTime + duration);
            source.onended = () => {
                try {
                    source.disconnect();
                    bandpass.disconnect();
                    highpass.disconnect();
                    gain.disconnect();
                } catch (_) {}
            };
        }
        // 全局游戏实例引用（用于设置检查）
        let globalGameInstance = null;
        
        // "duang——"音效
        function playEliminateSound(count, combo) {
            // 检查音效设置
            if (globalGameInstance && !globalGameInstance.settings.soundEnabled) {
                return;
            }
            // 你可以在这里用count和combo调整音效频率
            const freq = 600+Math.min(((Math.max(0,((count-8)^0.1)*20))+0*combo),1400); // 你可以用count和combo自定义
            // 1. 起始冲击：高频triangle波+白噪声
            /*const impactOsc = audioCtx.createOscillator();
            const impactGain = audioCtx.createGain();
            impactOsc.type = 'triangle';
            impactOsc.frequency.setValueAtTime(700, audioCtx.currentTime);
            impactGain.gain.setValueAtTime(0.22, audioCtx.currentTime);
            impactGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.05);
            impactOsc.connect(impactGain).connect(audioCtx.destination);
            impactOsc.start(audioCtx.currentTime);
            impactOsc.stop(audioCtx.currentTime + 0.05);
            // 白噪声冲击
            //const bufferSize = audioCtx.sampleRate * 0.05;
            /*const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2);
            }
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const noiseGain = audioCtx.createGain();
            noiseGain.gain.setValueAtTime(0.18, audioCtx.currentTime);
            noiseGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.05);
            noise.connect(noiseGain).connect(audioCtx.destination);
            noise.start(audioCtx.currentTime);
            noise.stop(audioCtx.currentTime + 0.05);*/
            // 2. 拖尾：triangle波频率下滑
            const tailOsc = audioCtx.createOscillator();
            const tailGain = audioCtx.createGain();
            tailOsc.type = 'triangle';
            tailOsc.frequency.setValueAtTime(freq, audioCtx.currentTime + 0.05);
            tailOsc.frequency.linearRampToValueAtTime(freq, audioCtx.currentTime + 0.30+Math.max(0,((count-8)^0.05)*0.1));
            // 渐入 + 渐出
            tailGain.gain.setValueAtTime(0, audioCtx.currentTime + 0.04); // 从0开始
            tailGain.gain.linearRampToValueAtTime(0.13, audioCtx.currentTime + 0.05); // 渐入到0.13
            tailGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.30+Math.max(0,((count-8)^0.05)*0.1));
            tailOsc.connect(tailGain).connect(audioCtx.destination);
            tailOsc.start(audioCtx.currentTime + 0.05);
            tailOsc.stop(audioCtx.currentTime + 0.30+Math.max(0,((count-8)^0.05)*0.1));
            tailOsc.onended = () => {
                tailOsc.disconnect();
                tailGain.disconnect();
            };
        }
        // 存档管理类
        class SaveManager {
            static SAVE_KEY = 'blockBlastSave';
            
            // 保存游戏
            static saveGame(gameInstance) {
                try {
                    const saveData = {
                        grid: gameInstance.grid,
                        score: gameInstance.score,
                        comboMultiplier: gameInstance.comboMultiplier,
                        comboCount: gameInstance.comboCount,
                        lastRoundEliminated: gameInstance.lastRoundEliminated,
                        thisRoundEliminated: gameInstance.thisRoundEliminated,
                        blocksUsedInRound: gameInstance.blocksUsedInRound,
                        shapeId: gameInstance.shapeId,
                        currentShapes: gameInstance.currentShapes,
                        colors: gameInstance.colors,
                        maxShapeColors: gameInstance.maxShapeColors,
                        activeColors: gameInstance.activeColors,
                        dominantColor: gameInstance.dominantColor,
                        shapeColorPools: gameInstance.shapeColorPools,
                        laneNodes: gameInstance.laneNodes,
                        highScore: gameInstance.highScore,
                        timestamp: Date.now(),
                        version: '1.0',
                        __timer: {
                            startMs: gameInstance.timerStartMs,
                            pausedMs: gameInstance.pausedAccumMs,
                            savedAtMs: Date.now()
                        }
                    };
                    localStorage.setItem(this.SAVE_KEY, JSON.stringify(saveData));
                    console.log('游戏已自动保存');
                } catch (error) {
                    console.error('保存失败:', error);
                }
            }
            
            // 加载游戏
            static loadGame() {
                try {
                    const saveData = localStorage.getItem(this.SAVE_KEY);
                    if (!saveData) {
                        console.log('没有找到存档，开始新游戏');
                        return null;
                    }
                    
                    const parsed = JSON.parse(saveData);
                    
                    // 验证存档数据完整性
                    if (!this.validateSaveData(parsed)) {
                        console.log('存档数据不完整，开始新游戏');
                        localStorage.removeItem(this.SAVE_KEY);
                        return null;
                    }
                    
                    console.log('找到有效存档，加载游戏');
                    return parsed;
                } catch (error) {
                    console.error('读取存档失败:', error);
                    localStorage.removeItem(this.SAVE_KEY);
                    return null;
                }
            }
            
            // 验证存档数据
            static validateSaveData(data) {
                const requiredFields = [
                    'grid', 'score', 'comboMultiplier', 'currentShapes', 
                    'colors', 'maxShapeColors', 'activeColors', 'dominantColor', 'shapeColorPools', 'laneNodes', 'highScore', 'version'
                ];
                
                for (const field of requiredFields) {
                    if (!(field in data)) {
                        console.log(`存档缺少字段: ${field}`);
                        return false;
                    }
                }
                
                // 检查grid是否为8x8数组
                if (!Array.isArray(data.grid) || data.grid.length !== 8) {
                    console.log('存档grid格式错误');
                    return false;
                }
                
                // 检查currentShapes是否为数组
                if (!Array.isArray(data.currentShapes)) {
                    console.log('存档currentShapes格式错误');
                    return false;
                }
                
                return true;
            }
            
            // 清除存档
            static clearSave() {
                // 保存最高分，避免被清除
                const independentHigh = this.loadHighScore();
                localStorage.removeItem(this.SAVE_KEY);
                // 恢复最高分
                if (independentHigh > 0) {
                    this.saveHighScore(independentHigh);
                }
                console.log('存档已清除，最高分已保留');
            }
            
            // 获取当前最高分
            static getCurrentHighScore() {
                try {
                    const saveData = localStorage.getItem(this.SAVE_KEY);
                    if (saveData) {
                        const parsed = JSON.parse(saveData);
                        return parsed.highScore || 0;
                    }
                } catch (error) {
                    console.error('读取最高分失败:', error);
                }
                return 0;
            }
            
            // 保存最高分
            static saveHighScore(highScore) {
                try {
                    localStorage.setItem('blockBlastHighScore', JSON.stringify({ highScore }));
                    console.log('最高分已保存:', highScore);
                } catch (error) {
                    console.error('保存最高分失败:', error);
                }
            }
            
            // 加载最高分
            static loadHighScore() {
                try {
                    const highScoreData = localStorage.getItem('blockBlastHighScore');
                    if (highScoreData) {
                        const parsed = JSON.parse(highScoreData);
                        return parsed.highScore || 0;
                    }
                } catch (error) {
                    console.error('加载最高分失败:', error);
                }
                return 0;
            }
        }

        class BlockBlast {
            constructor(colorCount, maxShapeColors) {
                this.gridSize = 8;
                this.grid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(0));
                this.score = 0;
                this.currentShapes = [];
                this.draggedShape = null;
                this.dragOffset = { x: 0, y: 0 };
                this.comboCount = 0; // 连击计数（基础逻辑）
                this.comboMultiplier = 1; // 由 comboCount 推导：1 + 0.5*comboCount
                this.colors = colorCount; // 颜色种类由参数决定
                this.maxShapeColors = maxShapeColors; // 每块最多颜色数
                this.shapeId = 1; // 唯一id自增
                // 新增：宽松连击相关变量
                this.lastRoundEliminated = false;
                this.thisRoundEliminated = false;
                this.blocksUsedInRound = 0;
                // 新增：算法泳道相关变量
                this.dominantColor = 1; // 默认颜色1
                // 新增：每个块的颜色池管理
                this.shapeColorPools = [[], [], []]; // 3个块的颜色池
                // 新增：泳道节点管理
                this.laneNodes = [0, 0, 0]; // 3个泳道节点分数
                // 泳道循环（按固定长度循环分段判定）
                this.laneLoopEnabled = true;
                this.laneLoopLength = 8000; // 分数达到此值即循环归零（减去该值）
                // 新增：本局运行计时器（秒）
                this.timerStartMs = Date.now();
                this.pausedAccumMs = 0;
                this.pauseStartedMs = null;
                this.isTimerPaused = false;
                // 读档后是否恢复计时（默认关闭：读档后重置计时）
                this.timerResumeFromSaveEnabled = false;
                // 新增：定时策略触发配置（不含策略，仅触发条件与状态）
                this.timeTriggerEnabled = true; // 基础定时触发默认开启
                this.timeEventActive = false; // 是否处于时间触发期
                // 基础阈值触发：单位秒（达到后每轮都触发）
                this.timeTriggerThresholdSec = 300 + Math.floor(Math.random() * 60);
                // 新增：最高分记录
                this.highScore = SaveManager.loadHighScore(); // 从独立存储加载最高分
                
                // 新增：设置相关变量
                this.settings = this.loadSettings();
                // 新增：语言（zh/en）
                this.language = this.settings.language || 'zh';
                
                // 新增：死亡检测相关变量
                this.pendingGameOverCheck = false;
                this.gameOverCheckTimeout = null; // 新增：延迟检测的定时器引用
                this.isPerformingGameOverCheck = false; // 新增：防止重复检测的标志
                
                // 新增：死亡动画相关变量
                this.isDeathAnimationPlaying = false; // 防止重复触发动画
                this.deathAnimationStage = 0; // 当前动画阶段
                this.deathAnimationTimeouts = []; // 动画定时器数组
                
                // 两色一轮策略（TCR）
                this.useTwoColorRoundStrategy = true; // 全局最高优先级测试开启
                this.twoColorRoundState = { active: false, colors: [0, 0], usage: {} };

                // 二三分策略（准备状态，默认不启用）
                this.useErSanFenStrategy = false; // 外部阶段切换时置为true启用
                this.useErSanFenAsync = false; // 变种：异步二三分，三块各自随机取面积
                this.esfState = { active: false, sizes: [], index: 0, colors: [] };
                this.esfCycleCompleted = false; // 开局只执行一轮N次，完成后标记
                // 新：单轮三分策略（Single Triple Split, STS）——仅一轮，拆成a,b,c三份
                this.useSingleTripleSplitStrategy = false; // 默认关闭，按需开启
                this.stsState = { active: false, sizes: [], color: 0, completed: false };
                 
                this.shapes = [
                    [[1]], // 单点
                    [[1, 1]], // 两格横
                    [[1], [1]], // 两格竖
                    [[1, 1, 1]], // 三格横
                    [[1], [1], [1]], // 三格竖
                    [[1, 1], [1, 1]], // 方块
                    [[1, 1, 1], [1, 0, 0]], // L形
                    [[1, 1, 1], [0, 0, 1]], // 反L形
                    [[1, 1, 0], [0, 1, 1]], // Z形
                    [[0, 1, 1], [1, 1, 0]], // 反Z形
                    [[1, 1, 1, 1]], // 四格横
                    [[1], [1], [1], [1]], // 四格竖
                    [[1, 1, 1], [0, 1, 0]], // T形
                    // 新增：
                    [[1,1,1,1,1]], // 横5格
                    [[1],[1],[1],[1],[1]], // 竖5格
                    // 5格L形（3x3）
                    [[1,0,0],[1,0,0],[1,1,1]], // L形5格 左下
                    [[0,0,1],[0,0,1],[1,1,1]], // L形5格 右下
                    [[1,1,1],[1,0,0],[1,0,0]], // L形5格 左上
                    [[1,1,1],[0,0,1],[0,0,1]], // L形5格 右上
                    [[1,1,1],[1,1,1]], // 2x3 横
                    [[1,1],[1,1],[1,1]], // 2x3 竖
                    [[1,1,1],[1,1,1],[1,1,1]], // 3x3 方块
                    // 新增：对角线形状（暂时注释，难度较高）
                    // [[1,0],[0,1]], // Z形2格（左上到右下）
                    // [[0,1],[1,0]], // Z形2格（右上到左下）
                    // [[1,0,0],[0,1,0],[0,0,1]], // Z形3格（左上到右下）
                    // [[0,0,1],[0,1,0],[1,0,0]], // Z形3格（右上到左下）
                ];
                // 新增：每局随机选N种颜色
                this.activeColors = this.getRandomColors(this.colors);
                // 初始化每个块的颜色池
                this.initializeShapeColorPools();
                // 初始化泳道节点
                this.initializeLaneNodes();
                
                // 尝试加载存档
                const savedData = SaveManager.loadGame();
                if (savedData) {
                    this.loadFromSave(savedData);
                } else {
                    this.init(); // 新建游戏
                }
            }

            // 选择两种本局颜色并初始化本轮状态
            prepareTwoColorRound() {
                try {
                    const pool = (this.activeColors && this.activeColors.length) ? [...this.activeColors] : [1,2,3];
                    while (pool.length < 2) pool.push(pool[0]);
                    // 随机两种
                    for (let i = pool.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [pool[i], pool[j]] = [pool[j], pool[i]]; }
                    const cA = pool[0];
                    // 找到不等于 cA 的色，否则就用 cA 本身（容错）
                    const cB = pool.find(c => c !== cA) ?? cA;
                    this.twoColorRoundState = { active: true, colors: [cA, cB], usage: { [cA]: 0, [cB]: 0 } };
                } catch(_) {
                    this.twoColorRoundState = { active: true, colors: [1, 2], usage: { 1:0, 2:0 } };
                }
            }

            // 为给定 pattern 生成两色矩阵：1+1 播种，其余随机填充；n<2 或 单色限制 时按用量均衡选择
            buildTwoColorMatrix(pattern, colorsPair) {
                const fallbackColors = (this.activeColors && this.activeColors.length) ? this.activeColors : [1,2,3];
                const pair = Array.isArray(colorsPair) ? colorsPair.slice(0, 2) : [];
                let cA = Number(pair[0]);
                let cB = Number(pair[1]);
                if (!Number.isFinite(cA) || cA <= 0) cA = fallbackColors[0] || 1;
                if (!Number.isFinite(cB) || cB <= 0 || cB === cA) {
                    const alt = fallbackColors.find(c => c !== cA);
                    cB = (typeof alt === 'number') ? alt : cA;
                }
                const usage = this.twoColorRoundState && this.twoColorRoundState.usage ? this.twoColorRoundState.usage : { [cA]:0, [cB]:0 };
                const rows = pattern.length;
                const cols = pattern[0].length;
                const coords = [];
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        if (pattern[r][c]) coords.push([r, c]);
                    }
                }
                const n = coords.length;
                const out = Array.from({ length: rows }, () => Array(cols).fill(0));
                if (n === 0) return out;
                // 单色限制或仅1格
                if (n === 1 || this.maxShapeColors <= 1) {
                    const prefer = (usage[cA] <= usage[cB]) ? cA : cB;
                    const [r0, c0] = coords[0];
                    out[r0][c0] = prefer;
                    usage[prefer] = (usage[prefer] || 0) + 1;
                    return out;
                }
                // 1+1 播种
                for (let i = coords.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [coords[i], coords[j]] = [coords[j], coords[i]]; }
                const seedA = coords[0];
                const seedB = coords[1];
                out[seedA[0]][seedA[1]] = cA; usage[cA] = (usage[cA] || 0) + 1;
                out[seedB[0]][seedB[1]] = cB; usage[cB] = (usage[cB] || 0) + 1;
                // 其余随机填充 A/B
                for (let i = 2; i < coords.length; i++) {
                    const [r, c] = coords[i];
                    const pick = (Math.random() < 0.5) ? cA : cB;
                    out[r][c] = pick; usage[pick] = (usage[pick] || 0) + 1;
                }
                return out;
            }
            // 从存档加载
            loadFromSave(savedData) {
                this.grid = savedData.grid;
                this.score = savedData.score;
                // 兼容旧存档：优先读取 comboCount；否则由倍率反推
                this.comboCount = typeof savedData.comboCount === 'number'
                    ? Math.max(0, Math.floor(savedData.comboCount))
                    : Math.max(0, Math.round(Math.max(1, savedData.comboMultiplier || 1) - 1) / 0.5);
                this.comboMultiplier = 1 + 0.5 * this.comboCount;
                this.lastRoundEliminated = savedData.lastRoundEliminated;
                this.thisRoundEliminated = savedData.thisRoundEliminated;
                this.blocksUsedInRound = savedData.blocksUsedInRound;
                this.shapeId = savedData.shapeId;
                this.currentShapes = savedData.currentShapes;
                this.colors = savedData.colors;
                this.maxShapeColors = savedData.maxShapeColors;
                this.activeColors = savedData.activeColors;
                this.dominantColor = savedData.dominantColor || 1;
                this.shapeColorPools = savedData.shapeColorPools || [[], [], []];
                this.laneNodes = savedData.laneNodes || [0, 0, 0];
                // 不从存档覆盖最高分，始终以独立存储的最高分为准
                // 计时器恢复策略
                try {
                    if (this.timerResumeFromSaveEnabled && savedData.__timer) {
                        const t = savedData.__timer;
                        this.timerStartMs = typeof t.startMs === 'number' ? t.startMs : Date.now();
                        this.pausedAccumMs = typeof t.pausedMs === 'number' ? t.pausedMs : 0;
                        this.pauseStartedMs = null;
                        this.isTimerPaused = false;
                    } else {
                        // 默认读档后重置计时
                        this.timerStartMs = Date.now();
                        this.pausedAccumMs = 0;
                        this.pauseStartedMs = null;
                        this.isTimerPaused = false;
                    }
                } catch(_) {}
                
                this.createGrid();
                this.updateGrid();
                this.updateScore();
                this.updateCombo();
                // 后置覆盖钩子：允许外部覆盖已经生成好的3个块
                try {
                    if (window.CP8_HOOK && window.CP8_HOOK.enabled && window.CP8_HOOK.position === 'after') {
                        const res = (typeof window.CP8_generateShapes === 'function') ? window.CP8_generateShapes(this, this.currentShapes) : null;
                        if (Array.isArray(res) && res.length) {
                            this.currentShapes = res.slice(0, 3).map(s => ({ id: this.shapeId++, pattern: s.pattern, colors: s.colors }));
                        }
                    }
                } catch(_) {}
                this.renderShapes();
                this.setupEventListeners();
                // 应用语言到UI
                this.applyLanguage();
                
                // 播放开局激励BGM（加载存档时也播放）
                this.playStartupBGM();
                
                // 加载存档后重新做一次死亡判定
                if (this.isGameOver()) {
                    console.log('加载存档后检测到游戏结束状态，清除存档并重新开始');
                    SaveManager.clearSave();
                    // 使用完整的重新开始流程
                    this.init(); // 重新开始游戏
                    return;
                }
            }

            // 自动保存
            autoSave() {
                SaveManager.saveGame(this);
            }

            // 新增：从1~8中随机选n种颜色
            getRandomColors(n) {
                const arr = [1,2,3,4,5,6,7,8];
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                return arr.slice(0, n);
            }

            // 新增：初始化每个块的颜色池
            initializeShapeColorPools() {
                const baseColors = (this.activeColors && this.activeColors.length) ? this.activeColors : [1,2,3];
                for (let i = 0; i < 3; i++) {
                    // 复制本局活跃颜色池作为初始值（兜底非空）
                    this.shapeColorPools[i] = [...baseColors];
                }
                console.log('初始化块颜色池:', this.shapeColorPools);
            }

            // 初始化泳道节点（当前阈值：约2000/4000/6000 起步，带少量波动）
            initializeLaneNodes() {
                this.laneNodes[0] = 2000 + Math.floor(Math.random() * 200);
                this.laneNodes[1] = 4000 + Math.floor(Math.random() * 400);
                this.laneNodes[2] = 6000 + Math.floor(Math.random() * 600);
                console.log('初始化泳道节点:', this.laneNodes);
            }

            // 新增：颜色分配策略0 - 完整颜色池
            updateColorPoolsStrategy0() {
                // 刷新3个块的颜色池为本局的颜色（兜底非空）
                const baseColors = (this.activeColors && this.activeColors.length) ? this.activeColors : [1,2,3];
                for (let i = 0; i < 3; i++) {
                    this.shapeColorPools[i] = [...baseColors];
                }
                
                console.log('颜色分配策略0 - 完整颜色池:', {
                    activeColors: baseColors,
                    shapeColorPools: this.shapeColorPools
                });
            }

            // 新增：颜色分配策略1 - 共同颜色+剩余随机1种
            updateColorPoolsStrategy1() {
                // 从颜色池中取随机1种颜色作为共同颜色（兜底非空）
                const baseColors = (this.activeColors && this.activeColors.length) ? this.activeColors : [1,2,3];
                const commonColor = baseColors[Math.floor(Math.random() * baseColors.length)];
                
                // 颜色池中剩余的颜色
                const remainingColors = baseColors.filter(color => color !== commonColor);
                
                // 为每个块分配颜色池：共同颜色 + 各自随机的另一种颜色（若无则退化为共同色）
                for (let i = 0; i < 3; i++) {
                    const randomColor = remainingColors.length ? remainingColors[Math.floor(Math.random() * remainingColors.length)] : commonColor;
                    this.shapeColorPools[i] = [commonColor, randomColor];
                }
                
                console.log('颜色分配策略1 - 共同颜色+剩余随机1种:', {
                    commonColor: commonColor,
                    remainingColors: remainingColors,
                    shapeColorPools: this.shapeColorPools
                });
            }

            // 新增：颜色分配策略2 - 共同颜色+本局随机1种
            updateColorPoolsStrategy2() {
                // 从颜色池中取随机1种颜色作为共同颜色（兜底非空）
                const baseColors = (this.activeColors && this.activeColors.length) ? this.activeColors : [1,2,3];
                const commonColor = baseColors[Math.floor(Math.random() * baseColors.length)];
                
                // 为每个块分配颜色池：共同颜色 + 本局颜色池中的随机1种
                for (let i = 0; i < 3; i++) {
                    const randomColor = baseColors[Math.floor(Math.random() * baseColors.length)];
                    this.shapeColorPools[i] = [commonColor, randomColor];
                }
                
                console.log('颜色分配策略2 - 共同颜色+本局随机1种:', {
                    commonColor: commonColor,
                    activeColors: baseColors,
                    shapeColorPools: this.shapeColorPools
                });
            }

            // 新增：颜色分配策略X - 每个块独立从本局颜色中随机抽两色（≤2色）
            // 位置：介于 TCR 与 最终策略0 之间；与最终策略一致地不固定"共同色"，但限制每块两色
            updateColorPoolsStrategyPreferredPair() {
                try {
                    const pool = (this.activeColors && this.activeColors.length) ? [...this.activeColors] : [1,2,3];
                    for (let i = 0; i < 3; i++) {
                        // 随机抽取两色，保证尽量不同；不足则退化
                        const shuffled = [...pool];
                        for (let k = shuffled.length - 1; k > 0; k--) { const j = Math.floor(Math.random() * (k + 1)); [shuffled[k], shuffled[j]] = [shuffled[j], shuffled[k]]; }
                        const cA = shuffled[0];
                        const cB = shuffled.find(c => c !== cA) ?? cA;
                        this.shapeColorPools[i] = [cA, cB];
                    }
                    console.log('颜色分配策略X - 每块独立两色:', { activeColors: this.activeColors, shapeColorPools: this.shapeColorPools });
                } catch (e) {
                    this.updateColorPoolsStrategy2();
                }
            }

            // 新增：TCR 作为固定策略函数（供泳道段1调用）
            updateColorPoolsStrategyTCR() {
                try {
                    if (!this.twoColorRoundState || !this.twoColorRoundState.active) this.prepareTwoColorRound();
                    const [cA, cB] = this.twoColorRoundState.colors || [1, 2];
                    this.shapeColorPools[0] = [cA, cB];
                    this.shapeColorPools[1] = [cA, cB];
                    this.shapeColorPools[2] = [cA, cB];
                    this.twoColorRoundState.active = false;
                } catch (_) {
                    // 兜底：退回策略2
                    this.updateColorPoolsStrategy2();
                }
            }

            init() {
                // 重置游戏状态
                this.grid = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(0));
                this.score = 0;
                this.comboMultiplier = 1;
                this.currentShapes = [];
                this.draggedShape = null;
                this.lastRoundEliminated = false;
                this.thisRoundEliminated = false;
                this.blocksUsedInRound = 0;
                this.shapeId = 1;
                // 重置计时器
                this.timerStartMs = Date.now();
                this.pausedAccumMs = 0;
                this.pauseStartedMs = null;
                this.isTimerPaused = false;
                // 重置定时触发相关状态
                this.timeEventActive = false;
                // 清空上一次放块分待合并信息
                this.pendingPlacementScore = 0;
                this.pendingPlacementAnchor = null;
                
                // 重置死亡检测状态
                this.clearGameOverCheck();
                
                this.createGrid();
                // 每局重新随机颜色
                this.activeColors = this.getRandomColors(this.colors);
                // 初始化每个块的颜色池
                this.initializeShapeColorPools();
                // 初始化泳道节点
                this.initializeLaneNodes();
                // 开局策略：同步二三分 / 异步二三分 / 单轮三分(STS) 等概率选择一种
                this.esfCycleCompleted = false;
                // 清空所有开场策略开关
                this.useErSanFenStrategy = false;
                this.useErSanFenAsync = false;
                this.useSingleTripleSplitStrategy = false;
                // 随机选择
                (function pickAndEnable(self){
                    const roll = Math.floor(Math.random() * 3); // 0 同步, 1 异步, 2 STS
                    if (roll === 0) {
                        self.useErSanFenStrategy = true;
                        self.useErSanFenAsync = false;
                        self.esfState.active = false; // 首次 generate 时初始化ESF
                    } else if (roll === 1) {
                        self.useErSanFenStrategy = true;
                        self.useErSanFenAsync = true;
                        self.esfState.active = false;
                    } else {
                        self.useSingleTripleSplitStrategy = true;
                        self.stsState.active = false; // 首次 generate 时初始化STS
                        self.stsState.completed = false;
                    }
                })(this);
                this.generateShapes();
                this.updateGrid();
                this.updateScore();
                this.updateCombo();
                this.setupEventListeners();
                
                // 应用语言到UI（首次启动时确保使用默认语言）
                this.applyLanguage();
                
                // 播放开局激励BGM
                this.playStartupBGM();
            }

            // 本局已用时（秒），自动剔除暂停时长
            getElapsedSeconds() {
                const now = Date.now();
                const pausedNow = this.isTimerPaused && this.pauseStartedMs ? (now - this.pauseStartedMs) : 0;
                const effectivePaused = this.pausedAccumMs + (this.isTimerPaused ? pausedNow : 0);
                const elapsedMs = Math.max(0, now - this.timerStartMs - effectivePaused);
                return Math.floor(elapsedMs / 1000);
            }

            // 暂停/恢复计时器（供外部调用，如打开设置面板/失焦等）
            pauseTimer() {
                if (this.isTimerPaused) return;
                this.isTimerPaused = true;
                this.pauseStartedMs = Date.now();
            }

            resumeTimer() {
                if (!this.isTimerPaused) return;
                const now = Date.now();
                if (this.pauseStartedMs) this.pausedAccumMs += Math.max(0, now - this.pauseStartedMs);
                this.isTimerPaused = false;
                this.pauseStartedMs = null;
            }

            createGrid() {
                const gridElement = document.getElementById('grid');
                gridElement.innerHTML = '';
                
                for (let i = 0; i < this.gridSize * this.gridSize; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.index = i;
                    gridElement.appendChild(cell);
                }
			}

            // 辅助函数：查找所有可放入位置
            findAllValidPositions(grid, pattern) {
                const positions = [];
                for (let row = 0; row <= this.gridSize - pattern.length; row++) {
                    for (let col = 0; col <= this.gridSize - pattern[0].length; col++) {
                        let canPlace = true;
                        for (let r = 0; r < pattern.length; r++) {
                            for (let c = 0; c < pattern[r].length; c++) {
                                if (pattern[r][c] && grid[row + r][col + c]) {
                                    canPlace = false;
                                    break;
                                }
                            }
                            if (!canPlace) break;
                        }
                        if (canPlace) positions.push({row, col});
                    }
                }
                return positions;
            }

            // 辅助函数：返回放置后的新grid
            placeShapeOnGrid(grid, pattern, colors, startRow, startCol) {
                const newGrid = grid.map(row => row.slice());
                for (let r = 0; r < pattern.length; r++) {
                    for (let c = 0; c < pattern[r].length; c++) {
                        if (pattern[r][c]) {
                            newGrid[startRow + r][startCol + c] = colors[r][c];
                        }
                    }
                }
                return newGrid;
            }

            // Fisher-Yates 洗牌算法
            shuffleArray(arr) {
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
            }

            // 获取所有可能的起点并打乱
            getShuffledPositions(maxRow, maxCol) {
                const positions = [];
                for (let row = 0; row <= maxRow; row++) {
                    for (let col = 0; col <= maxCol; col++) {
                        positions.push({row, col});
                    }
                }
                this.shuffleArray(positions);
                return positions;
            }

            // 统计盘面各颜色数量，返回最多的颜色
            getMostFrequentColor() {
                const colorCounts = {};
                
                // 统计每种颜色的数量
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const color = this.grid[row][col];
                        if (color > 0) {
                            colorCounts[color] = (colorCounts[color] || 0) + 1;
                        }
                    }
                }
                
                // 找到数量最多的颜色
                let maxCount = 0;
                let mostFrequentColors = [];
                
                for (const color in colorCounts) {
                    const count = colorCounts[color];
                    if (count > maxCount) {
                        maxCount = count;
                        mostFrequentColors = [parseInt(color)];
                    } else if (count === maxCount) {
                        mostFrequentColors.push(parseInt(color));
                    }
                }
                
                // 如果有最多数量的颜色，随机选择一个
                if (mostFrequentColors.length > 0) {
                    return mostFrequentColors[Math.floor(Math.random() * mostFrequentColors.length)];
                }
                
                // 如果所有颜色都为0，从本局颜色中随机选择
                return this.activeColors[Math.floor(Math.random() * this.activeColors.length)];
            }

            generateShapes() {
                // 覆盖钩子：前置（最高优先级）
                try {
                    if (window.CP8_HOOK && window.CP8_HOOK.enabled && window.CP8_HOOK.position === 'before') {
                        const res = (typeof window.CP8_generateShapes === 'function') ? window.CP8_generateShapes(this) : null;
                        if (Array.isArray(res) && res.length) {
                            this.currentShapes = res.slice(0, 3).map(s => ({ id: this.shapeId++, pattern: s.pattern, colors: s.colors }));
                            this.renderShapes();
                            return;
                        }
                    }
                } catch(_) {}
                // 优先：单轮三分策略（STS）——单独测试或开局单轮时使用
                if (this.useSingleTripleSplitStrategy) {
                    if (!this.stsState || !this.stsState.active) {
                        if (!this.stsState || !this.stsState.completed) this.initSingleTripleSplitStrategy();
                    }
                    if (this.stsState && this.stsState.active) {
                        const sizes = [...this.stsState.sizes];
                        for (let i = sizes.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [sizes[i], sizes[j]] = [sizes[j], sizes[i]];
                        }
                        const color = this.stsState.color;
                        // console 调试
                        try { console.log('STS 开局：sizes=', sizes, ' color=', color); } catch(_) {}
                        this.currentShapes = [];
                        for (let i = 0; i < 3; i++) {
                            const area = sizes[i % sizes.length];
                            const pattern = this.getRandomShapeByArea(area);
                            const colorMatrix = this.buildPureColorMatrix(pattern, color);
                            this.currentShapes.push({ id: this.shapeId++, pattern, colors: colorMatrix });
                        }
                        this.renderShapes();
                        this.completeSingleTripleSplit();
                        return;
                    }
                }
                 // 若开启二三分策略并处于活动阶段，则按ESF规格生成一批3个块
                 if (this.useErSanFenStrategy) {
                     if (!this.esfState || !this.esfState.active) {
                         if (this.esfCycleCompleted) {
                             // 已完成一轮，直接回退至原逻辑
                         } else {
                             this.initErSanFenStrategy();
                         }
                     }
                     const spec = this.esfCycleCompleted ? null : this.getCurrentEsfSpec();
                     if (spec) {
                         const { area, colors } = spec;
                         // 每轮随机打乱三色对应的左右中顺序
                         const shuffled = [...colors];
                         for (let i = shuffled.length - 1; i > 0; i--) {
                             const j = Math.floor(Math.random() * (i + 1));
                             [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                         }
                         // 若启用异步二三分：从每个颜色对应的bag中"不放回"取一个面积，确保N轮内对该颜色的面积不重复
                         const areasForRound = [];
                         if (this.useErSanFenAsync && this.esfAsync && this.esfAsync.bagsByColor) {
                             for (let k = 0; k < 3; k++) {
                                 const col = shuffled[k % shuffled.length];
                                 const bag = this.esfAsync.bagsByColor[col] || [];
                                 let pick = bag.length ? bag.pop() : this.esfState.sizes[Math.floor(Math.random()*this.esfState.sizes.length)];
                                 areasForRound.push(pick);
                             }
                         }
                         this.currentShapes = [];
                         for (let i = 0; i < 3; i++) {
                             // 变种：每个块独立随机选取面积（来自本轮sizes集合）
                             const pickArea = this.useErSanFenAsync ? areasForRound[i] : area;
                             const pattern = this.getRandomShapeByArea(pickArea);
                             const colorNum = shuffled[i % shuffled.length];
                             const colorMatrix = this.buildPureColorMatrix(pattern, colorNum);
                             this.currentShapes.push({ id: this.shapeId++, pattern, colors: colorMatrix });
                         }
                         this.renderShapes();
                         this.advanceEsfRound();
                         if (!this.esfState.active) {
                             // N轮完成：标记并关闭ESF，后续回落泳道
                             this.esfCycleCompleted = true;
                             this.useErSanFenStrategy = false;
                         }
                         return;
                     }
                     // 若ESF已结束，则继续走原有逻辑
                 }
                 
                 // 算法泳道逻辑：更新指定变量为当前盘面块数最多的颜色种类
                 this.dominantColor = this.getMostFrequentColor();
                 console.log('当前盘面最多颜色:', this.dominantColor);
                 
                 // 定时策略触发检测（仅更新状态，不执行策略）
                 try {
                     if (this.timeTriggerEnabled) {
                         const elapsed = this.getElapsedSeconds();
                         const prev = this._lastTimeProgressSec || 0;
                         const windowSec = 0; // 简化：不再使用容差窗口
                         // 简化：达到阈值后每轮都触发
                         if (elapsed >= (this.timeTriggerThresholdSec || 0)) {
                             this.timeEventActive = true;
                         } else {
                             this.timeEventActive = false;
                         }
                         // 结束简化
                         const nodes = Array.isArray(this.timeTriggerNodesSec) ? this.timeTriggerNodesSec : [];
                         let crossed = false;
                         for (const t of nodes) {
                             if (t >= prev && t <= elapsed + windowSec) { crossed = true; break; }
                         }
                         this._lastTimeProgressSec = elapsed;
                         if (crossed) {
                             this.timeEventRoundsLeft = Math.max(this.timeTriggerRounds || 1, 1);
                             this.timeEventActive = true;
                         }
                         if (this.timeEventRoundsLeft <= 0) this.timeEventActive = false;
                     }
                 } catch(_) {}

                 // 定时策略：优先于泳道
                 if (this.timeEventActive) {
                     this.updateColorPoolsStrategy0();
                        } else {
                    // 泳道逻辑：根据分数阶段调用不同策略（支持循环）
                    let laneProgress = this.score;
                    
                    // 如果启用循环且分数超过循环长度，则进行循环处理
                    if (this.laneLoopEnabled && laneProgress >= this.laneLoopLength) {
                        const loopCount = Math.floor(laneProgress / this.laneLoopLength);
                        laneProgress = laneProgress % this.laneLoopLength;
                        console.log(`泳道循环: 分数 ${this.score} -> 循环${loopCount}次, 当前进度 ${laneProgress}`);
                    }
                    
                    if (laneProgress < this.laneNodes[0]) {
                       // 第1段：TCR 作为固定泳道策略
                       this.updateColorPoolsStrategyTCR();
                   } else if (laneProgress >= this.laneNodes[0] && laneProgress < this.laneNodes[1]) {
                    // 第2段：策略2
                    this.updateColorPoolsStrategy2();
                    } else if (laneProgress >= this.laneNodes[1] && laneProgress < this.laneNodes[2]) {
                    // 第3段：策略1
                    this.updateColorPoolsStrategy1();
                    } else if (laneProgress >= this.laneNodes[2]) {
                        // 第4段：单块双色策略（替换原策略0）
                        this.updateColorPoolsStrategyPreferredPair();
                    }
                }
                 
                 // 新出块逻辑：块池打乱，依次取块，依次放下3个块
                 try { console.log('出块前计时(秒):', this.getElapsedSeconds()); } catch(_) {}
                 let found = false;
                 let tryCount = 0;
                 const maxTries = 100;
                 let lastRandomShapes = [];
                 let selectedShapes = [];
                 let patterns = [];
                 let colorsArr = [];
                 while (!found && tryCount < maxTries) {
                     tryCount++;
                     let tempGrid = this.grid.map(row => row.slice());
                     // 1. 块池打乱
                     const shapePool = this.shapes.slice();
                     this.shuffleArray(shapePool);
                     selectedShapes = [];
                     patterns = [];
                     colorsArr = [];
                     lastRandomShapes = [];
                     for (let i = 0; i < shapePool.length && selectedShapes.length < 3; i++) {
                         const pattern = shapePool[i];
                         // 使用对应块的颜色池
                         const blockIndex = selectedShapes.length; // 当前是第几个块
                         const rawPool = this.shapeColorPools[blockIndex];
                         const baseColors = (this.activeColors && this.activeColors.length) ? this.activeColors : [1,2,3];
                         const colorPool = (Array.isArray(rawPool) && rawPool.length) ? rawPool : baseColors;
                         // 若为单块双色策略（两色池）且允许多色，优先保证两色都出现（1+1播种），否则直接随机
                         let cellCount = 0; for (let rr = 0; rr < pattern.length; rr++) { for (let cc = 0; cc < pattern[rr].length; cc++) { if (pattern[rr][cc]) cellCount++; } }
                         const colors = (Array.isArray(colorPool) && colorPool.length === 2 && this.maxShapeColors > 1 && cellCount >= 2)
                             ? this.buildTwoColorMatrix(pattern, colorPool)
                             : pattern.map(row => row.map(cell => cell ? colorPool[Math.floor(Math.random() * colorPool.length)] : 0));
                         // 2. 获取所有可能起点并打乱
                         const maxRow = this.gridSize - pattern.length;
                         const maxCol = this.gridSize - pattern[0].length;
                         const positions = this.getShuffledPositions(maxRow, maxCol);
                         let placed = false;
                         for (const pos of positions) {
                             // 检查能否放下
                             let canPlace = true;
                             for (let r = 0; r < pattern.length; r++) {
                                 for (let c = 0; c < pattern[r].length; c++) {
                                     if (pattern[r][c] && tempGrid[pos.row + r][pos.col + c]) {
                                         canPlace = false;
                                         break;
                                     }
                                 }
                                 if (!canPlace) break;
                             }
                             if (canPlace) {
                                 // 放下
                                 tempGrid = this.placeShapeOnGrid(tempGrid, pattern, colors, pos.row, pos.col);
                                 selectedShapes.push({pattern, colors});
                                 patterns.push(pattern);
                                 colorsArr.push(colors);
                                 placed = true;
                                 break;
                             }
                         }
                         // 记录所有尝试过的shape和配色
                         lastRandomShapes.push({ pattern, colors });
                     }
                     if (selectedShapes.length === 3) {
                         found = true;
                     }
                 }
                 // 构造最终的3个块
                 this.currentShapes = [];
                 let idx = 0;
                 for (; idx < selectedShapes.length && idx < 3; idx++) {
                     this.currentShapes.push({
                         id: this.shapeId++,
                         pattern: selectedShapes[idx].pattern,
                         colors: selectedShapes[idx].colors
                     });
                 }
                 // 补足到3个
                 while (this.currentShapes.length < 3) {
                     // 随机选一个shape和配色
                     let randomShape;
                     if (lastRandomShapes.length > 0) {
                         randomShape = lastRandomShapes[Math.floor(Math.random() * lastRandomShapes.length)];
                     } else {
                         // 兜底
                         const pattern = this.shapes[0];
                         const blockIndex = this.currentShapes.length; // 当前是第几个块
                         const rawPool = this.shapeColorPools[blockIndex];
                         const baseColors = (this.activeColors && this.activeColors.length) ? this.activeColors : [1,2,3];
                         const colorPool = (Array.isArray(rawPool) && rawPool.length) ? rawPool : baseColors;
                         // 与上方一致的规则：双色池时优先包含两色
                         let __cells = 0; for (let r2 = 0; r2 < pattern.length; r2++) { for (let c2 = 0; c2 < pattern[r2].length; c2++) { if (pattern[r2][c2]) __cells++; } }
                         const colors = (Array.isArray(colorPool) && colorPool.length === 2 && this.maxShapeColors > 1 && __cells >= 2)
                             ? this.buildTwoColorMatrix(pattern, colorPool)
                             : pattern.map(row => row.map(cell => cell ? colorPool[Math.floor(Math.random() * colorPool.length)] : 0));
                         randomShape = { pattern, colors };
                     }
                     this.currentShapes.push({
                         id: this.shapeId++,
                         pattern: randomShape.pattern,
                         colors: randomShape.colors
                     });
                 }
                 this.renderShapes();
                 // 重置连击倍率
                 /*this.comboMultiplier = 1;
                 this.updateCombo();*/
             }

            renderShapes() {
                for (let i = 0; i < 3; i++) {
                    const slot = document.getElementById(`shape-slot-${i}`);
                    slot.innerHTML = '';
                    const shape = this.currentShapes[i];
                    if (shape && shape.pattern) this.createShapeElement(shape, i);
                }
            }

            createShapeElement(shapeWithColors, slotIndex) {
                const slot = document.getElementById(`shape-slot-${slotIndex}`);
                const shapeDiv = document.createElement('div');
                shapeDiv.className = 'shape';
                shapeDiv.dataset.shapeId = shapeWithColors.id;
                shapeDiv.dataset.slotIndex = slotIndex;

                const grid = document.createElement('div');
                grid.className = 'shape-grid';
                grid.style.gridTemplateColumns = `repeat(${shapeWithColors.pattern[0].length}, 1fr)`;

                // 只对最大边大于4的shape缩放，否则保持原始比例
                const maxCell = Math.max(shapeWithColors.pattern.length, shapeWithColors.pattern[0].length);
                const slotSize = 80; // px
                const cellGap = 2; // gap px
                let cellSize;
                if (maxCell > 4) {
                    // 缩放
                    cellSize = (slotSize - cellGap * (maxCell - 1)) / maxCell;
                    grid.style.width = (cellSize * shapeWithColors.pattern[0].length + cellGap * (shapeWithColors.pattern[0].length - 1)) + 'px';
                    grid.style.height = (cellSize * shapeWithColors.pattern.length + cellGap * (shapeWithColors.pattern.length - 1)) + 'px';
                } else {
                    // 保持原始比例，单元格最大20px
                    cellSize = 20;
                    grid.style.width = (cellSize * shapeWithColors.pattern[0].length + cellGap * (shapeWithColors.pattern[0].length - 1)) + 'px';
                    grid.style.height = (cellSize * shapeWithColors.pattern.length + cellGap * (shapeWithColors.pattern.length - 1)) + 'px';
                }
                grid.style.justifySelf = 'center';
                grid.style.alignSelf = 'center';

                for (let r = 0; r < shapeWithColors.pattern.length; r++) {
                    for (let c = 0; c < shapeWithColors.pattern[r].length; c++) {
                        const cell = shapeWithColors.pattern[r][c];
                        const color = shapeWithColors.colors[r][c];
                        const cellDiv = document.createElement('div');
                        if (cell) {
                            cellDiv.className = `shape-cell filled color-${color}`;
                        } else {
                            cellDiv.className = 'shape-cell empty';
                        }
                        cellDiv.style.width = cellSize + 'px';
                        cellDiv.style.height = cellSize + 'px';
                        grid.appendChild(cellDiv);
                    }
                }

                shapeDiv.appendChild(grid);
                slot.appendChild(shapeDiv);
            }

            setupEventListeners() {
                // 鼠标事件
                document.addEventListener('mousedown', this.handleMouseDown.bind(this));
                document.addEventListener('mousemove', this.handleMouseMove.bind(this));
                document.addEventListener('mouseup', this.handleMouseUp.bind(this));

                // 触摸事件 - 添加 passive: false 以确保可以preventDefault
                document.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                document.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                document.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });
                
                // 防止页面滚动干扰拖拽
                document.addEventListener('touchmove', (e) => {
                    if (this.draggedShape) {
                        e.preventDefault();
                    }
                }, { passive: false });

                // 拖拽结束时全局清理投影（兜底）
                document.addEventListener('mouseup', () => {
                    const cells = document.getElementById('grid').children;
                    Array.from(cells).forEach(cell => {
                        cell.classList.remove('projection');
                        cell.style.opacity = '';
                    });
                });
                document.addEventListener('touchend', () => {
                    const cells = document.getElementById('grid').children;
                    Array.from(cells).forEach(cell => {
                        cell.classList.remove('projection');
                        cell.style.opacity = '';
                    });
                });
                // 扩大可拾取区域：左右对齐棋盘（或屏幕边界），从棋盘下沿延申至屏幕底部
                const shapesContainer = document.getElementById('shapes-container');
                if (shapesContainer) {
                    shapesContainer.addEventListener('mousedown', (ev) => {
                        if (ev.target.closest('.shape')) return;
                        if (this.isInExpandedPickRegion(ev.clientX, ev.clientY)) this.pickShapeByZone(ev.clientX, ev.clientY);
                    });
                    shapesContainer.addEventListener('touchstart', (ev) => {
                        if (ev.target.closest('.shape')) return;
                        ev.preventDefault();
                        const t = ev.touches[0];
                        if (this.isInExpandedPickRegion(t.clientX, t.clientY)) this.pickShapeByZone(t.clientX, t.clientY);
                    }, { passive: false });
                    document.addEventListener('mousedown', (ev) => {
                        if (ev.target.closest('.shape') || ev.target.closest('#grid')) return;
                        if (this.isInExpandedPickRegion(ev.clientX, ev.clientY)) this.pickShapeByZone(ev.clientX, ev.clientY);
                    });
                    document.addEventListener('touchstart', (ev) => {
                        if (ev.target.closest('.shape') || ev.target.closest('#grid')) return;
                        const t = ev.touches[0];
                        if (this.isInExpandedPickRegion(t.clientX, t.clientY)) { ev.preventDefault(); this.pickShapeByZone(t.clientX, t.clientY); }
                    }, { passive: false });
                }
            }

            handleMouseDown(e) {
                const shape = e.target.closest('.shape');
                if (shape) {
                    const shapeId = parseInt(shape.dataset.shapeId);
                    const slotIndex = parseInt(shape.dataset.slotIndex);
                    const shapeObj = this.currentShapes.find(s => s && s.id === shapeId);
                    if (!shapeObj) return;
                    this.startDrag(shape, e.clientX, e.clientY);
                } else if (e.target.closest('#shapes-container')) {
                    this.pickShapeByZone(e.clientX, e.clientY);
                }
            }

            handleTouchStart(e) {
                const shape = e.target.closest('.shape');
                if (shape) {
                    const shapeId = parseInt(shape.dataset.shapeId);
                    const slotIndex = parseInt(shape.dataset.slotIndex);
                    const shapeObj = this.currentShapes.find(s => s && s.id === shapeId);
                    if (!shapeObj) return;
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.startDrag(shape, touch.clientX, touch.clientY);
                } else if (e.target.closest('#shapes-container')) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.pickShapeByZone(touch.clientX, touch.clientY);
                }
            }

            // 扩展拾取命中：左右以棋盘为基准（贴两侧），上边贴近棋盘下沿，下至屏幕底
            isInExpandedPickRegion(clientX, clientY) {
                const grid = document.getElementById('grid');
                if (!grid) return false;
                const g = grid.getBoundingClientRect();
                const left = g.left;   // 严格使用棋盘左右作为边界
                const right = g.right;
                const top = g.bottom + 8;
                const bottom = window.innerHeight;
                return clientX >= left && clientX <= right && clientY >= top && clientY <= bottom;
            }

            // 将扩展区域按宽度三等分，点击任一区域拿起对应槽位的块（严格按棋盘宽度等分）
            pickShapeByZone(clientX, clientY) {
                try {
                    const grid = document.getElementById('grid');
                    if (!grid) return;
                    const g = grid.getBoundingClientRect();
                    const left = g.left;   // 严格使用棋盘左右作为边界
                    const right = g.right;
                    const clampedX = Math.min(right, Math.max(left, clientX));
                    const relX = clampedX - left;
                    const zone = Math.min(2, Math.max(0, Math.floor(relX / ((right - left) / 3)))); // 0/1/2
                    const slot = document.getElementById(`shape-slot-${zone}`);
                    if (!slot) return;
                    const shapeEl = slot.querySelector('.shape');
                    if (!shapeEl) return;
                    const startX = clientX;
                    const startY = Math.max(clientY, g.bottom + 8);
                    this.startDrag(shapeEl, startX, startY);
                } catch(_){ }
            }

            startDrag(shapeElement, x, y, anchorAtPointer = false) {
                const shapeId = parseInt(shapeElement.dataset.shapeId);
                const slotIndex = parseInt(shapeElement.dataset.slotIndex);
                const shapeObj = this.currentShapes.find(s => s && s.id === shapeId);
                if (!shapeObj) return;
                if (this.draggedShape) return;
                // 播放拿起块的风声
                playPickupWhoosh();
                const slot = document.getElementById(`shape-slot-${slotIndex}`);
                const slotRect = slot.getBoundingClientRect();
                // 拖拽时切换为固定cell大小
                const grid = shapeElement.querySelector('.shape-grid');
                const gridElement = document.getElementById('grid');
                const firstCell = gridElement.children[0];
                const cellSize = firstCell.offsetWidth;
                const cellGap = 2;
                grid.style.width = (cellSize * shapeObj.pattern[0].length + cellGap * (shapeObj.pattern[0].length - 1)) + 'px';
                grid.style.height = (cellSize * shapeObj.pattern.length + cellGap * (shapeObj.pattern.length - 1)) + 'px';
                grid.style.justifySelf = 'center';
                grid.style.alignSelf = 'center';
                const cells = grid.querySelectorAll('.shape-cell');
                cells.forEach(cell => {
                    cell.style.width = cellSize + 'px';
                    cell.style.height = cellSize + 'px';
                });

                // 设置拖拽外观与层级
                shapeElement.classList.add('dragging');
                shapeElement.style.position = 'fixed';
                shapeElement.style.zIndex = 1000;
                shapeElement.style.pointerEvents = 'none';
                document.body.appendChild(shapeElement);

                // 计算初始锚点
                const halfW = shapeElement.offsetWidth / 2;
                const halfH = shapeElement.offsetHeight / 2;
                const defaultCenterX = slotRect.left + slotRect.width / 2;
                const defaultTopY = slotRect.top - 20;
                const slotStartX = anchorAtPointer ? x : defaultCenterX;
                const slotStartY = anchorAtPointer ? (y - halfH) : defaultTopY;
                const dragYOffset = anchorAtPointer ? 0 : -60;

                this.draggedShape = {
                    element: shapeElement,
                    shapeWithColors: shapeObj,
                    id: shapeId,
                    slotIndex: slotIndex,
                    slotStartX: slotStartX,
                    slotStartY: slotStartY,
                    dragStartX: x,
                    dragStartY: y,
                    dragYOffset: dragYOffset
                };

                // 设置初始位置
                shapeElement.style.left = (slotStartX - halfW) + 'px';
                shapeElement.style.top = (slotStartY + dragYOffset) + 'px';
            }

            handleMouseMove(e) {
                if (this.draggedShape) {
                    this.updateDragPosition(e.clientX, e.clientY);
                }
            }

            handleTouchMove(e) {
                if (this.draggedShape) {
                    e.preventDefault();
                    e.stopPropagation();  // 防止事件冒泡
                    const touch = e.touches[0];
                    this.updateDragPosition(touch.clientX, touch.clientY);
                }
            }

            updateDragPosition(x, y) {
                const element = this.draggedShape.element;
                // 鼠标移动量
                const dx = (x - this.draggedShape.dragStartX) * 1.5;
                const dy = (y - this.draggedShape.dragStartY) * 1.5;
                // 以 slot 上方为锚点
                const left = this.draggedShape.slotStartX - element.offsetWidth / 2 + dx;
                const top = this.draggedShape.slotStartY + dy + this.draggedShape.dragYOffset;
                requestAnimationFrame(() => {
                    element.style.left = left + 'px';
                    element.style.top = top + 'px';
                });
                this.highlightValidPositions(x, y);
            }

            highlightValidPositions(x, y) {
                const gridElement = document.getElementById('grid');
                const gridRect = gridElement.getBoundingClientRect();
                const cells = gridElement.children;
                // 只清理 projection、highlight、invalid 和 projection cell 的 color-x，不影响已放置块
                Array.from(cells).forEach(cell => {
                    if (cell.classList.contains('projection')) {
                        for (let i = 1; i <= 8; i++) cell.classList.remove('color-' + i);
                        cell.classList.remove('projection');
                        cell.style.opacity = '';
                    }
                    cell.classList.remove('highlight', 'invalid', 'pre-clear');
                    for (let i = 1; i <= 8; i++) cell.classList.remove('pre-clear-color-' + i);
                });

                let judgeX = x, judgeY = y;
                if (this.draggedShape && this.draggedShape.shapeWithColors) {
                    const el = this.draggedShape.element;
                    const left = parseFloat(el.style.left);
                    const top = parseFloat(el.style.top);
                    judgeX = left + el.offsetWidth / 2;
                    judgeY = top + el.offsetHeight / 2;
                }
                // shape pattern anchor（中心）
                if (!this.draggedShape || !this.draggedShape.shapeWithColors || !this.draggedShape.shapeWithColors.pattern) return;
                const pattern = this.draggedShape.shapeWithColors.pattern;
                const anchorOffsetX = pattern[0].length / 2;
                const anchorOffsetY = pattern.length / 2;
                const cellSize = gridRect.width / this.gridSize;
                // 让shape中心对准鼠标/视觉中心，支持半格
                const anchorGridX = Math.round((judgeX - gridRect.left) / cellSize - anchorOffsetX + 0.5);
                const anchorGridY = Math.round((judgeY - gridRect.top) / cellSize - anchorOffsetY + 0.5);

                // 搜索1格范围内所有可放置点，选最近的
                let minDist = Infinity;
                let bestPos = null;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const gx = anchorGridX + dx;
                        const gy = anchorGridY + dy;
                        if (gx >= 0 && gx < this.gridSize && gy >= 0 && gy < this.gridSize) {
                            if (this.canPlaceShape(pattern, gy, gx)) {
                                // 计算shape中心点落在盘面上的实际像素坐标
                                const gridCenterX = gridRect.left + (gx + anchorOffsetX) * cellSize;
                                const gridCenterY = gridRect.top + (gy + anchorOffsetY) * cellSize;
                                const dist = Math.hypot(judgeX - gridCenterX, judgeY - gridCenterY);
                                if (dist < minDist) {
                                    minDist = dist;
                                    bestPos = {gx, gy};
                                }
                            }
                        }
                    }
                }
                this._currentProjection = null;
                if (bestPos) {
                    this.highlightShape(pattern, bestPos.gy, bestPos.gx, true);
                    this._currentProjection = {gx: bestPos.gx, gy: bestPos.gy};

                    // 预消除高亮：模拟落块，查找消除区域
                    const tempGrid = this.grid.map(row => row.slice());
                    // 模拟放置 shape
                    for (let r = 0; r < pattern.length; r++) {
                        for (let c = 0; c < pattern[r].length; c++) {
                            if (pattern[r][c]) {
                                const gridRow = bestPos.gy + r;
                                const gridCol = bestPos.gx + c;
                                if (gridRow >= 0 && gridRow < this.gridSize && gridCol >= 0 && gridCol < this.gridSize) {
                                    tempGrid[gridRow][gridCol] = this.draggedShape.shapeWithColors.colors[r][c];
                                }
                            }
                        }
                    }
                    // 用 findConnectedGroupsOnGrid 查找消除区域
                    const cellsToRemove = this.findConnectedGroupsOnGrid(tempGrid);
                    if (cellsToRemove.length > 0) {
                        // 高亮这些 cell
                        cellsToRemove.forEach(({row, col}) => {
                            const cellIndex = row * this.gridSize + col;
                            const cell = cells[cellIndex];
                            cell.classList.add('pre-clear');
                            // 先移除所有颜色高亮
                            for (let i = 1; i <= 8; i++) cell.classList.remove('pre-clear-color-' + i);
                            // 取该cell颜色
                            const color = tempGrid[row][col];
                            if (color) cell.classList.add('pre-clear-color-' + color);
                        });
                    }
                }
            }

            highlightShape(shape, startRow, startCol, valid) {
                // 只负责渲染投影，不再清理
                const cells = document.getElementById('grid').children;
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[r].length; c++) {
                        if (shape[r][c]) {
                            const gridRow = startRow + r;
                            const gridCol = startCol + c;
                            if (gridRow >= 0 && gridRow < this.gridSize && gridCol >= 0 && gridCol < this.gridSize) {
                                const cellIndex = gridRow * this.gridSize + gridCol;
                                const cell = cells[cellIndex];
                                if (valid) {
                                    // 只加 projection 和 color-x，不加 filled
                                    cell.classList.remove('highlight', 'invalid', 'projection');
                                    for (let i = 1; i <= 8; i++) cell.classList.remove('color-' + i);
                                    cell.classList.add('projection');
                                    const color = this.draggedShape.shapeWithColors.colors[r][c];
                                    if (color) cell.classList.add('color-' + color);
                                    cell.style.opacity = '0.5';
                                } else {
                                    cell.classList.add('invalid');
                                }
                            }
                        }
                    }
                }
            }

            handleMouseUp(e) {
                if (this.draggedShape) {
                    this.handleDrop(e.clientX, e.clientY);
                }
                
                // 检查是否有待处理的死亡检测
                if (this.pendingGameOverCheck) {
                    this.pendingGameOverCheck = false;
                    // 延迟一帧执行，确保拖拽状态已完全清理
                    requestAnimationFrame(() => {
                        this.performGameOverCheck();
                    });
                }
            }

            handleTouchEnd(e) {
                if (this.draggedShape) {
                    const touch = e.changedTouches[0];
                    this.handleDrop(touch.clientX, touch.clientY);
                }
                
                // 检查是否有待处理的死亡检测
                if (this.pendingGameOverCheck) {
                    this.pendingGameOverCheck = false;
                    // 延迟一帧执行，确保拖拽状态已完全清理
                    requestAnimationFrame(() => {
                        this.performGameOverCheck();
                    });
                }
            }

            handleDrop(x, y) {
                const gridElement = document.getElementById('grid');
                const gridRect = gridElement.getBoundingClientRect();
                const cellSize = gridRect.width / this.gridSize;
                let judgeX = x, judgeY = y;
                if (this.draggedShape) {
                    // 使用 shape-grid 的精确几何，避免容器 padding/transform 影响
                    const el = this.draggedShape.element;
                    const grid = el.querySelector('.shape-grid');
                    const gridRect = grid ? grid.getBoundingClientRect() : el.getBoundingClientRect();
                    judgeX = gridRect.left + gridRect.width / 2;
                    judgeY = gridRect.top + gridRect.height / 2;
                }
                if (this.draggedShape) {
                    // 使用 shape-grid 的精确几何，避免容器 padding/transform 影响
                    const el = this.draggedShape.element;
                    const grid = el.querySelector('.shape-grid');
                    const gridRect = grid ? grid.getBoundingClientRect() : el.getBoundingClientRect();
                    judgeX = gridRect.left + gridRect.width / 2;
                    judgeY = gridRect.top + gridRect.height / 2;
                }
                // 优先用投影点
                let placed = false;
                if (this._currentProjection) {
                    const {gx, gy} = this._currentProjection;
                    if (this.canPlaceShape(this.draggedShape.shapeWithColors.pattern, gy, gx)) {
                        this.placeShape(this.draggedShape.shapeWithColors.pattern, this.draggedShape.shapeWithColors.colors, gy, gx);
                        this.removeShapeById(this.draggedShape.id);
                        placed = true;
                    }
                }
                this._currentProjection = null;
                this.cleanupDrag(placed);
                if (placed) {
                    this.clearLines();
                    this.updateGrid();
                    this.updateScore();
                    const remainingShapes = this.currentShapes.filter(s => s !== null);
                    if (remainingShapes.length === 0) {
                        // 先切换轮次
                        this.lastRoundEliminated = this.thisRoundEliminated;
                        this.thisRoundEliminated = false;
                        this.blocksUsedInRound = 0;
                        // 再判断是否需要归零combo
                        console.log('判定归零', this.thisRoundEliminated, this.lastRoundEliminated);
                        if (!this.thisRoundEliminated && !this.lastRoundEliminated) {
                            this.comboCount = 0;
                            this.comboMultiplier = 1 + 0.5 * this.comboCount;
                            this.updateCombo();
                        }
                        this.generateShapes();
                    }
                    // 延迟死亡检测，给玩家操作时间
                    this.checkGameOverWithDelay();
                    // 自动保存游戏
                    this.autoSave();
                } /*else {
                    this.comboMultiplier = Math.max(1, this.comboMultiplier - 0.2);
                    this.updateCombo();
                }*/
            }

            cleanupDrag(placed) {
                const element = this.draggedShape.element;
                if (placed) {
                    if (element.parentNode) {
                        element.parentNode.removeChild(element);
                    }
                } else {
                    element.classList.remove('dragging');
                    element.style.position = '';
                    element.style.left = '';
                    element.style.top = '';
                    element.style.zIndex = '';
                    element.style.pointerEvents = '';
                    // 恢复到原来的 slot
                    const slot = document.getElementById(`shape-slot-${this.draggedShape.slotIndex}`);
                    slot.appendChild(element);
                    // 恢复为slot缩放
                    const grid = element.querySelector('.shape-grid');
                    const shapeWithColors = this.draggedShape.shapeWithColors;
                    // 只对最大边大于4的shape缩放，否则保持原始比例
                    const maxCell = Math.max(shapeWithColors.pattern.length, shapeWithColors.pattern[0].length);
                    const slotSize = 80; // px
                    const cellGap = 2; // gap px
                    let cellSize;
                    if (maxCell > 4) {
                        cellSize = (slotSize - cellGap * (maxCell - 1)) / maxCell;
                        grid.style.width = (cellSize * shapeWithColors.pattern[0].length + cellGap * (shapeWithColors.pattern[0].length - 1)) + 'px';
                        grid.style.height = (cellSize * shapeWithColors.pattern.length + cellGap * (shapeWithColors.pattern.length - 1)) + 'px';
                    } else {
                        cellSize = 20;
                        grid.style.width = (cellSize * shapeWithColors.pattern[0].length + cellGap * (shapeWithColors.pattern[0].length - 1)) + 'px';
                        grid.style.height = (cellSize * shapeWithColors.pattern.length + cellGap * (shapeWithColors.pattern.length - 1)) + 'px';
                    }
                    grid.style.justifySelf = 'center';
                    grid.style.alignSelf = 'center';
                    const cells = grid.querySelectorAll('.shape-cell');
                    cells.forEach(cell => {
                        cell.style.width = cellSize + 'px';
                        cell.style.height = cellSize + 'px';
                    });
                }
                // 清除高亮和 projection
                const cells = document.getElementById('grid').children;
                Array.from(cells).forEach(cell => {
                    cell.classList.remove('highlight', 'invalid', 'projection', 'pre-clear');
                    cell.style.opacity = '';
                    for (let i = 1; i <= 8; i++) cell.classList.remove('pre-clear-color-' + i);
                });
                this.draggedShape = null;
            }

            canPlaceShape(shape, startRow, startCol) {
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[r].length; c++) {
                        if (shape[r][c]) {
                            const gridRow = startRow + r;
                            const gridCol = startCol + c;
                            if (gridRow >= this.gridSize || gridCol >= this.gridSize || 
                                gridRow < 0 || gridCol < 0 || this.grid[gridRow][gridCol]) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            placeShape(pattern, colors, startRow, startCol) {
                playPlaceBlockSound();
                
                // 计算放置的格数
                let placedCells = 0;
                for (let r = 0; r < pattern.length; r++) {
                    for (let c = 0; c < pattern[r].length; c++) {
                        if (pattern[r][c]) {
                            this.grid[startRow + r][startCol + c] = colors[r][c];
                            placedCells++;
                        }
                    }
                }
                
                // 添加放置分：放置块格数 × 1
                const placementScore = placedCells * 1;
                this.score += placementScore;
                
                // 放块位置坐标（用于动效锚点）
                const gridElement = document.getElementById('grid');
                const gridRect = gridElement.getBoundingClientRect();
                const cellSize = gridRect.width / this.gridSize;
                const x = gridRect.left + startCol * cellSize + (pattern[0].length * cellSize) / 2;
                const y = gridRect.top + startRow * cellSize + (pattern.length * cellSize) / 2;
                const placeAnchor = { x, y };
                
                // 暂停放块分的视觉效果与合并逻辑
                this.pendingPlacementScore = 0;
                this.pendingPlacementAnchor = null;
                
                // 新增：统计本轮已用块数
                this.blocksUsedInRound++;
            }

            removeShapeById(id) {
                const idx = this.currentShapes.findIndex(s => s && s.id === id);
                if (idx !== -1) this.currentShapes[idx] = null;
                // 覆盖钩子：后置（可替换通用结果）
                try {
                    if (window.CP8_HOOK && window.CP8_HOOK.enabled && window.CP8_HOOK.position === 'after') {
                        const res = (typeof window.CP8_generateShapes === 'function') ? window.CP8_generateShapes(this) : null;
                        if (Array.isArray(res) && res.length) {
                            this.currentShapes = res.slice(0, 3).map(s => ({ id: this.shapeId++, pattern: s.pattern, colors: s.colors }));
                        }
                    }
                } catch(_) {}
                this.renderShapes();
            }

            clearLines() {
                const cellsToRemove = this.findConnectedGroups();
                
                if (cellsToRemove.length > 0) {
                    this.thisRoundEliminated = true;
                    console.log('本轮有消除，设置thisRoundEliminated为true');
                    // 先获取消除块数和连击次数
                    const eliminatedCount = cellsToRemove.length;
                    const comboCount = this.comboCount || 0; // 使用增量前的连击计数
                    const compositeCue = eliminatedCount + comboCount; // 统一用于配音与激励词
                    playEliminateSound(eliminatedCount, comboCount);
                    this.animateClearance(cellsToRemove);
                    // 语音播报（本地音频）— 使用统一的 compositeCue
                    this.playVoiceForElimination(compositeCue);
                    // 在清除前统计本次消除颜色集合（用于按字符循环上色）
                    const colorNumbers = this.collectColorsFromCells(cellsToRemove);
                    
                    // 清除方块
                    cellsToRemove.forEach(({row, col}) => {
                        this.grid[row][col] = 0;
                    });
                    
                    // 计算分数
                    const baseScore = cellsToRemove.length * 10;
                    // 暂停放块分并入消除分
                    const mergedPlacement = 0;
                    
                    // 先按 comboCount 推导倍率，再计算奖励
                    this.comboMultiplier = 1 + 0.5 * this.comboCount;
                    let bonusScore = 0;
                    if (this.comboMultiplier > 1) {
                        bonusScore = Math.floor(baseScore * (this.comboMultiplier - 1));
                    }
                    
                    this.score += baseScore + bonusScore + mergedPlacement;
                    
                    // 本轮放块分已计入总分；消除时不单独播放放块分动效
                    // 显示合并的消除分（基础分+连击奖励）
                    const totalScore = baseScore + bonusScore + mergedPlacement;
                    // 统一锚点
                    const gridElement = document.getElementById('grid');
                    const gridRect = gridElement.getBoundingClientRect();
                    const cellSize = gridRect.width / this.gridSize;
                    let totalRow = 0, totalCol = 0;
                    cellsToRemove.forEach(({row, col}) => { totalRow += row; totalCol += col; });
                    const centerRow = totalRow / cellsToRemove.length;
                    const centerCol = totalCol / cellsToRemove.length;
                    const anchor = {
                        x: gridRect.left + centerCol * cellSize + cellSize / 2,
                        y: gridRect.top + centerRow * cellSize + cellSize / 2
                    };
                    this.showEliminationScoreWithColor(totalScore, cellsToRemove, anchor, colorNumbers.length ? colorNumbers : (this.dominantColor || 1));
                    // 保持关闭合并逻辑
                    
                    // 显示连击特效（暂时关闭）
                    // if (this.comboMultiplier > 1) {
                    //     const comboCount = Math.round((this.comboMultiplier - 1) / 0.5) + 1;
                    //     this.showComboEffect(comboCount);
                    // }
                    
                    // 消除震动
                    this.vibrateOnElimination(cellsToRemove.length);
                    
                    // 语音播报：消除9格及以上时播报"good"（暂时关闭）
                    // if (cellsToRemove.length >= 9) {
                    //     this.speakGood();
                    // }
                    
                    // 增加 combo 计数（为下次消除做准备）
                    this.comboCount = Math.min(this.comboCount + 1, 8);
                    this.comboMultiplier = 1 + 0.5 * this.comboCount;
                    this.updateCombo();
                    // 显示"Combo N"动效，便于校验
                    const dict = this.getI18n()[this.language] || this.getI18n().zh;
                    const label = (this.language === 'zh' ? '连击' : 'Combo');
                    const text = `${label} ${this.comboCount}`;
                    // 使用本次消除的颜色集合（与加分一致，数组将触发逐字符循环着色）
                    const comboColorSpec = colorNumbers.length ? colorNumbers : (this.dominantColor || 1);
                    // 与激励词、加分共用一个锚点：复用上方计算的 anchor
                    // 上方显示激励词（若存在）使用与配音一致的 compositeCue（连击自增前）
                    if (this.settings && this.settings.motivationEnabled) {
                    const cue = this.getBestVoiceCueId(compositeCue);
                    if (cue) this.addComboText(this.formatVoiceLabel(cue), comboColorSpec, 'top', anchor);
                    }
                    // 中间显示连击提示
                    this.addComboText(text, comboColorSpec, 'center', anchor);
                    // 下方显示加分动效（与上面间距一致）
                    // 让加分颜色与上方文案保持一致
                    this.showEliminationScoreWithColor(totalScore, cellsToRemove, anchor, comboColorSpec);
                }
            }

            // 播放本地激励词语音：根据 VOICE_CUES 中的阈值表选择最强匹配
            playVoiceForElimination(eliminatedCount) {
                try {
                    if (!this.settings || !this.settings.soundEnabled || !this.settings.voiceEnabled) {
                        return;
                    }
                    const now = performance.now();
                    if (now - lastVoicePlayTs < VOICE_COOLDOWN_MS) return;
                    initVoiceAudios();
                    // 选择阈值<=消除数的最大项
                    let chosen = null;
                    for (let i = 0; i < VOICE_CUES.length; i++) {
                        if (eliminatedCount >= VOICE_CUES[i].threshold) {
                            chosen = VOICE_CUES[i];
                        } else {
                            break;
                        }
                    }
                    if (!chosen) return;
                    // 停止所有已加载的语音，避免叠音
                    Object.values(voiceAudioMap).forEach(a => {
                        if (a) {
                            try { a.pause(); a.currentTime = 0; } catch (_) {}
                        }
                    });
                    const target = voiceAudioMap[chosen.id];
                    if (target) {
                        const r = target.play();
                        lastVoicePlayTs = now;
                        if (r && typeof r.catch === 'function') r.catch(() => {});
                    }
                } catch (err) {
                    console.log('语音播放失败:', err);
                }
            }

            findConnectedGroups() {
                const visited = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(false));
                const cellsToRemove = [];
                
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (!visited[row][col] && this.grid[row][col] > 0) {
                            const group = this.getConnectedGroup(row, col, this.grid[row][col], visited);
                            if (group.length >= 8) {
                                cellsToRemove.push(...group);
                            }
                        }
                    }
                }
                
                return cellsToRemove;
            }

            getConnectedGroup(startRow, startCol, color, visited) {
                const stack = [{row: startRow, col: startCol}];
                const group = [];
                const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]; // 右，下，左，上
                
                while (stack.length > 0) {
                    const {row, col} = stack.pop();
                    
                    if (row < 0 || row >= this.gridSize || col < 0 || col >= this.gridSize || 
                        visited[row][col] || this.grid[row][col] !== color) {
                        continue;
                    }
                    
                    visited[row][col] = true;
                    group.push({row, col});
                    
                    // 检查四个方向
                    directions.forEach(([dr, dc]) => {
                        stack.push({row: row + dr, col: col + dc});
                    });
                }
                
                return group;
            }

            animateClearance(cells) {
                const eliminatedCount = cells.length;
                const comboCount = this.comboMultiplier > 1 ? Math.round((this.comboMultiplier - 1) / 0.5) : 0;
                const composite = eliminatedCount + comboCount;
                // 颜色统计逻辑移至 collectColorsFromCells
                
                // 基础闪烁效果（保持现有）
                cells.forEach(({ row, col }) => {
                    const cellIndex = row * this.gridSize + col;
                    const cellElement = document.getElementById('grid').children[cellIndex];
                    // 先移除所有clearing-color-x
                    for (let i = 1; i <= 8; i++) cellElement.classList.remove('clearing-color-' + i);
                    // 获取当前cell颜色
                    const color = this.grid[row][col];
                    if (color) cellElement.classList.add('clearing-color-' + color);
                    cellElement.classList.add('clearing');
                    setTimeout(() => {
                        cellElement.classList.remove('clearing');
                        for (let i = 1; i <= 8; i++) cellElement.classList.remove('clearing-color-' + i);
                    }, 500);
                });
                
                // 分级增强效果
                if (composite >= 16) {
                    // 超大消除（16+块）：强烈效果
                    this.addScreenShake(6, 150); // 强烈震动
                    this.addParticleExplosion(cells, 30); // 大量粒子
                } else if (composite >= 14) {
                    // 大消除（14-15块）：明显效果
                    this.addScreenShake(4, 100); // 明显震动
                    this.addParticleExplosion(cells, 20); // 中等粒子
                } else if (composite >= 12) {
                    // 中消除（12-13块）：轻微效果
                    this.addScreenShake(2, 50); // 轻微震动
                    this.addParticleExplosion(cells, 10); // 少量粒子
                }
                // 小消除（8块）：保持基础效果
            }

            // 选择与本次消除数匹配的最佳语音 cue id
            getBestVoiceCueId(eliminatedCount) {
                let chosen = null;
                for (let i = 0; i < VOICE_CUES.length; i++) {
                    if (eliminatedCount >= VOICE_CUES[i].threshold) {
                        chosen = VOICE_CUES[i].id;
                    } else {
                        break;
                    }
                }
                return chosen;
            }

            // 将 cue id 转为展示文案
            formatVoiceLabel(id) {
                const special = {
                    goodjob: 'GOOD JOB',
                    welldone: 'WELL DONE'
                };
                if (special[id]) return special[id];
                return id.replace(/[-_]/g, ' ').toUpperCase();
            }
            
            // 新增：屏幕震动效果
            addScreenShake(intensity, duration) {
                const gameBoard = document.querySelector('.game-board');
                const originalTransform = gameBoard.style.transform;
                
                // 创建震动动画
                let shakeCount = 0;
                const maxShakes = Math.floor(duration / 20); // 每50ms一次震动
                
                const shake = () => {
                    if (shakeCount >= maxShakes) {
                        gameBoard.style.transform = originalTransform;
                        return;
                    }
                    
                    const x = (Math.random() - 0.5) * intensity;
                    const y = (Math.random() - 0.5) * intensity;
                    gameBoard.style.transform = `translate(${x}px, ${y}px)`;
                    
                    shakeCount++;
                    setTimeout(shake, 50);
                };
                
                shake();
            }
            
            // 新增：粒子爆炸效果
            addParticleExplosion(cells, particleCount) {
                const gameBoard = document.querySelector('.game-board');
                const rect = gameBoard.getBoundingClientRect();
                
                // 计算消除区域中心
                let centerX = 0, centerY = 0;
                cells.forEach(({ row, col }) => {
                    const cellIndex = row * this.gridSize + col;
                    const cellElement = document.getElementById('grid').children[cellIndex];
                    const cellRect = cellElement.getBoundingClientRect();
                    centerX += cellRect.left + cellRect.width / 2;
                    centerY += cellRect.top + cellRect.height / 2;
                });
                centerX /= cells.length;
                centerY /= cells.length;
                
                // 创建粒子
                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    
                    // 随机运动方向和距离
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 50 + Math.random() * 100;
                    const endX = Math.cos(angle) * distance;
                    const endY = Math.sin(angle) * distance;
                    
                    particle.style.cssText = `
                        position: fixed;
                        left: ${centerX}px;
                        top: ${centerY}px;
                        width: 4px;
                        height: 4px;
                        background: ${this.getRandomParticleColor()};
                        border-radius: 50%;
                        pointer-events: none;
                        z-index: 1000;
                        --x: ${endX}px;
                        --y: ${endY}px;
                        animation: particleExplosion 0.8s ease-out forwards;
                    `;
                    
                    document.body.appendChild(particle);
                    
                    // 清理粒子
                    setTimeout(() => {
                        if (particle.parentNode) {
                            particle.parentNode.removeChild(particle);
                        }
                    }, 800);
                }
            }
            
            // 新增：连击文字效果
            addComboText(text, colorSpec = 0, position = 'center', anchor = null) {
                const gameBoard = document.querySelector('.game-board');
                const rect = gameBoard.getBoundingClientRect();
                // 计算锚点：优先使用传入的格子中心坐标，否则使用棋盘中心
                const baseX = anchor && anchor.x ? anchor.x : (rect.left + rect.width / 2);
                const baseY = anchor && anchor.y ? anchor.y : (rect.top + rect.height / 2);
                let yOffset = 0;
                let fontSize = 36;
                if (position === 'top') { yOffset = -46; fontSize = 42; }
                else if (position === 'bottom') { yOffset = 40; fontSize = 28; }
                else { fontSize = 34; }

                const comboText = document.createElement('div');
                comboText.className = 'combo-text';
                comboText.textContent = text;
                comboText.style.cssText = `
                    position: fixed;
                    left: ${baseX}px;
                    top: ${baseY + yOffset}px;
                    transform: translate(-50%, -50%);
                    font-size: ${fontSize}px;
                    font-weight: bold;
                    color: ${this.getColorByNumber(typeof colorSpec === 'number' ? colorSpec : 0) || '#ff6b6b'};
                    text-shadow: 2px 2px 4px rgba(0,0,0,0.45);
                    pointer-events: none;
                    z-index: 1001;
                    animation: comboText 0.8s ease-out forwards;
                `;

                // 应用颜色：数组则按字符轮换，多色循环；单色则直接着色
                if (Array.isArray(colorSpec)) {
                    this.applyPerCharColoring(comboText, text, colorSpec);
                } else {
                    this.applyTextColorStyle(comboText, colorSpec);
                }

                document.body.appendChild(comboText);

                // 清理文字
                setTimeout(() => {
                    if (comboText.parentNode) {
                        comboText.parentNode.removeChild(comboText);
                    }
                }, 800);
            }
            
            // 统计一组被消除格子的颜色，按数量降序返回颜色编号数组
            collectColorsFromCells(cells) {
                const counts = {};
                try {
                    cells.forEach(({ row, col }) => {
                        const color = this.grid[row][col];
                        if (color > 0) counts[color] = (counts[color] || 0) + 1;
                    });
                } catch (_) {}
                const entries = Object.entries(counts).sort((a, b) => b[1] - a[1]);
                return entries.map(e => parseInt(e[0]));
            }

            // 从一次消除的格子中选定"主导颜色"：块数最多；若并列则随机
            getDominantColorFromCells(cells) {
                    const counts = {};
                try {
                    cells.forEach(({ row, col }) => {
                        const color = this.grid[row][col];
                        if (color > 0) counts[color] = (counts[color] || 0) + 1;
                    });
                } catch (_) {}
                let max = 0;
                let candidates = [];
                    Object.keys(counts).forEach(k => {
                    const v = counts[k];
                    if (v > max) { max = v; candidates = [parseInt(k)]; }
                    else if (v === max) { candidates.push(parseInt(k)); }
                });
                if (candidates.length === 0) return this.dominantColor || 1;
                if (candidates.length === 1) return candidates[0];
                return candidates[Math.floor(Math.random() * candidates.length)];
            }

            // 将颜色规格（单个编号/数组/字符串）应用到文字元素
            applyTextColorStyle(el, colorSpec) {
                try {
                    // 数组：多色渐变
                    if (Array.isArray(colorSpec)) {
                        // 使用"每个编号的主色"做渐变（避免多重端点造成偏色）
                        const palette = colorSpec
                            .filter(n => typeof n === 'number' && n > 0)
                            .map(n => this.getColorByNumber(n));
                        if (palette.length === 0) return;
                        // 去重连续相同色，避免条纹
                        const dedup = [palette[0]];
                        for (let i = 1; i < palette.length; i++) {
                            if (palette[i] !== dedup[dedup.length - 1]) dedup.push(palette[i]);
                        }
                        if (dedup.length === 1) {
                            el.style.background = '';
                            el.style.webkitBackgroundClip = '';
                            el.style.backgroundClip = '';
                            el.style.color = dedup[0];
                            return;
                        }
                        // 等分分布颜色停点，避免"断层"
                        const stops = dedup.map((c, i) => {
                            const p = Math.round((i / (dedup.length - 1)) * 100);
                            return `${c} ${p}%`;
                        });
                        // 简化到两个主色时，直接在 45° 做双端渐变
                        // 两色时，稍微提高最暗端的亮度避免整体偏暗
                        const gradient = dedup.length === 2
                            ? `linear-gradient(45deg, ${dedup[0]} 0%, ${dedup[1]} 100%)`
                            : `linear-gradient(45deg, ${stops.join(', ')})`;
                        el.style.background = gradient;
                        el.style.webkitBackgroundClip = 'text';
                        el.style.backgroundClip = 'text';
                        el.style.color = 'transparent';
                        return;
                    }
                    // 字符串：直接使用（可为渐变）
                    if (typeof colorSpec === 'string') {
                        if (colorSpec.startsWith('linear-gradient')) {
                            el.style.background = colorSpec;
                            el.style.webkitBackgroundClip = 'text';
                            el.style.backgroundClip = 'text';
                            el.style.color = 'transparent';
                    } else {
                            el.style.background = '';
                            el.style.webkitBackgroundClip = '';
                            el.style.backgroundClip = '';
                            el.style.color = colorSpec;
                        }
                        return;
                    }
                    // 数字：单色
                    if (typeof colorSpec === 'number') {
                        const c = this.getColorByNumber(colorSpec);
                        el.style.background = '';
                        el.style.webkitBackgroundClip = '';
                        el.style.backgroundClip = '';
                        el.style.color = c;
                    }
                } catch (_) {}
            }

            // 新增：按字符循环着色（用于多色消除时的文字）
            applyPerCharColoring(el, text, palette) {
                try {
                    const colors = (palette || [])
                        .map(c => (typeof c === 'number' ? this.getColorByNumber(c) : c))
                        .filter(Boolean);
                    if (colors.length === 0) { el.textContent = text; return; }
                    el.innerHTML = '';
                    const start = Math.floor(Math.random() * colors.length);
                    for (let i = 0; i < text.length; i++) {
                        const ch = text[i];
                        const span = document.createElement('span');
                        span.textContent = ch;
                        if (ch.trim() !== '') {
                            span.style.color = colors[(start + i) % colors.length];
                        }
                        el.appendChild(span);
                    }
                } catch (_) {
                    el.textContent = text;
                }
            }
            
            // 新增：获取随机粒子颜色
            getRandomParticleColor() {
                // 从主色表随机取一个端点色
                const ids = Object.keys(COLOR_STYLES);
                const id = ids[Math.floor(Math.random() * ids.length)];
                const pair = COLOR_STYLES[id];
                return pair[Math.floor(Math.random() * pair.length)] || '#ffd700';
            }
            
            getColorByNumber(colorNumber) {
                // 返回该编号用于"文字"的主色：选择更亮的一端
                const pair = COLOR_STYLES[colorNumber];
                if (pair && pair.length) return pickTextPrimaryColor(pair);
                return '#ffffff';
            }
            
            loadSettings() {
                const defaultSettings = {
                    soundEnabled: true,    // 音效开启
                    vibrationEnabled: true, // 震动开启
                    voiceEnabled: WX_MINIPROGRAM_MODE ? false : true,    // 小程序关闭配音
                    motivationEnabled: WX_MINIPROGRAM_MODE ? false : true, // 小程序关闭英文激励词
                    language: WX_MINIPROGRAM_MODE ? 'zh' : 'en'         // 小程序强制中文
                };
                
                try {
                    const savedSettings = localStorage.getItem('blockBlastSettings');
                    if (savedSettings) {
                        const merged = { ...defaultSettings, ...JSON.parse(savedSettings) };
                        if (WX_MINIPROGRAM_MODE) {
                            merged.language = 'zh';
                            merged.voiceEnabled = false;
                            merged.motivationEnabled = false;
                        }
                        return merged;
                    }
                } catch (error) {
                    console.log('加载设置失败:', error);
                }
                
                return defaultSettings;
            }
            
            saveSettings() {
                try {
                    localStorage.setItem('blockBlastSettings', JSON.stringify(this.settings));
                } catch (error) {
                    console.log('保存设置失败:', error);
                }
            }
            
            updateSetting(key, value) {
                this.settings[key] = value;
                this.saveSettings();
                if (key === 'language') {
                    this.language = value;
                    this.applyLanguage();
                }
            }

            // 多语言词条
            getI18n() {
                return {
                    zh: {
                        combo: '连击',
                        gameOver: '游戏结束',
                        finalScore: '分数',
                        highScore: '最高分',
                        restart: '重新开始',
                        settings: '设置',
                        sound: '音效',
                        vibration: '震动',
                        voice: '语音播报',
                        language: '语言',
                        privacy: '隐私政策',
                        confirm: '确定'
                    },
                    en: {
                        combo: 'Combo',
                        gameOver: 'Game Over',
                        finalScore: 'Score',
                        highScore: 'Best',
                        restart: 'Restart',
                        settings: 'Settings',
                        sound: 'Sound',
                        vibration: 'Vibration',
                        voice: 'Voice',
                        language: 'Language',
                        privacy: 'Privacy Policy',
                        confirm: 'OK'
                    }
                };
            }

            // 应用语言到界面文本
            applyLanguage() {
                const dict = this.getI18n()[this.language] || this.getI18n().zh;
                const el = (id) => document.getElementById(id);
                const setText = (id, text) => { const n = el(id); if (n) n.textContent = text; };
                setText('combo-text', dict.combo);
                setText('game-over-title', dict.gameOver);
                setText('final-score-label', dict.finalScore);
                setText('high-score-label', dict.highScore);
                const restartBtn = el('restart-btn'); if (restartBtn) restartBtn.textContent = dict.restart;
                setText('settings-title', dict.settings);
                setText('sound-label', dict.sound);
                setText('vibration-label', dict.vibration);
                setText('voice-label', dict.voice);
                setText('language-label', dict.language);
                setText('privacy-link', dict.privacy);
                // 设置弹窗的"确定"按钮
                const settingsContent = document.querySelector('.settings-content button');
                if (settingsContent) settingsContent.textContent = dict.confirm;
                // 设置语言选择框
                const langSelect = document.getElementById('language-select');
                if (langSelect) langSelect.value = this.language;
            }

            updateGrid() {
                const cells = document.getElementById('grid').children;
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const cellIndex = row * this.gridSize + col;
                        const cell = cells[cellIndex];
                        
                        // 清除所有颜色类
                        cell.classList.remove('filled', 'color-1', 'color-2', 'color-3', 'color-4', 'color-5', 'color-6', 'color-7', 'color-8');
                        
                        if (this.grid[row][col] > 0) {
                            cell.classList.add('filled', `color-${this.grid[row][col]}`);
                        }
                    }
                }
            }

            updateScore() {
                // 分数递增动画
                if (scoreAnimationFrame) cancelAnimationFrame(scoreAnimationFrame);
                const targetScore = this.score;
                const step = () => {
                    if (displayScore === targetScore) return;
                    // 计算步长，跨度大时加快动画
                    let diff = targetScore - displayScore;
                    let delta = Math.ceil(Math.abs(diff) / 10);
                    if (diff > 0) {
                        displayScore = Math.min(displayScore + delta, targetScore);
                    } else {
                        displayScore = Math.max(displayScore - delta, targetScore);
                    }
                    document.getElementById('score').textContent = displayScore;
                    if (displayScore !== targetScore) {
                        scoreAnimationFrame = requestAnimationFrame(step);
                    }
                };
                step();
            }

            updateCombo() {
                document.getElementById('combo').textContent = `x${this.comboMultiplier.toFixed(1)}`;
            }

            showComboBonus(bonus) {
                // 使用消除分的动效显示连击奖励
                this.showEliminationScore(bonus, '连击奖励!');
            }
            
            showEliminationScore(score, cellsToRemove = null, anchor = null) {
                const scoreElement = document.createElement('div');
                scoreElement.className = 'elimination-score';
                scoreElement.textContent = `+${score}`; // 恢复加号
                // 使用 fixed 定位到视窗，统一与其他提示一致
                document.body.appendChild(scoreElement);
                
                // 如果有消除位置信息，计算显示位置
                if (anchor && typeof anchor.x === 'number' && typeof anchor.y === 'number') {
                    const x = anchor.x;
                    const y = anchor.y + 46; // 与上方激励词和中间连击的间距一致
                    scoreElement.style.left = x + 'px';
                    scoreElement.style.top = y + 'px';
                    scoreElement.style.transform = 'translate(-50%, -50%)';
                    scoreElement.style.fontSize = '26px';
                } else if (Array.isArray(cellsToRemove) && cellsToRemove.length > 0) {
                    let totalRow = 0, totalCol = 0;
                    cellsToRemove.forEach(({row, col}) => {
                        totalRow += row;
                        totalCol += col;
                    });
                    const centerRow = totalRow / cellsToRemove.length;
                    const centerCol = totalCol / cellsToRemove.length;
                    const gridElement = document.getElementById('grid');
                    const gridRect = gridElement.getBoundingClientRect();
                    const cellSize = gridRect.width / this.gridSize;
                    const x = gridRect.left + centerCol * cellSize + cellSize / 2;
                    const y = gridRect.top + centerRow * cellSize + cellSize / 2 + 46; // 与激励词/连击的间距一致
                    scoreElement.style.left = x + 'px';
                    scoreElement.style.top = y + 'px';
                    scoreElement.style.transform = 'translate(-50%, -50%)';
                    scoreElement.style.fontSize = '26px';
                }
                setTimeout(() => {
                    if (scoreElement.parentNode) {
                        scoreElement.parentNode.removeChild(scoreElement);
                    }
                }, 1000);
            }

            // 同步颜色版：传入具体颜色
            showEliminationScoreWithColor(score, cellsToRemove = null, anchor = null, colorSpec = '#ffd700') {
                const el = document.createElement('div');
                el.className = 'elimination-score';
                el.textContent = `+${score}`;
                // 默认按单色变量走动画
                if (!Array.isArray(colorSpec) && typeof colorSpec === 'string' && !colorSpec.startsWith('linear-gradient')) {
                    el.style.setProperty('--elim-color', colorSpec);
                }
                document.body.appendChild(el);

                if (anchor && typeof anchor.x === 'number' && typeof anchor.y === 'number') {
                    const x = anchor.x;
                    const y = anchor.y + 46;
                    el.style.left = x + 'px';
                    el.style.top = y + 'px';
                    el.style.transform = 'translate(-50%, -50%)';
                    el.style.fontSize = '26px';
                } else if (Array.isArray(cellsToRemove) && cellsToRemove.length > 0) {
                    let totalRow = 0, totalCol = 0;
                    cellsToRemove.forEach(({row, col}) => { totalRow += row; totalCol += col; });
                    const centerRow = totalRow / cellsToRemove.length;
                    const centerCol = totalCol / cellsToRemove.length;
                    const gridElement = document.getElementById('grid');
                    const gridRect = gridElement.getBoundingClientRect();
                    const cellSize = gridRect.width / this.gridSize;
                    const x = gridRect.left + centerCol * cellSize + cellSize / 2;
                    const y = gridRect.top + centerRow * cellSize + cellSize / 2 + 46;
                    el.style.left = x + 'px';
                    el.style.top = y + 'px';
                    el.style.transform = 'translate(-50%, -50%)';
                    el.style.fontSize = '26px';
                }
                // 应用单色或按字符循环色（覆盖默认颜色变量）
                if (Array.isArray(colorSpec)) {
                    this.applyPerCharColoring(el, `+${score}` , colorSpec);
                } else {
                    this.applyTextColorStyle(el, colorSpec);
                }
                // 渐变/多色时阴影容易压暗，保持较轻
                el.style.textShadow = '2px 2px 4px rgba(0,0,0,0.35)';
                setTimeout(() => { if (el.parentNode) el.parentNode.removeChild(el); }, 1000);
            }
            
            showComboEffect(comboCount) {
                if (comboCount < 2) return; // 只有2连击以上才显示
                
                // 创建连击特效元素
                const comboElement = document.createElement('div');
                comboElement.className = 'combo-effect';
                comboElement.textContent = `${comboCount}连击！`;
                
                // 直接添加到body，确保绝对定位正确
                document.body.appendChild(comboElement);
                
                // 屏幕震动效果
                this.shakeScreen(comboCount);
                
                // 1.2秒后移除
                setTimeout(() => {
                    if (comboElement.parentNode) {
                        comboElement.parentNode.removeChild(comboElement);
                    }
                }, 1200);
            }
            
            shakeScreen(comboCount) {
                const gamePanel = document.querySelector('.game-panel');
                const intensity = Math.min(comboCount * 2, 10); // 连击数越高震动越强，最大10px
                
                // 添加震动动画
                gamePanel.style.animation = `screenShake 0.3s ease-in-out`;
                
                // 移除动画类
                setTimeout(() => {
                    gamePanel.style.animation = '';
                }, 300);
                
                // 设备震动
                this.vibrateDevice(comboCount);
            }
            
            vibrateDevice(comboCount) {
                // 检查设置是否开启震动
                if (!this.settings.vibrationEnabled) {
                    return;
                }
                
                // 检查是否支持震动API
                if ('vibrate' in navigator) {
                    try {
                        // 根据连击数设置震动模式
                        let vibrationPattern;
                        if (comboCount >= 5) {
                            // 5连击以上：强烈震动
                            vibrationPattern = [100, 50, 100, 50, 100, 50, 200];
                        } else if (comboCount >= 3) {
                            // 3-4连击：中等震动
                            vibrationPattern = [80, 40, 80, 40, 150];
                        } else {
                            // 2连击：轻微震动
                            vibrationPattern = [50, 30, 100];
                        }
                        
                        navigator.vibrate(vibrationPattern);
                        console.log('设备震动:', vibrationPattern);
                    } catch (error) {
                        console.log('震动失败:', error);
                    }
                } else {
                    console.log('设备不支持震动');
                }
            }
            
            vibrateOnElimination(eliminatedCount) {
                // 检查设置是否开启震动
                if (!this.settings.vibrationEnabled) {
                    return;
                }
                
                // 检查是否支持震动API
                if ('vibrate' in navigator) {
                    try {
                        // 根据消除数量设置震动强度
                        let vibrationPattern;
                        if (eliminatedCount >= 20) {
                            // 大量消除：强烈震动
                            vibrationPattern = [120, 60, 120, 60, 120, 60, 250];
                        } else if (eliminatedCount >= 12) {
                            // 中等消除：中等震动
                            vibrationPattern = [80, 40, 80, 40, 150];
                        } else {
                            // 少量消除：轻微震动
                            vibrationPattern = [40, 20, 80];
                        }
                        
                        navigator.vibrate(vibrationPattern);
                        console.log('消除震动:', vibrationPattern);
                    } catch (error) {
                        console.log('震动失败:', error);
                    }
                }
            }
            
            speakGood() {
                // 检查设置是否开启语音播报
                if (!this.settings.voiceEnabled) {
                    return;
                }
                
                // 检查是否支持语音合成
                if ('speechSynthesis' in window) {
                    try {
                        // 停止当前正在播放的语音
                        speechSynthesis.cancel();
                        
                        // 创建语音合成对象
                        const utterance = new SpeechSynthesisUtterance('good');
                        
                        // 设置语音参数
                        utterance.lang = 'en-US';        // 英语
                        utterance.rate = 0.8;            // 语速稍慢，更有力量感
                        utterance.pitch = 0.7;           // 音调较低，成熟男音
                        utterance.volume = 0.9;          // 音量适中
                        
                        // 尝试选择男声
                        const voices = speechSynthesis.getVoices();
                        const maleVoice = voices.find(voice => 
                            voice.lang.includes('en') && 
                            voice.name.toLowerCase().includes('male')
                        );
                        
                        if (maleVoice) {
                            utterance.voice = maleVoice;
                        }
                        
                        // 播放语音
                        speechSynthesis.speak(utterance);
                        
                        console.log('语音播报: good');
                    } catch (error) {
                        console.log('语音播报失败:', error);
                    }
                } else {
                    console.log('浏览器不支持语音合成');
                }
            }
            
            showPlacementScore(score) {
                // 旧函数保留占位，不再使用
            }

            // 新：仅放置得分的灰白小字动效（无消除时显示）
            showPlacementOnlyScore(score, anchor) {
                if (!score || !anchor) return;
                const el = document.createElement('div');
                el.className = 'placement-score';
                el.textContent = `+${score}`;
                el.style.left = anchor.x + 'px';
                el.style.top = anchor.y + 'px';
                el.style.transform = 'translate(-50%, -50%)';
                document.body.appendChild(el);
                setTimeout(() => { if (el.parentNode) el.parentNode.removeChild(el); }, 600);
            }

            isGameOver() {
                const remainingShapes = this.currentShapes.filter(s => s !== null);
                if (remainingShapes.length === 0) return false;

                return !remainingShapes.some(shapeWithColor => {
                    for (let row = 0; row < this.gridSize; row++) {
                        for (let col = 0; col < this.gridSize; col++) {
                            if (this.canPlaceShape(shapeWithColor.pattern, row, col)) {
                                return true;
                            }
                        }
                    }
                    return false;
                });
            }
            
            // 检查死亡时考虑拖拽中的方块
            isGameOverWithDraggedShape() {
                const remainingShapes = this.currentShapes.filter(s => s !== null);
                if (remainingShapes.length === 0) return false;
                
                // 如果有拖拽中的方块，将其加入检测
                const shapesToCheck = [...remainingShapes];
                if (this.draggedShape && this.draggedShape.shapeWithColors) {
                    shapesToCheck.push(this.draggedShape.shapeWithColors);
                }

                return !shapesToCheck.some(shapeWithColor => {
                    for (let row = 0; row < this.gridSize; row++) {
                        for (let col = 0; col < this.gridSize; col++) {
                            if (this.canPlaceShape(shapeWithColor.pattern, row, col)) {
                                return true;
                            }
                        }
                    }
                    return false;
                });
            }
            
            checkGameOverWithDelay() {
                // 清除之前的延迟检测
                if (this.gameOverCheckTimeout) {
                    clearTimeout(this.gameOverCheckTimeout);
                    this.gameOverCheckTimeout = null;
                }
                
                // 延迟1秒后检测死亡
                this.gameOverCheckTimeout = setTimeout(() => {
                    this.gameOverCheckTimeout = null;
                    this.performGameOverCheck();
                }, 1000);
            }
            
            performGameOverCheck() {
                // 防止重复检测
                if (this.isPerformingGameOverCheck) {
                    return;
                }
                
                this.isPerformingGameOverCheck = true;
                
                try {
                    // 如果正在拖拽，等待玩家松手
                    if (this.draggedShape) {
                        // 设置一个标记，在松手时检查
                        this.pendingGameOverCheck = true;
                        return;
                    }
                    
                    // 检查死亡（考虑拖拽中的方块）
                    if (this.isGameOverWithDraggedShape()) {
                        // 死亡判定通过，开始死亡动画
                        this.startDeathAnimation();
                    }
                } finally {
                    this.isPerformingGameOverCheck = false;
                }
            }
            
            // 新增：死亡动画启动函数
            startDeathAnimation() {
                if (this.isDeathAnimationPlaying) {
                    return;
                }
                this.isDeathAnimationPlaying = true;
                
                // 直接开始盘面填满动画
                this.fillGridDirectly();
            }
            
            // 新增：盘面填满动画
            fillGridDirectly() {
                // 找到所有空位置
                const emptyPositions = [];
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (this.grid[row][col] === 0) {
                            emptyPositions.push({row, col});
                        }
                    }
                }
                // 若无空位（棋盘已满），直接完成死亡流程并播放BGM
                if (emptyPositions.length === 0) {
                    try { this.playDescendingBGM(); } catch(_) {}
                    setTimeout(() => { this.onDeathAnimationComplete(); }, 300);
                    return;
                }
                
                // 随机打乱空位置顺序
                for (let i = emptyPositions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [emptyPositions[i], emptyPositions[j]] = [emptyPositions[j], emptyPositions[i]];
                }
                
                // 逐格填满
                emptyPositions.forEach(({row, col}, index) => {
                    setTimeout(() => {
                        // 使用全颜色池
                        const fullColorPool = [1, 2, 3, 4, 5, 6, 7, 8];
                        const randomColor = fullColorPool[Math.floor(Math.random() * fullColorPool.length)];
                        this.grid[row][col] = randomColor;
                        this.updateGrid();
                        
                        // 播放填满音效
                        this.playFillSound();
                        
                        // 最后一个方块填满后，完成死亡动画
                        if (index === emptyPositions.length - 1) {
                            setTimeout(() => {
                                this.onDeathAnimationComplete();
                            }, 500);
                        }
                    }, index * 50);
                });
                
                // 播放降调BGM
                this.playDescendingBGM();
            }
            
            // 新增：死亡动画完成回调
            onDeathAnimationComplete() {
                this.isDeathAnimationPlaying = false;
                this.deathAnimationStage = 0;
                this.deathAnimationTimeouts.forEach(timeout => clearTimeout(timeout));
                this.deathAnimationTimeouts = [];
                
                // 结束游戏
                this.endGame();
            }
            
            // 新增：清理死亡动画状态
            clearDeathAnimation() {
                this.isDeathAnimationPlaying = false;
                this.deathAnimationStage = 0;
                this.deathAnimationTimeouts.forEach(timeout => clearTimeout(timeout));
                this.deathAnimationTimeouts = [];
                
                // 移除相关CSS类
                const gameBoard = document.querySelector('.game-board');
                if (gameBoard) {
                    gameBoard.classList.remove('fill-grid');
                }
            }
            
            // 新增：播放填满音效
            playFillSound() {
                if (!this.settings.soundEnabled) return;
                
                // 播放清脆的填满音效
                const duration = 0.1;
                const bufferSize = audioCtx.sampleRate * duration;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    // 清脆的"叮"声
                    const t = i / audioCtx.sampleRate;
                    data[i] = Math.sin(2 * Math.PI * 800 * t) * Math.exp(-t * 10) * 0.07;
                }
                
                const source = audioCtx.createBufferSource();
                source.buffer = buffer;
                source.connect(audioCtx.destination);
                source.start();
            }
            
            // 新增：播放降调BGM
            playDescendingBGM() {
                if (!this.settings.soundEnabled) return;
                
                console.log('开始播放降调BGM');
                
                // 带节奏感的降调BGM
                const duration = 2.0; // 2秒BGM
                const bufferSize = audioCtx.sampleRate * duration;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate); // 单声道
                const data = buffer.getChannelData(0);
                
                // 定义节奏模式：哒哒，哒哒哒哒
                const rhythm = [
                    { freq: 500, duration: 0.2, start: 0.0 },    // 哒
                    { freq: 440, duration: 0.2, start: 0.3 },    // 哒
                    { freq: 415, duration: 0.15, start: 0.8 },   // 哒
                    { freq: 392, duration: 0.15, start: 0.96 },   // 哒
                    { freq: 370, duration: 0.2, start: 1.12 },    // 最后两个长音
                    { freq: 349, duration: 0.2, start: 1.3 }     // 结束
                ];
                
                rhythm.forEach(note => {
                    const startSample = Math.floor(note.start * audioCtx.sampleRate);
                    const endSample = Math.floor((note.start + note.duration) * audioCtx.sampleRate);
                    
                    for (let i = startSample; i < endSample && i < bufferSize; i++) {
                        const t = (i - startSample) / audioCtx.sampleRate;
                        const envelope = Math.exp(-t * 3); // 更快的衰减，营造打击感
                        data[i] = Math.sin(2 * Math.PI * note.freq * t) * envelope * 0.3;
                    }
                });
                
                const source = audioCtx.createBufferSource();
                source.buffer = buffer;
                source.connect(audioCtx.destination);
                source.start();
                
                console.log('降调BGM播放完成');
            }
            
            // 新增：播放开局激励BGM
            playStartupBGM() {
                if (!this.settings.soundEnabled) return;
                
                console.log('开始播放开局BGM');
                
                // 清脆轻快的开局BGM - 12个音符
                const duration = 0.7; // 增加总时长到0.8秒
                const bufferSize = audioCtx.sampleRate * duration;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate); // 单声道
                const data = buffer.getChannelData(0);
                
                // 12个清脆的上升音符 - C大调
                const notes = [523, 587, 659, 698, 784, 880, 988, 1047, 1175, 1319, 1397, 1568]; // C5, D5, E5, F5, G5, A5, B5, C6, D6, E6, F6, G6
                const noteDuration = duration / notes.length;
                
                notes.forEach((freq, noteIndex) => {
                    const startSample = Math.floor(noteIndex * noteDuration * audioCtx.sampleRate);
                    const endSample = Math.floor((noteIndex + 1) * noteDuration * audioCtx.sampleRate);
                    
                    // 音量衰减：从振奋(0.4)逐渐降到沉浸(0.1)
                    const volumeDecay = 0.4 - (noteIndex / (notes.length - 1)) * 0.30;
                    
                    for (let i = startSample; i < endSample && i < bufferSize; i++) {
                        const t = (i - startSample) / audioCtx.sampleRate;
                        // 更慢的衰减，确保高频音符也能听到
                        const envelope = Math.exp(-t * 2) * (1 - t / noteDuration);
                        // 减少谐波，避免高频干扰
                        const fundamental = Math.sin(2 * Math.PI * freq * t);
                        const harmonic = Math.sin(2 * Math.PI * freq * 2 * t) * 0.1;
                        data[i] = (fundamental + harmonic) * envelope * volumeDecay;
                    }
                });
                
                const source = audioCtx.createBufferSource();
                source.buffer = buffer;
                source.connect(audioCtx.destination);
                source.start();
                
                console.log('开局BGM播放完成');
            }
            
            // 新增：清理死亡检测状态
            clearGameOverCheck() {
                if (this.gameOverCheckTimeout) {
                    clearTimeout(this.gameOverCheckTimeout);
                    this.gameOverCheckTimeout = null;
                }
                this.pendingGameOverCheck = false;
                this.isPerformingGameOverCheck = false;
            }

            endGame() {
                // 清理死亡检测状态
                this.clearGameOverCheck();
                
                // 清理死亡动画状态
                this.clearDeathAnimation();
                
                // 更新最高分
                const isNewRecord = this.score > this.highScore;
                if (isNewRecord) {
                    this.highScore = this.score;
                    SaveManager.saveHighScore(this.highScore); // 保存到独立存储
                    console.log('新纪录！最高分更新为:', this.highScore);
                }
                
                // 清除游戏存档，避免加载时卡在结束状态
                SaveManager.clearSave();
                
                // 显示游戏结束界面
                document.getElementById('game-over').classList.remove('hidden');
                
                // 根据是否新纪录调整结束弹窗样式与文案
                const overPanel = document.querySelector('#game-over .game-over-content');
                const titleEl = document.getElementById('game-over-title');
                const finalScoreLabelEl = document.getElementById('final-score-label');
                const highScoreBlock = document.getElementById('high-score').parentNode; // 整个最高分段落
                if (isNewRecord) {
                    overPanel.classList.add('best-record');
                    titleEl.textContent = (this.language === 'zh' ? '最高分' : 'BestScore');
                    // 隐藏原有的"Best Score"行
                    highScoreBlock.style.display = 'none';
                    // 微调布局：将当前分数标签隐藏，仅保留数值更突出
                    if (finalScoreLabelEl) finalScoreLabelEl.style.display = 'none';
                } else {
                    overPanel.classList.remove('best-record');
                    titleEl.textContent = (this.language === 'zh' ? '游戏结束' : 'Game Over');
                    highScoreBlock.style.display = '';
                    if (finalScoreLabelEl) finalScoreLabelEl.style.display = '';
                }
                
                // 分数动效：从小到大的效果
                const finalScoreElement = document.getElementById('final-score');
                const highScoreElement = document.getElementById('high-score');
                
                // 先设置最高分
                highScoreElement.textContent = this.highScore;
                
                // 分数动效：从0开始增长到最终分数
                let currentScore = 0;
                const targetScore = this.score;
                const duration = 800; // 0.8秒动画
                const startTime = Date.now();
                
                const animateScore = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // 使用缓动函数让动画更自然
                    const easeOutQuart = 1 - Math.pow(1 - progress, 4);
                    currentScore = Math.floor(easeOutQuart * targetScore);
                    
                    finalScoreElement.textContent = currentScore;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateScore);
                    } else {
                        // 动画完成，停止计分音效并给结束提示
                        stopScoreCountSfx(true);
                    }
                };
                
                // 启动计分音效（非语音）并开始动画
                startScoreCountSfx();
                animateScore();
                // 移除游戏结束时的语音播放，避免与消除音效混淆
            }

            // 新增：在指定 grid 上查找消除区域
            findConnectedGroupsOnGrid(grid) {
                const visited = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(false));
                const cellsToRemove = [];
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (!visited[row][col] && grid[row][col] > 0) {
                            const group = this.getConnectedGroupOnGrid(row, col, grid[row][col], visited, grid);
                            if (group.length >= 8) {
                                cellsToRemove.push(...group);
                            }
                        }
                    }
                }
                return cellsToRemove;
            }
            // 新增：在指定 grid 上查找连通块
            getConnectedGroupOnGrid(startRow, startCol, color, visited, grid) {
                const stack = [{row: startRow, col: startCol}];
                const group = [];
                const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                while (stack.length > 0) {
                    const {row, col} = stack.pop();
                    if (row < 0 || row >= this.gridSize || col < 0 || col >= this.gridSize || 
                        visited[row][col] || grid[row][col] !== color) {
                        continue;
                    }
                    visited[row][col] = true;
                    group.push({row, col});
                    directions.forEach(([dr, dc]) => {
                        stack.push({row: row + dr, col: col + dc});
                    });
                }
                return group;
            }

            // 生成[min, max]的随机整数
            randInt(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            // 初始化二三分策略（ESF）：将8拆为N∈{2,3}个正整数，且每个∈[1..6]，并缓存本局三色
            initErSanFenStrategy() {
                // 仅当activeColors>=3时使用前三种颜色；不足则用已有颜色循环
                const baseColors = this.activeColors.slice(0, 3);
                const colors = baseColors.length === 3 ? baseColors : (baseColors.length === 2 ? [...baseColors, baseColors[0]] : [1,2,3]);
                // 随机选择N=2或3
                const N = Math.random() < 0.5 ? 2 : 3;
                // 构造满足和为8、每个1..6的N元组
                let sizes = [];
                const attempts = 100;
                for (let t = 0; t < attempts; t++) {
                    if (N === 2) {
                        const a = this.randInt(1, 6);
                        const b = 8 - a;
                        if (b >= 1 && b <= 6) { sizes = [a, b]; break; }
                    } else {
                        const a = this.randInt(1, 6);
                        const b = this.randInt(1, 6);
                        const c = 8 - a - b;
                        if (c >= 1 && c <= 6) { sizes = [a, b, c]; break; }
                    }
                }
                if (sizes.length === 0) sizes = N === 2 ? [3,5] : [2,3,3];
                this.esfState = { active: true, sizes, index: 0, colors };
                // 异步二三分：为每个颜色准备一个"不放回"的面积池（sizes的乱序拷贝），跨N轮逐个取用
                if (this.useErSanFenAsync) {
                    const bagsByColor = {};
                    colors.forEach(col => {
                        const bag = [...sizes];
                        for (let i = bag.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [bag[i], bag[j]] = [bag[j], bag[i]];
                        }
                        bagsByColor[col] = bag;
                    });
                    this.esfAsync = { bagsByColor };
                } else {
                    this.esfAsync = null;
                }
            }

            // 取得当前ESF轮的面积与颜色序列
            getCurrentEsfSpec() {
                if (!this.esfState || !this.esfState.active) return null;
                const i = this.esfState.index % this.esfState.sizes.length;
                const area = this.esfState.sizes[i];
                // 三个块分别使用本局三色中的一种纯色
                const colors = this.esfState.colors;
                return { area, colors };
            }

            // 推进到下一ESF轮
            advanceEsfRound() {
                if (!this.esfState || !this.esfState.active) return;
                this.esfState.index++;
                if (this.esfState.index >= this.esfState.sizes.length) {
                    // 一轮ESF结束，可按需停止或循环；此处默认停止并标记完成
                    this.esfState.active = false;
                }
            }

            // 从形状库中随机取"面积恰好为area"的形状；若库中无精确面积，构造退化形状
            getRandomShapeByArea(area) {
                try {
                    const candidates = [];
                    for (const pattern of this.shapes) {
                        let count = 0;
                        for (let r = 0; r < pattern.length; r++) {
                            for (let c = 0; c < pattern[r].length; c++) {
                                if (pattern[r][c]) count++;
                            }
                        }
                        if (count === area) candidates.push(pattern);
                    }
                    if (candidates.length > 0) {
                        return candidates[Math.floor(Math.random() * candidates.length)];
                    }
                    // 兜底：构造连续条形（优先横条），保证面积
                    const maxW = Math.min(area, 5);
                    const w = Math.min(area, maxW);
                    const h = Math.ceil(area / w);
                    const pattern = Array.from({ length: h }, () => Array.from({ length: w }, () => 1));
                    // 若面积不整，去掉尾部多余格
                    let toRemove = w * h - area;
                    for (let r = h - 1; r >= 0 && toRemove > 0; r--) {
                        for (let c = w - 1; c >= 0 && toRemove > 0; c--) {
                            pattern[r][c] = 0; toRemove--;
                        }
                    }
                    return pattern;
                } catch (_) {
                    return [[1]];
                }
            }

            // 生成纯色矩阵，与给定pattern的形状一致
            buildPureColorMatrix(pattern, colorNumber) {
                const colors = [];
                for (let r = 0; r < pattern.length; r++) {
                    const row = [];
                    for (let c = 0; c < pattern[r].length; c++) {
                        row.push(pattern[r][c] ? colorNumber : 0);
                    }
                    colors.push(row);
                }
                return colors;
            }

            // 初始化单轮三分策略（STS）：把8拆成三份 a,b,c，各∈[1..6] 且和为8；三块统一使用同一种随机颜色
            initSingleTripleSplitStrategy() {
                // 尝试随机找到 a+b+c=8 的解
                let sizes = [];
                for (let t = 0; t < 200; t++) {
                    const a = this.randInt(1, 6);
                    const b = this.randInt(1, 6);
                    const c = 8 - a - b;
                    if (c >= 1 && c <= 6) { sizes = [a, b, c]; break; }
                }
                if (sizes.length === 0) sizes = [2,3,3];
                // 从启用色中随机挑一色，三块统一上色
                const baseColors = this.activeColors.length ? this.activeColors : [1,2,3];
                const color = baseColors[Math.floor(Math.random()*baseColors.length)];
                this.stsState = { active: true, sizes, color, completed: false };
            }

            // 完成STS后清理状态
            completeSingleTripleSplit() {
                this.stsState.active = false;
                this.stsState.completed = true;
                this.useSingleTripleSplitStrategy = false;
            }
        }

        let game;

        function getSelectedColorCount() {
            const select = document.getElementById('color-count-select');
            return parseInt(select.value);
        }
        function getSelectedMaxShapeColors() {
            const select = document.getElementById('max-shape-color-select');
            return parseInt(select.value);
        }

        function startGame() {
            game = new BlockBlast(getSelectedColorCount(), getSelectedMaxShapeColors());
            globalGameInstance = game; // 设置全局引用
        }

        function restartGame() {
            document.getElementById('game-over').classList.add('hidden');
            SaveManager.clearSave(); // 清除存档
            startGame();
        }
        
        function showSettings() {
            // 更新复选框状态
            document.getElementById('sound-toggle').checked = game.settings.soundEnabled;
            document.getElementById('vibration-toggle').checked = game.settings.vibrationEnabled;
            document.getElementById('voice-toggle').checked = game.settings.voiceEnabled;
            // 更新语言选择
            const langSelect = document.getElementById('language-select');
            if (langSelect) langSelect.value = game.language || 'zh';
            
            // 显示设置弹窗
            document.getElementById('settings-modal').classList.remove('hidden');
        }
        
        function closeSettings() {
            // 保存设置
            const soundEnabled = document.getElementById('sound-toggle').checked;
            const vibrationEnabled = document.getElementById('vibration-toggle').checked;
            const voiceEnabled = document.getElementById('voice-toggle').checked;
            const language = document.getElementById('language-select').value;
            
            game.updateSetting('soundEnabled', soundEnabled);
            game.updateSetting('vibrationEnabled', vibrationEnabled);
            game.updateSetting('voiceEnabled', voiceEnabled);
            game.updateSetting('language', language);
            
            // 隐藏设置弹窗
            document.getElementById('settings-modal').classList.add('hidden');
        }

        // 监听参数变化，自动重开游戏
        const colorCountSelect = document.getElementById('color-count-select');
        colorCountSelect.addEventListener('change', () => {
            startGame();
        });
        const maxShapeColorSelect = document.getElementById('max-shape-color-select');
        maxShapeColorSelect.addEventListener('change', () => {
            startGame();
        });
        // 启动游戏
        initDynamicColorStyles();
        startGame();

        // GM面板开关，false为正式版不显示，true为开发调试显示
        const SHOW_DEV_PANEL = false;
        // 页面加载后只隐藏显示和交互，不移除DOM
        window.addEventListener('DOMContentLoaded', function() {
            if (!SHOW_DEV_PANEL) {
                const devPanel = document.getElementById('developer-panel');
                if (devPanel) {
                    devPanel.style.display = 'none';
                    devPanel.style.pointerEvents = 'none';
                }
            }
        });

        // 计分音效（非语音）：随分数增长的短促提示音，仅受 soundEnabled 控制
        let scoreCountSfxTimer = null;
        let scoreCountSfxStep = 0;

        function startScoreCountSfx() {
            if (globalGameInstance && !globalGameInstance.settings.soundEnabled) return;
            stopScoreCountSfx(false);
            scoreCountSfxStep = 0;
            const intervalMs = 60;
            scoreCountSfxTimer = setInterval(() => {
                try {
                    const base = 420;
                    const freq = base + Math.min(900, scoreCountSfxStep * 28);
                    scoreCountSfxStep++;
                    const osc = audioCtx.createOscillator();
                    osc.type = 'triangle';
                    const gain = audioCtx.createGain();
                    gain.gain.setValueAtTime(0.06, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.05);
                    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                    osc.connect(gain).connect(audioCtx.destination);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.05);
                } catch (e) {}
            }, intervalMs);
        }

        function stopScoreCountSfx(withFinalize) {
            if (scoreCountSfxTimer) {
                clearInterval(scoreCountSfxTimer);
                scoreCountSfxTimer = null;
            }
            if (!withFinalize) return;
            if (globalGameInstance && !globalGameInstance.settings.soundEnabled) return;
            try {
                const now = audioCtx.currentTime;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                gain.gain.setValueAtTime(0.08, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
                osc.connect(gain).connect(audioCtx.destination);
                osc.frequency.setValueAtTime(660, now);
                osc.frequency.linearRampToValueAtTime(770, now + 0.12);
                osc.start(now);
                osc.stop(now + 0.18);
            } catch(e) {}
        }

        // 分数音效：根据分数大小播放不同的激励音效
        function playScoreSound(score) {
            if (globalGameInstance && !globalGameInstance.settings.soundEnabled) {
                return;
            }
            
            // 根据分数选择音效
            let soundId = 'nice'; // 默认音效
            
            if (score >= 1000) soundId = 'legendary';
            else if (score >= 800) soundId = 'unbelievable';
            else if (score >= 600) soundId = 'amazing';
            else if (score >= 400) soundId = 'incredible';
            else if (score >= 300) soundId = 'outstanding';
            else if (score >= 200) soundId = 'perfect';
            else if (score >= 150) soundId = 'wonderful';
            else if (score >= 100) soundId = 'fantastic';
            else if (score >= 80) soundId = 'awesome';
            else if (score >= 60) soundId = 'brilliant';
            else if (score >= 40) soundId = 'excellent';
            else if (score >= 30) soundId = 'great';
            else if (score >= 20) soundId = 'goodjob';
            else if (score >= 15) soundId = 'welldone';
            else if (score >= 10) soundId = 'sweet';
            else if (score >= 5) soundId = 'whoa';
            else if (score >= 3) soundId = 'wow';
            else soundId = 'cool';
            
            // 播放音效
            const target = voiceAudioMap[soundId];
            if (target) {
                try {
                    target.currentTime = 0;
                    target.play().catch(() => {});
                } catch (err) {
                    console.log('分数音效播放失败:', err);
                }
            }
        }
        
        // 控制台调试指令
        window.setScore = function(score) {
            if (typeof score !== 'number' || score < 0) {
                console.log('用法: setScore(分数) - 例如 setScore(1000)');
                return;
            }
            if (globalGameInstance) {
                globalGameInstance.score = score;
                globalGameInstance.updateScore();
                console.log('分数已设置为:', score);
            } else {
                console.log('游戏未初始化');
            }
        };
        
        window.addScore = function(points) {
            if (typeof points !== 'number') {
                console.log('用法: addScore(分数) - 例如 addScore(500)');
                return;
            }
            if (globalGameInstance) {
                globalGameInstance.score += points;
                globalGameInstance.updateScore();
                console.log('已增加分数:', points, '当前分数:', globalGameInstance.score);
            } else {
                console.log('游戏未初始化');
            }
        };
        
        window.getScore = function() {
            if (globalGameInstance) {
                console.log('当前分数:', globalGameInstance.score);
                return globalGameInstance.score;
            } else {
                console.log('游戏未初始化');
                return 0;
            }
        };
        
        // 泳道调试指令
        window.getLaneInfo = function() {
            if (globalGameInstance) {
                const laneProgress = globalGameInstance.score;
                const loopCount = globalGameInstance.laneLoopEnabled ? Math.floor(laneProgress / globalGameInstance.laneLoopLength) : 0;
                const currentProgress = globalGameInstance.laneLoopEnabled ? (laneProgress % globalGameInstance.laneLoopLength) : laneProgress;
                
                console.log('=== 泳道信息 ===');
                console.log('当前分数:', laneProgress);
                console.log('循环启用:', globalGameInstance.laneLoopEnabled);
                console.log('循环长度:', globalGameInstance.laneLoopLength);
                console.log('循环次数:', loopCount);
                console.log('当前进度:', currentProgress);
                console.log('泳道节点:', globalGameInstance.laneNodes);
                
                // 判断当前处于哪个泳道段
                let currentSegment = '未知';
                if (currentProgress < globalGameInstance.laneNodes[0]) {
                    currentSegment = '第1段 (TCR策略)';
                } else if (currentProgress >= globalGameInstance.laneNodes[0] && currentProgress < globalGameInstance.laneNodes[1]) {
                    currentSegment = '第2段 (策略2)';
                } else if (currentProgress >= globalGameInstance.laneNodes[1] && currentProgress < globalGameInstance.laneNodes[2]) {
                    currentSegment = '第3段 (策略1)';
                } else if (currentProgress >= globalGameInstance.laneNodes[2]) {
                    currentSegment = '第4段 (单块双色策略)';
                }
                console.log('当前泳道段:', currentSegment);
                
                return {
                    score: laneProgress,
                    loopCount: loopCount,
                    currentProgress: currentProgress,
                    currentSegment: currentSegment,
                    laneNodes: globalGameInstance.laneNodes
                };
            } else {
                console.log('游戏未初始化');
                return null;
            }
        };
        
        window.testLaneLoop = function(targetScore) {
            if (typeof targetScore !== 'number' || targetScore < 0) {
                console.log('用法: testLaneLoop(目标分数) - 例如 testLaneLoop(10000)');
                return;
            }
            if (globalGameInstance) {
                globalGameInstance.score = targetScore;
                globalGameInstance.updateScore();
                console.log(`分数设置为 ${targetScore}，查看泳道信息:`);
                getLaneInfo();
            } else {
                console.log('游戏未初始化');
            }
        };
        
        // 游戏内广告和购买集成函数
        window.revivePlayer = function() {
            // 复活玩家逻辑
            console.log('玩家复活');
            // 这里添加您的复活逻辑
        };
        
        window.addCoins = function(amount) {
            // 添加金币逻辑
            if (!window.gameCoins) window.gameCoins = 0;
            window.gameCoins += amount;
            console.log(`获得 ${amount} 金币，总计: ${window.gameCoins}`);
            // 更新UI显示
            const coinsDisplay = document.getElementById('coins-display');
            if (coinsDisplay) {
                coinsDisplay.textContent = window.gameCoins;
            }
        };
        
        window.giveHint = function() {
            // 给予提示逻辑
            console.log('获得提示');
            // 这里添加您的提示逻辑
        };
        
        // 横幅广告测试与控制（AdMob v1）
        window.bannerConfig = {
            adUnitId: 'ca-app-pub-7061618651809737/4419786189',
            size: 'SMART_BANNER'
        };
        
        window.bannerCreate = async function(config) {
            if (typeof admob === 'undefined') throw new Error('AdMob 未加载');
            try {
                try { adDbg('调用 banner.create ...'); } catch(_) {}
                const cfg = config || window.bannerConfig || {};
                const unitId = cfg.adUnitId;
                if (!unitId) throw new Error('missing adUnitId');
                if (window.__bannerAd && typeof window.__bannerAd.hide === 'function') {
                    try { await window.__bannerAd.hide(); } catch(_) {}
                }
                if (!admob.BannerAd) throw new Error('admob.BannerAd unavailable');
                const b = new admob.BannerAd({ adUnitId: unitId, position: 'bottom', offset: 0 });
                window.__bannerAd = b;
                try { await b.load(); } catch(_) {}
                try { adDbg('banner.create 成功(实例化)'); } catch(_) {}
                return b;
            } catch (e) {
                console.error('横幅创建失败:', e);
                try { adDbg('banner.create 失败: ' + (e && (e.message||e.toString())), true); } catch(_) {}
                throw e;
            }
        };
        
        window.bannerShow = async function() {
            try {
                if (!window.__bannerAd) {
                    try { adDbg('banner.show 触发：先创建'); } catch(_) {}
                    await window.bannerCreate();
                }
                try { adDbg('调用 banner.show ...'); } catch(_) {}
                await window.__bannerAd.show();
                try { adDbg('banner.show 成功，显示中'); } catch(_) {}
                var el = document.getElementById('admob-banner');
                if (el) el.style.display = 'none';
            } catch (e) {
                console.error('横幅显示失败:', e);
                try { adDbg('banner.show 失败: ' + (e && (e.message||e.toString())), true); } catch(_) {}
            }
        };
        
        window.bannerHide = function() {
            try {
                try { adDbg('调用 banner.hide'); } catch(_) {}
                if (window.__bannerAd && typeof window.__bannerAd.hide === 'function') {
                    window.__bannerAd.hide();
                }
                var el = document.getElementById('admob-banner');
                if (el) el.style.display = 'none';
            } catch (e) {
                console.error('横幅隐藏失败:', e);
            }
        };
        
        
        
        // 游戏失败时显示激励视频选项
        window.showReviveOption = function() {
            if (window.adManager && window.adManager.rewardedAd) {
                if (confirm('观看广告复活？')) {
                    window.adManager.offerRewardVideo('revive');
                }
            }
        };
        
        // 拿起块时"呼"的风声
        
        // 广告系统初始化 - 兼容"脚本在deviceready之后才加载"的情况
        (function() {
            let inited = false;
            async function initAd() {
                if (inited) return;
                inited = true;
                try { adDbg('开始初始化广告系统...'); } catch(_) {}
                if (typeof admob === 'undefined') {
                    try { adDbg('AdMob插件未找到！', true); } catch(_) {}
                    return;
                }
                try {
                    // 为 start 增加超时兜底，避免 Promise 长时间不回调
                    const START_TIMEOUT_MS = 5000;
                    const started = await Promise.race([
                        (async () => { await admob.start(); return true; })(),
                        new Promise((_, reject) => setTimeout(() => reject(new Error('start-timeout')), START_TIMEOUT_MS))
                    ]);
                    if (started) {
                        try { adDbg('AdMob初始化成功'); } catch(_) {}
                    }
                    // 改为按冷启动延迟展示
                    scheduleBannerShow();
                } catch (e) {
                    try { adDbg('广告初始化/创建失败: ' + (e && (e.message||e.toString())), true); } catch(_) {}
                    // 兜底：即便 start 超时，也按冷启动延迟再尝试一次
                    scheduleBannerShow();
                }
            }
            document.addEventListener('deviceready', requestATTrackingPermission, { once: true });
            // 如果此脚本在 deviceready 之后才注入，补偿一次
            if (window.cordova && window.cordova.platformId && document.readyState === 'complete') {
                setTimeout(requestATTrackingPermission, 0);
            }
        })();

        document.addEventListener('deviceready', function () {
            if (window.StatusBar && typeof StatusBar.overlaysWebView === 'function') {
                try { StatusBar.overlaysWebView(true); } catch (e) {}
            }
            if (window.StatusBar && typeof StatusBar.styleLightContent === 'function') {
                try { StatusBar.styleLightContent(); } catch (e) {}
            }
        }, { once: true });
        // 如果此脚本在 deviceready 之后才注入，补偿一次
    </script>
    
    <!-- 广告脚本：已内联初始化，移除外部脚本以避免冲突（admob v1） -->
    
    <!-- AdMob横幅广告 -->
    <div id="admob-banner" style="position: fixed; bottom: 0; left: 0; width: 100%; height: 50px; background: #f0f0f0; z-index: 1000; display: none;"></div>
    
    
</body>
</html>